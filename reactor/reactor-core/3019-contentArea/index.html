<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Stephane Maldini, Simon BaslÃ©">
<title>Reactor 3 Reference Guide</title>
<style>
@import url(https://fonts.googleapis.com/css?family=Montserrat:400,700);
@import url(https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/1.6.2/semantic.min.css);


#header .details br+span.author:before {
    content: "\00a0\0026\00a0";
    color: rgba(0,0,0,.85);
}

#header .details br+span.email:before {
    content: "(";
}

#header .details br+span.email:after {
    content: ")";
}

/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
@import url(https://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.css);

article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary {
    display: block;
}

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video {
    display: inline-block;
}

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) {
    display: none;
    height: 0;
}

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template {
    display: none;
}

script {
    display: none !important;
}

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html {
    font-family: sans-serif; /* 1 */
    -ms-text-size-adjust: 100%; /* 2 */
    -webkit-text-size-adjust: 100%; /* 2 */
}

/** Remove default margin. */
body {
    margin: 0;
}

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a {
    background: transparent;
}

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus {
    outline: thin dotted;
}

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover {
    outline: 0;
}

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 {
    font-size: 2em;
    margin: 1.2em 0;
}

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] {
    border-bottom: 1px dotted;
}

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong {
    font-weight: bold;
}

/** Address styling not present in Safari 5 and Chrome. */
dfn {
    font-style: italic;
}

/** Address differences between Firefox and other browsers. */
hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/** Address styling not present in IE 8/9. */
mark {
    background: #ff0;
    color: #000;
}

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp {
    font-family: monospace, serif;
    font-size: 1em;
}

/** Improve readability of pre-formatted text in all browsers. */
pre {
    white-space: pre-wrap;
}

/** Set consistent quote types. */
q {
    quotes: "\201C" "\201D" "\2018" "\2019";
}

/** Address inconsistent and variable font size in all browsers. */
small {
    font-size: 80%;
}

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img {
    border: 0;
}

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) {
    overflow: hidden;
}

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure {
    margin: 0;
}

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend {
    border: 0; /* 1 */
    padding: 0; /* 2 */
}

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea {
    font-family: inherit; /* 1 */
    font-size: 100%; /* 2 */
    margin: 0; /* 3 */
}

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input {
    line-height: normal;
}

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select {
    text-transform: none;
}

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
}

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] {
    cursor: default;
}

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
}

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table {
    border-collapse: collapse;
    border-spacing: 0;
}

meta.foundation-mq-small {
    font-family: "only screen and (min-width: 768px)";
    width: 768px;
}

meta.foundation-mq-medium {
    font-family: "only screen and (min-width:1280px)";
    width: 1280px;
}

meta.foundation-mq-large {
    font-family: "only screen and (min-width:1440px)";
    width: 1440px;
}

*, *:before, *:after {
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}

html, body {
    font-size: 100%;
}

body {
    background: white;
    color: #34302d;
    padding: 0;
    margin: 0;
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
    font-weight: normal;
    font-style: normal;
    line-height: 1.8em;
    position: relative;
    cursor: auto;
}

#content, #content p {
    line-height: 1.8em;
    margin-top: 1.5em;
}

#content li p {
  margin-top: 0.25em;
}

a:hover {
    cursor: pointer;
}

img, object, embed {
    max-width: 100%;
    height: auto;
}

object, embed {
    height: 100%;
}

img {
    -ms-interpolation-mode: bicubic;
}

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object {
    max-width: none !important;
}

.left {
    float: left !important;
}

.right {
    float: right !important;
}

.text-left {
    text-align: left !important;
}

.text-right {
    text-align: right !important;
}

.text-center {
    text-align: center !important;
}

.text-justify {
    text-align: justify !important;
}

.hide {
    display: none;
}

.antialiased, body {
    -webkit-font-smoothing: antialiased;
}

img {
    display: inline-block;
    vertical-align: middle;
}

textarea {
    height: auto;
    min-height: 50px;
}

select {
    width: 100%;
}

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: 1.21875em;
}

.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption {
    color: #6db33f;
    font-weight: 300;
    margin-top: 0.2em;
    margin-bottom: 0.5em;
}

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td {
    margin: 0;
    padding: 0;
    direction: ltr;
}

/* Default Link Styles */
a {
    color: #6db33f;
    line-height: inherit;
    text-decoration: none;
}

a:hover, a:focus {
    color: #6db33f;
    text-decoration: underline;
}

a img {
    border: none;
}

/* Default paragraph styles */
p {
    font-family: inherit;
    font-weight: normal;
    font-size: 1em;
    margin-bottom: 1.25em;
    text-rendering: optimizeLegibility;
}

p aside {
    font-size: 0.875em;
    font-style: italic;
}

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    font-family: "Montserrat", Arial, sans-serif;
    font-weight: normal;
    font-style: normal;
    color: #34302d;
    text-rendering: optimizeLegibility;
    margin-top: 1.6em;
    margin-bottom: 0.6em;
}

h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small {
    font-size: 60%;
    color: #6db33f;
    line-height: 0;
}

h1 {
    font-size: 2.125em;
}

h2 {
    font-size: 1.6875em;
}

h3, #toctitle, .sidebarblock > .content > .title {
    font-size: 1.375em;
}

h4 {
    font-size: 1.125em;
}

h5 {
    font-size: 1.125em;
}

h6 {
    font-size: 1em;
}

hr {
    border: solid #dcd2c9;
    border-width: 1px 0 0;
    clear: both;
    margin: 1.25em 0 1.1875em;
    height: 0;
}

/* Helpful Typography Defaults */
em, i {
    font-style: italic;
    line-height: inherit;
}

strong, b {
    font-weight: bold;
    line-height: inherit;
}

small {
    font-size: 60%;
    line-height: inherit;
}

code {
    font-family: Consolas, "Liberation Mono", Courier, monospace;
    font-weight: bold;
    color: #305CB5;
}

/* Lists */
ul, ol, dl {
    font-size: 1em;
    margin-bottom: 1.25em;
    list-style-position: outside;
    font-family: inherit;
}

ul, ol {
    margin-left: 1.5em;
}

ul.no-bullet, ol.no-bullet {
    margin-left: 1.5em;
}

/* Unordered Lists */
ul li ul, ul li ol {
    margin-left: 1.25em;
    margin-bottom: 0;
    font-size: 1em; /* Override nested font-size change */
}

ul.square li ul, ul.circle li ul, ul.disc li ul {
    list-style: inherit;
}

ul.square {
    list-style-type: square;
}

ul.circle {
    list-style-type: circle;
}

ul.disc {
    list-style-type: disc;
}

ul.no-bullet {
    list-style: none;
}

/* Ordered Lists */
ol li ul, ol li ol {
    margin-left: 1.25em;
    margin-bottom: 0;
}

/* Definition Lists */
dl dt {
    margin-bottom: 0.3125em;
    font-weight: bold;
}

dl dd {
    margin-bottom: 1.25em;
}

/* Abbreviations */
abbr, acronym {
    text-transform: uppercase;
    font-size: 90%;
    color: #34302d;
    border-bottom: 1px dotted #dddddd;
    cursor: help;
}

abbr {
    text-transform: none;
}

/* Blockquotes */
blockquote {
    margin: 0 0 1.25em;
    padding: 0.5625em 1.25em 0 1.1875em;
    border-left: 1px solid #dddddd;
}

blockquote cite {
    display: block;
    font-size: 0.8125em;
    color: #655241;
}

blockquote cite:before {
    content: "\2014 \0020";
}

blockquote cite a, blockquote cite a:visited {
    color: #655241;
}

blockquote, blockquote p {
    color: #34302d;
}

/* Microformats */
.vcard {
    display: inline-block;
    margin: 0 0 1.25em 0;
    border: 1px solid #dddddd;
    padding: 0.625em 0.75em;
}

.vcard li {
    margin: 0;
    display: block;
}

.vcard .fn {
    font-weight: bold;
    font-size: 0.9375em;
}

.vevent .summary {
    font-weight: bold;
}

.vevent abbr {
    cursor: auto;
    text-decoration: none;
    font-weight: bold;
    border: none;
    padding: 0 0.0625em;
}

@media only screen and (min-width: 768px) {
    h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    }

    h1 {
        font-size: 2.75em;
    }

    h2 {
        font-size: 2.3125em;
    }

    h3, #toctitle, .sidebarblock > .content > .title {
        font-size: 1.6875em;
    }

    h4 {
        font-size: 1.4375em;
    }
}

/* Print styles.  Inlined to avoid required HTTP connection: www.phpied.com/delay-loading-your-print-css/ Credit to Paul Irish and HTML5 Boilerplate (html5boilerplate.com)
*/
.print-only {
    display: none !important;
}

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a, a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
        content: "";
    }

    pre, blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr, img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p, h2, h3, #toctitle, .sidebarblock > .content > .title {
        orphans: 3;
        widows: 3;
    }

    h2, h3, #toctitle, .sidebarblock > .content > .title {
        page-break-after: avoid;
    }

    .hide-on-print {
        display: none !important;
    }

    .print-only {
        display: block !important;
    }

    .hide-for-print {
        display: none !important;
    }

    .show-for-print {
        display: inherit !important;
    }
}

/* Tables */
table {
    background: white;
    margin-bottom: 1.25em;
    border: solid 1px #34302d;
}

table thead, table tfoot {
    font-weight: bold;
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
    padding: 0.5em 0.625em 0.625em;
    font-size: inherit;
    color: #34302d;
    text-align: left;
}

table thead tr th {
    color: white;
    background: #34302d;
}

table tr th, table tr td {
    padding: 0.5625em 0.625em;
    font-size: inherit;
    color: #34302d;
    border: 0 none;
}

table tr.even, table tr.alt, table tr:nth-of-type(even) {
    background: #f2F2F2;
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
    display: table-cell;
}

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after {
    content: " ";
    display: table;
}

.clearfix:after, .float-group:after {
    clear: both;
}

*:not(pre) > code {
    font-size: inherit;
    padding: 0;
    background-color: inherit;
    border: 0 solid #dddddd;
    -webkit-border-radius: 6px;
    border-radius: 6px;
    text-shadow: none;
    overflow-wrap: anywhere;
}

@media only screen and (min-width: 1280px) {
    *:not(pre) > code {
        white-space: nowrap;
        overflow-wrap: normal;
    }
}

pre, pre > code {
    color: black;
    font-family: monospace, serif;
    font-weight: normal;
}

.keyseq {
    color: #774417;
}

kbd:not(.keyseq) {
    display: inline-block;
    color: #211306;
    font-size: 0.75em;
    background-color: #F7F7F7;
    border: 1px solid #ccc;
    -webkit-border-radius: 3px;
    border-radius: 3px;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset;
    margin: -0.15em 0.15em 0 0.15em;
    padding: 0.2em 0.6em 0.2em 0.5em;
    vertical-align: middle;
    white-space: nowrap;
}

.keyseq kbd:first-child {
    margin-left: 0;
}

.keyseq kbd:last-child {
    margin-right: 0;
}

.menuseq, .menu {
    color: black;
}

b.button:before, b.button:after {
    position: relative;
    top: -1px;
    font-weight: normal;
}

b.button:before {
    content: "[";
    padding: 0 3px 0 2px;
}

b.button:after {
    content: "]";
    padding: 0 2px 0 3px;
}

p a > code:hover {
    color: #541312;
}

#header, #content, #footnotes, #footer {
    width: 100%;
    margin-left: auto;
    margin-right: auto;
    margin-top: 0;
    margin-bottom: 0;
    max-width: max(80em, 60%);
    *zoom: 1;
    position: relative;
    padding-left: 2em;
    padding-right: 2em;
}

@media only screen and (min-width: 768px) {
    #header, #content, #footnotes, #footer {
        padding-left: 4em;
        padding-right: 4em;
    }
}

#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after {
    content: " ";
    display: table;
}

#header:after, #content:after, #footnotes:after, #footer:after {
    clear: both;
}

#header {
    margin-bottom: 2.5em;
}

#header > h1 {
    color: #34302d;
    font-weight: 400;
}

#header span {
    color: #34302d;
}

#header #revnumber {
    text-transform: capitalize;
}

#header br {
    display: none;
}

#header br + span {
}

#revdate {
    display: block;
}

#toc {
    border-bottom: 1px solid #e6dfd8;
    padding-bottom: 1.25em;
}

#toc > ul {
    margin-left: 0.25em;
}

#toc ul.sectlevel0 > li > a {
    font-style: italic;
}

#toc ul.sectlevel0 ul.sectlevel1 {
    margin-left: 0;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}

#toc ul {
    list-style-type: none;
}

#toctitle {
    color: #385dbd;
}

@media only screen and (min-width: 768px) {
    body.toc2 {
        padding-left: 15em;
        padding-right: 0;
    }

    #toc.toc2 {
        position: fixed;
        width: 15em;
        left: 0;
        border-bottom: 0;
        z-index: 1000;
        padding: 1em;
        height: 100%;
        top: 0px;
        background: #F1F1F1;
        overflow: auto;

        -moz-transition-property: top;
        -o-transition-property: top;
        -webkit-transition-property: top;
        transition-property: top;
        -moz-transition-duration: 0.4s;
        -o-transition-duration: 0.4s;
        -webkit-transition-duration: 0.4s;
        transition-duration: 0.4s;
    }

    #reactor-header {
        position: fixed;
        top: -75px;
        left: 0;
        right: 0;
        height: 75px;


        -moz-transition-property: top;
        -o-transition-property: top;
        -webkit-transition-property: top;
        transition-property: top;
        -moz-transition-duration: 0.4s;
        -o-transition-duration: 0.4s;
        -webkit-transition-duration: 0.4s;
        transition-duration: 0.4s;
    }

    body.head-show #toc.toc2 {
        top: 75px;
    }
    body.head-show #reactor-header {
        top: 0;
    }

    #toc.toc2 a {
        color: #34302d;
        font-family: Montserrat;
    }

    #toc.toc2 #toctitle {
        margin-top: 0;
        font-size: 1.2em;
    }

    #toc.toc2 > ul {
        font-size: .90em;
    }

    #toc.toc2 ul ul {
        margin-left: 0;
        padding-left: 0.4em;
    }

    #toc.toc2 ul.sectlevel0 ul.sectlevel1 {
        padding-left: 0;
        margin-top: 0.5em;
        margin-bottom: 0.5em;
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 15em;
    }

    body.toc2.toc-right #toc.toc2 {
        border-right: 0;
        border-left: 1px solid #e6dfd8;
        left: auto;
        right: 0;
    }
}

@media only screen and (min-width: 1280px) {
    body.toc2 {
        padding-left: 20em;
        padding-right: 0;
    }

    #toc.toc2 {
        width: 20em;
    }

    #toc.toc2 #toctitle {
        font-size: 1.375em;
    }

    #toc.toc2 > ul {
        font-size: 0.95em;
    }

    #toc.toc2 ul ul {
        padding-left: 1.25em;
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 20em;
    }
}

#content #toc {
    border-style: solid;
    border-width: 1px;
    border-color: #d9d9d9;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #f2f2f2;
    border-width: 0;
    -webkit-border-radius: 6px;
    border-radius: 6px;
}

#content #toc > :first-child {
    margin-top: 0;
}

#content #toc > :last-child {
    margin-bottom: 0;
}

#content #toc a {
    text-decoration: none;
}

#content #toctitle {
    font-weight: bold;
    font-family: "Montserrat", Arial, sans-serif;
    font-size: 1em;
    padding-left: 0.125em;
}

#footer {
    max-width: 100%;
    background-color: white;
    padding: 1.25em;
    color: #CCC;
    border-top: 3px solid #F1F1F1;
}

#footer-text {
    color: #444;
    line-height: 1.44;
}

.sect1 {
    padding-bottom: 1.25em;
}

.sect1 + .sect1 {
    border-top: 1px solid #e6dfd8;
}

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor {
    position: absolute;
    width: 1em;
    margin-left: -1em;
    display: block;
    text-decoration: none;
    visibility: hidden;
    text-align: center;
    font-weight: normal;
}

#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before {
    content: '\00A7';
    font-size: .85em;
    vertical-align: text-top;
    display: block;
    margin-top: 0.05em;
}

#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover {
    visibility: visible;
}

#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link {
    color: #34302d;
    text-decoration: none;
}

#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover {
    color: #34302d;
}

.paragraph {
    overflow-wrap: break-word;
}

.imageblock, .literalblock, .listingblock, .mathblock, .verseblock, .videoblock {
    margin-bottom: 1.25em;
    margin-top: 1.25em;
}

.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title {
    text-align: left;
    font-weight: bold;
}

.tableblock {
    overflow-wrap: anywhere;
}

.tableblock > caption {
    text-align: left;
    font-weight: bold;
    white-space: nowrap;
    overflow: visible;
    max-width: 0;
}

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: inherit;
}

.admonitionblock > table {
    border: 0;
    background: none;
    width: 100%;
    table-layout: fixed;
}

.admonitionblock > table td.icon {
    text-align: center;
    width: 48px;
}

.admonitionblock > table td.icon img {
    max-width: none;
}

.admonitionblock > table td.icon .title {
    font-weight: bold;
    text-transform: uppercase;
}

.admonitionblock > table td.content {
    padding-left: 1.125em;
    padding-right: 1.25em;
    border-left: 1px solid #dcd2c9;
    color: #34302d;
    overflow-wrap: break-word;
}

.admonitionblock > table td.content > :last-child > :last-child {
    margin-bottom: 0;
}

@media only screen and (min-width: 768px) {
    .admonitionblock > table td.icon {
        width: 80px;
    }
}

.exampleblock > .content {
    border-style: solid;
    border-width: 1px;
    border-color: #f3e0ce;
    margin-bottom: 1.25em;
    padding: 1.25em 1em;
    background: white;
    -webkit-border-radius: 6px;
    border-radius: 6px;
}

.exampleblock > .content > :first-child {
    margin-top: 0;
}

.exampleblock > .content > :last-child {
    margin-bottom: 0;
}

.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p {
    color: #333333;
}

.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 {
    margin-bottom: 0.625em;
}

.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader {
}

.exampleblock.result > .content {
    -webkit-box-shadow: 0 1px 8px #d9d9d9;
    box-shadow: 0 1px 8px #d9d9d9;
}

@media only screen and (min-width: 768px) {
    .exampleblock > .content {
        padding: 1.25em;
    }
}

.sidebarblock {
    padding: 1.25em 2em;
    background: #F1F1F1;
    margin: 2em -2em;

}

.sidebarblock > :first-child {
    margin-top: 0;
}

.sidebarblock > :last-child {
    margin-bottom: 0;
}

.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p {
    color: #333333;
}

.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 {
    margin-bottom: 0.625em;
}

.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader {
}

.sidebarblock > .content > .title {
    color: #6db33f;
    margin-top: 0;
    font-size: 1.2em;
}

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child {
    margin-bottom: 0;
}

/*.literalblock .content pre.highlight, .listingblock .content pre.highlight {*/
    /*background-color: #f1f8ec;*/
/*}*/
/*.literalblock pre:not([class]), .listingblock pre:not([class]) {*/
    /*background-color: #f1f8ec;*/
/*}*/

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
    border-width: 1px;
    border-style: solid;
    border-color: rgba(21, 35, 71, 0.1);
    -webkit-border-radius: 6px;
    border-radius: 6px;
    padding: 0.8em;
    word-wrap: break-word;
}

.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap {
    overflow-x: auto;
    white-space: pre;
    word-wrap: normal;
}

.literalblock pre > code, .literalblock pre[class] > code, .listingblock pre > code, .listingblock pre[class] > code {
    display: block;
}

@media only screen {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 0.72em;
    }
}

@media only screen and (min-width: 768px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 0.81em;
    }
}

@media only screen and (min-width: 1280px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 0.9em;
    }
}

.listingblock pre.highlight {
    padding: 0;
    line-height: 1em;
}

.listingblock pre.highlight > code {
    padding: 0.8em;
}

.listingblock > .content {
    position: relative;
}

.listingblock:hover code[class*=" language-"]:before {
    text-transform: uppercase;
    font-size: 0.9em;
    color: #999;
    position: absolute;
    top: 0.375em;
    right: 0.375em;
}

.listingblock:hover code.asciidoc:before {
    content: "asciidoc";
}

.listingblock:hover code.clojure:before {
    content: "clojure";
}

.listingblock:hover code.css:before {
    content: "css";
}

.listingblock:hover code.groovy:before {
    content: "groovy";
}

.listingblock:hover code.html:before {
    content: "html";
}

.listingblock:hover code.java:before {
    content: "java";
}

.listingblock:hover code.javascript:before {
    content: "javascript";
}

.listingblock:hover code.python:before {
    content: "python";
}

.listingblock:hover code.ruby:before {
    content: "ruby";
}

.listingblock:hover code.sass:before {
    content: "sass";
}

.listingblock:hover code.scss:before {
    content: "scss";
}

.listingblock:hover code.xml:before {
    content: "xml";
}

.listingblock:hover code.yaml:before {
    content: "yaml";
}

.listingblock.terminal pre .command:before {
    content: attr(data-prompt);
    padding-right: 0.5em;
    color: #999;
}

.listingblock.terminal pre .command:not([data-prompt]):before {
    content: '$';
}

table.pyhltable {
    border: 0;
    margin-bottom: 0;
}

table.pyhltable td {
    vertical-align: top;
    padding-top: 0;
    padding-bottom: 0;
}

table.pyhltable td.code {
    padding-left: .75em;
    padding-right: 0;
}

.highlight.pygments .lineno, table.pyhltable td:not(.code) {
    color: #999;
    padding-left: 0;
    padding-right: .5em;
    border-right: 1px solid #dcd2c9;
}

.highlight.pygments .lineno {
    display: inline-block;
    margin-right: .25em;
}

table.pyhltable .linenodiv {
    background-color: transparent !important;
    padding-right: 0 !important;
}

.quoteblock {
    margin: 0 0 1.25em;
    padding: 0.5625em 1.25em 0 1.1875em;
    border-left: 3px solid #dddddd;
}

.quoteblock blockquote {
    margin: 0 0 1.25em 0;
    padding: 0 0 0.5625em 0;
    border: 0;
}

.quoteblock blockquote > .paragraph:last-child p {
    margin-bottom: 0;
}

.quoteblock .attribution {
    margin-top: -.25em;
    padding-bottom: 0.5625em;
    font-size: 0.8125em;
    overflow-wrap: break-word;
}

.quoteblock .attribution br {
    display: none;
}

.quoteblock .attribution cite {
    display: block;
    margin-bottom: 0.625em;
}

table thead th, table tfoot th {
    font-weight: bold;
}

table.tableblock.grid-all {
    border-collapse: separate;
    border-radius: 6px;
    border-top: 1px solid #34302d;
    border-bottom: 1px solid #34302d;
}

table.tableblock.frame-topbot, table.tableblock.frame-none {
    border-left: 0;
    border-right: 0;
}

table.tableblock.frame-sides, table.tableblock.frame-none {
    border-top: 0;
    border-bottom: 0;
}

table.tableblock td .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child {
    margin-bottom: 0;
}

th.tableblock.halign-left, td.tableblock.halign-left {
    text-align: left;
}

th.tableblock.halign-right, td.tableblock.halign-right {
    text-align: right;
}

th.tableblock.halign-center, td.tableblock.halign-center {
    text-align: center;
}

th.tableblock.valign-top, td.tableblock.valign-top {
    vertical-align: top;
}

th.tableblock.valign-bottom, td.tableblock.valign-bottom {
    vertical-align: bottom;
}

th.tableblock.valign-middle, td.tableblock.valign-middle {
    vertical-align: middle;
}

tbody tr th {
    display: table-cell;
    background: rgba(105, 60, 22, 0.25);
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
    color: #211306;
    font-weight: bold;
}

td > div.verse {
    white-space: pre;
}

ol {
    margin-left: 1.75em;
}

ul li ol {
    margin-left: 1.5em;
}

dl dd {
    margin-left: 1.125em;
}

dl dd:last-child, dl dd:last-child > :last-child {
    margin-bottom: 0;
}

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist {
    margin-bottom: 0.625em;
}

.ulist {
    overflow-wrap: break-word;
}

ul.unstyled, ol.unnumbered, ul.checklist, ul.none {
    list-style-type: none;
}

ul.unstyled, ol.unnumbered, ul.checklist {
    margin-left: 0.625em;
}

ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child {
    margin-right: 0.25em;
}

ul.checklist li > p:first-child > input[type="checkbox"]:first-child {
    position: relative;
    top: 1px;
}

ul.inline {
    margin: 0 auto 0.625em auto;
    margin-left: -1.375em;
    margin-right: 0;
    padding: 0;
    list-style: none;
    overflow: hidden;
}

ul.inline > li {
    list-style: none;
    float: left;
    margin-left: 1.375em;
    display: block;
}

ul.inline > li > * {
    display: block;
}

.unstyled dl dt {
    font-weight: normal;
    font-style: normal;
}

ol.arabic {
    list-style-type: decimal;
}

ol.decimal {
    list-style-type: decimal-leading-zero;
}

ol.loweralpha {
    list-style-type: lower-alpha;
}

ol.upperalpha {
    list-style-type: upper-alpha;
}

ol.lowerroman {
    list-style-type: lower-roman;
}

ol.upperroman {
    list-style-type: upper-roman;
}

ol.lowergreek {
    list-style-type: lower-greek;
}

.hdlist > table, .colist > table {
    border: 0;
    background: none;
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
    background: none;
}

td.hdlist1 {
    padding-right: .75em;
    font-weight: bold;
}

td.hdlist1, td.hdlist2 {
    vertical-align: top;
}

.literalblock + .colist, .listingblock + .colist {
    margin-top: -0.5em;
}

.colist > table {
    overflow-wrap: anywhere;
}

.colist > table tr > td:first-of-type {
    padding: 0 .75em;
}

.colist > table tr > td:last-of-type {
    padding: 0.25em 0;
}

.qanda > ol > li > p > em:only-child {
    color: #063f40;
}

.thumb, .th {
    line-height: 0;
    display: inline-block;
    border: solid 4px white;
    -webkit-box-shadow: 0 0 0 1px #dddddd;
    box-shadow: 0 0 0 1px #dddddd;
}

.imageblock.left, .imageblock[style*="float: left"] {
    margin: 0.25em 0.625em 1.25em 0;
}

.imageblock.right, .imageblock[style*="float: right"] {
    margin: 0.25em 0 1.25em 0.625em;
}

.imageblock > .title {
    margin-bottom: 0;
}

.imageblock.thumb, .imageblock.th {
    border-width: 6px;
}

.imageblock.thumb > .title, .imageblock.th > .title {
    padding: 0 0.125em;
}

.image.left, .image.right {
    margin-top: 0.25em;
    margin-bottom: 0.25em;
    display: inline-block;
    line-height: 0;
}

.image.left {
    margin-right: 0.625em;
}

.image.right {
    margin-left: 0.625em;
}

a.image {
    text-decoration: none;
}

span.footnote, span.footnoteref {
    vertical-align: super;
    font-size: 0.875em;
}

span.footnote a, span.footnoteref a {
    text-decoration: none;
}

#footnotes {
    padding-top: 0.75em;
    padding-bottom: 0.75em;
    margin-bottom: 0.625em;
}

#footnotes hr {
    width: 20%;
    min-width: 6.25em;
    margin: -.25em 0 .75em 0;
    border-width: 1px 0 0 0;
}

#footnotes .footnote {
    padding: 0 0.375em;
    font-size: 0.875em;
    margin-left: 1.2em;
    text-indent: -1.2em;
    margin-bottom: .2em;
}

#footnotes .footnote a:first-of-type {
    font-weight: bold;
    text-decoration: none;
}

#footnotes .footnote:last-of-type {
    margin-bottom: 0;
}

#content #footnotes {
    margin-top: -0.625em;
    margin-bottom: 0;
    padding: 0.75em 0;
}

.gist .file-data > table {
    border: none;
    background: #fff;
    width: 100%;
    margin-bottom: 0;
}

.gist .file-data > table td.line-data {
    width: 99%;
}

div.unbreakable {
    page-break-inside: avoid;
}

.big {
    font-size: larger;
}

.small {
    font-size: smaller;
}

.underline {
    text-decoration: underline;
}

.overline {
    text-decoration: overline;
}

.line-through {
    text-decoration: line-through;
}

.aqua {
    color: #00bfbf;
}

.aqua-background {
    background-color: #00fafa;
}

.black {
    color: black;
}

.black-background {
    background-color: black;
}

.blue {
    color: #0000bf;
}

.blue-background {
    background-color: #0000fa;
}

.fuchsia {
    color: #bf00bf;
}

.fuchsia-background {
    background-color: #fa00fa;
}

.gray {
    color: #606060;
}

.gray-background {
    background-color: #7d7d7d;
}

.green {
    color: #006000;
}

.green-background {
    background-color: #007d00;
}

.lime {
    color: #00bf00;
}

.lime-background {
    background-color: #00fa00;
}

.maroon {
    color: #600000;
}

.maroon-background {
    background-color: #7d0000;
}

.navy {
    color: #000060;
}

.navy-background {
    background-color: #00007d;
}

.olive {
    color: #606000;
}

.olive-background {
    background-color: #7d7d00;
}

.purple {
    color: #600060;
}

.purple-background {
    background-color: #7d007d;
}

.red {
    color: #bf0000;
}

.red-background {
    background-color: #fa0000;
}

.silver {
    color: #909090;
}

.silver-background {
    background-color: #bcbcbc;
}

.teal {
    color: #006060;
}

.teal-background {
    background-color: #007d7d;
}

.white {
    color: #bfbfbf;
}

.white-background {
    background-color: #fafafa;
}

.yellow {
    color: #bfbf00;
}

.yellow-background {
    background-color: #fafa00;
}

span.icon > [class^="icon-"], span.icon > [class*=" icon-"] {
    cursor: default;
}

.admonitionblock td.icon [class^="icon-"]:before {
    font-size: 2.5em;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    cursor: default;
}

.admonitionblock td.icon .icon-note:before {
    content: "\f05a";
    color: #095557;
    color: #064042;
}

.admonitionblock td.icon .icon-tip:before {
    content: "\f0eb";
    text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8);
    color: #111;
}

.admonitionblock td.icon .icon-warning:before {
    content: "\f071";
    color: #bf6900;
}

.admonitionblock td.icon .icon-caution:before {
    content: "\f06d";
    color: #bf3400;
}

.admonitionblock td.icon .icon-important:before {
    content: "\f06a";
    color: #bf0000;
}

.conum {
    display: inline-block;
    color: white !important;
    background-color: #6db33f;
    -webkit-border-radius: 100px;
    border-radius: 100px;
    text-align: center;
    width: 20px;
    height: 20px;
    font-size: 12px;
    font-weight: bold;
    line-height: 20px;
    font-family: Arial, sans-serif;
    font-style: normal;
    position: relative;
    top: -2px;
    letter-spacing: -1px;
}

.conum * {
    color: white !important;
}

.conum + b {
    display: none;
}

.conum:after {
    content: attr(data-value);
}

.conum:not([data-value]):empty {
    display: none;
}

body {
    padding-top: 60px;
}

#toc.toc2 ul ul {
    padding-left: 1em;
}
#toc.toc2 ul ul.sectlevel2 {
}

#toctitle {
    color: #34302d;
    display: none;
}

#header h1 {
    font-weight: bold;
    position: relative;
    left: -0.0625em;
}

#header h1 span.lo {
    color: #dc9424;
}

#content h2, #content h3, #content #toctitle, #content .sidebarblock > .content > .title, #content h4, #content h5, #content #toctitle {
    font-weight: normal;
    position: relative;
    left: -0.0625em;
    overflow-wrap: break-word;
}

#content h2 {
    font-weight: bold;
}

.admonitionblock > table td.content {
    border-color: #e6dfd8;
}

table.tableblock.grid-all {
    -webkit-border-radius: 0;
    border-radius: 0;
}

#footer {
    background-color: white;
    color: #34302d;
}

.imageblock .title {
    text-align: center;
}

#content h1.sect0 {
    font-size: 48px;
}

#toc > ul > li > a {
    font-size: large;
}




@import url(https://fonts.googleapis.com/css?family=Montserrat:400,700|Karla:400,700);
body {
}
#reactor-header {
    background: #34302d;
    border-top: 4px solid #6db33f;
    z-index: 2000;
    font-family: 'Montserrat';
    height: 75px;
}

#reactor-header h1#logo {
    margin: 7px 0 0 10px;
    padding: 0;
    float: left;
}

#reactor-header h1#logo a {
    display: block;
    background: url(images/logo-2x.png) no-repeat 0 0;
    background-size: 253px 80px;
    height: 40px;
    width: 253px;
    text-indent: -6000em;
    margin: 8px 0;
}
#reactor-header h1#logo a:hover strong {
    filter: progid:DXImageTransform.Microsoft.Alpha(enabled=false);
    opacity: 1;
}
#reactor-header h1#logo a strong {
    display: block;
    background: url(images/logo-2x.png) no-repeat 0 0;
    background-size: 253px 80px;
    color: red;
    height: 40px;
    width: 253px;
    text-indent: -6000em;
    margin: 8px 0;
    -moz-transition-property: opacity;
    -o-transition-property: opacity;
    -webkit-transition-property: opacity;
    transition-property: opacity;
    -moz-transition-duration: 0.2s;
    -o-transition-duration: 0.2s;
    -webkit-transition-duration: 0.2s;
    transition-duration: 0.2s;
    filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=0);
    opacity: 0;
}

#nav, #nav ul {
    display: block;
    margin: 0;
    padding: 0;
}
#nav {
    float: right;
    margin-right: 10px;
}
#nav ul li {
    display: block;
    float: left;
    list-style: none;
    margin: 0;
    padding: 0;
}
#nav ul li a {
    color: white;
    text-decoration: none;
    font-weight: 500;
    display: block;
    text-transform: uppercase;
    font-size: 13.5px;
    line-height: 71px;
    margin: 0;
    padding: 0 12px;
    -moz-transition-property: background-color;
    -o-transition-property: background-color;
    -webkit-transition-property: background-color;
    transition-property: background-color;
    -moz-transition-duration: 0.2s;
    -o-transition-duration: 0.2s;
    -webkit-transition-duration: 0.2s;
    transition-duration: 0.2s;
}
#nav ul li a:hover {
    background: #6db33f;
}
#nav ul li a.active {
    background: #6db33f;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Reactor 3 Reference Guide</h1>
<div class="details">
<span id="author" class="author">Stephane Maldini</span><br>
<span id="email" class="email"><a href="https://twitter.com/smaldini">@smaldini</a></span><br>
<span id="author2" class="author">Simon BaslÃ©</span><br>
<span id="email2" class="email"><a href="https://twitter.com/simonbasle">@simonbasle</a></span><br>
<span id="revnumber">version 3.5.0-SNAPSHOT</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#about-doc">1. About the Documentation</a>
<ul class="sectlevel2">
<li><a href="#_latest_version_copyright_notice">1.1. Latest Version &amp; Copyright Notice</a></li>
<li><a href="#_contributing_to_the_documentation">1.2. Contributing to the Documentation</a></li>
<li><a href="#_getting_help">1.3. Getting Help</a></li>
<li><a href="#_where_to_go_from_here">1.4. Where to Go from Here</a></li>
</ul>
</li>
<li><a href="#getting-started">2. Getting Started</a>
<ul class="sectlevel2">
<li><a href="#getting-started-introducing-reactor">2.1. Introducing Reactor</a></li>
<li><a href="#prerequisites">2.2. Prerequisites</a></li>
<li><a href="#getting-started-understanding-bom">2.3. Understanding the BOM and versioning scheme</a></li>
<li><a href="#getting">2.4. Getting Reactor</a></li>
<li><a href="#support">2.5. Support and policies</a></li>
</ul>
</li>
<li><a href="#intro-reactive">3. Introduction to Reactive Programming</a>
<ul class="sectlevel2">
<li><a href="#_blocking_can_be_wasteful">3.1. Blocking Can Be Wasteful</a></li>
<li><a href="#_asynchronicity_to_the_rescue">3.2. Asynchronicity to the Rescue?</a></li>
<li><a href="#_from_imperative_to_reactive_programming">3.3. From Imperative to Reactive Programming</a></li>
</ul>
</li>
<li><a href="#core-features">4. Reactor Core Features</a>
<ul class="sectlevel2">
<li><a href="#flux">4.1. <code>Flux</code>, an Asynchronous Sequence of 0-N Items</a></li>
<li><a href="#mono">4.2. <code>Mono</code>, an Asynchronous 0-1 Result</a></li>
<li><a href="#_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it">4.3. Simple Ways to Create a Flux or Mono and Subscribe to It</a></li>
<li><a href="#producing">4.4. Programmatically creating a sequence</a></li>
<li><a href="#schedulers">4.5. Threading and Schedulers</a></li>
<li><a href="#error.handling">4.6. Handling Errors</a></li>
<li><a href="#sinks">4.7. Sinks</a></li>
</ul>
</li>
<li><a href="#kotlin">5. Kotlin support</a>
<ul class="sectlevel2">
<li><a href="#kotlin-requirements">5.1. Requirements</a></li>
<li><a href="#kotlin-extensions">5.2. Extensions</a></li>
<li><a href="#kotlin-null-safety">5.3. Null Safety</a></li>
</ul>
</li>
<li><a href="#testing">6. Testing</a>
<ul class="sectlevel2">
<li><a href="#_testing_a_scenario_with_stepverifier">6.1. Testing a Scenario with <code>StepVerifier</code></a></li>
<li><a href="#_manipulating_time">6.2. Manipulating Time</a></li>
<li><a href="#_performing_post_execution_assertions_with_stepverifier">6.3. Performing Post-execution Assertions with <code>StepVerifier</code></a></li>
<li><a href="#_testing_the_context">6.4. Testing the <code>Context</code></a></li>
<li><a href="#_manually_emitting_with_testpublisher">6.5. Manually Emitting with <code>TestPublisher</code></a></li>
<li><a href="#_checking_the_execution_path_with_publisherprobe">6.6. Checking the Execution Path with <code>PublisherProbe</code></a></li>
</ul>
</li>
<li><a href="#debugging">7. Debugging Reactor</a>
<ul class="sectlevel2">
<li><a href="#_the_typical_reactor_stack_trace">7.1. The Typical Reactor Stack Trace</a></li>
<li><a href="#debug-activate">7.2. Activating Debug Mode - aka tracebacks</a></li>
<li><a href="#_reading_a_stack_trace_in_debug_mode">7.3. Reading a Stack Trace in Debug Mode</a></li>
<li><a href="#reactor-tools-debug">7.4. Production-ready Global Debugging</a></li>
<li><a href="#_logging_a_sequence">7.5. Logging a Sequence</a></li>
</ul>
</li>
<li><a href="#metrics">8. Exposing Reactor metrics</a>
<ul class="sectlevel2">
<li><a href="#_scheduler_metrics">8.1. Scheduler metrics</a></li>
<li><a href="#_publisher_metrics">8.2. Publisher metrics</a></li>
</ul>
</li>
<li><a href="#advanced">9. Advanced Features and Concepts</a>
<ul class="sectlevel2">
<li><a href="#advanced-mutualizing-operator-usage">9.1. Mutualizing Operator Usage</a></li>
<li><a href="#reactor.hotCold">9.2. Hot Versus Cold</a></li>
<li><a href="#advanced-broadcast-multiple-subscribers-connectableflux">9.3. Broadcasting to Multiple Subscribers with <code>ConnectableFlux</code></a></li>
<li><a href="#advanced-three-sorts-batching">9.4. Three Sorts of Batching</a></li>
<li><a href="#advanced-parallelizing-parralelflux">9.5. Parallelizing Work with <code>ParallelFlux</code></a></li>
<li><a href="#scheduler-factory">9.6. Replacing Default <code>Schedulers</code></a></li>
<li><a href="#hooks">9.7. Using Global Hooks</a></li>
<li><a href="#context">9.8. Adding a Context to a Reactive Sequence</a></li>
<li><a href="#cleanup">9.9. Dealing with Objects that Need Cleanup</a></li>
<li><a href="#null-safety">9.10. Null Safety</a></li>
</ul>
</li>
<li><a href="#which-operator">Appendix A: Which operator do I need?</a>
<ul class="sectlevel2">
<li><a href="#which.create">A.1. Creating a New Sequence&#8230;&#8203;</a></li>
<li><a href="#which.values">A.2. Transforming an Existing Sequence</a></li>
<li><a href="#which.peeking">A.3. Peeking into a Sequence</a></li>
<li><a href="#which.filtering">A.4. Filtering a Sequence</a></li>
<li><a href="#which.errors">A.5. Handling Errors</a></li>
<li><a href="#which.time">A.6. Working with Time</a></li>
<li><a href="#which.window">A.7. Splitting a Flux</a></li>
<li><a href="#which.blocking">A.8. Going Back to the Synchronous World</a></li>
<li><a href="#which.multicasting">A.9. Multicasting a Flux to several Subscribers</a></li>
</ul>
</li>
<li><a href="#howtoReadMarbles">Appendix B: How to read marble diagrams?</a></li>
<li><a href="#faq">Appendix C: FAQ, Best Practices, and "How do I&#8230;&#8203;?"</a>
<ul class="sectlevel2">
<li><a href="#faq.wrap-blocking">C.1. How Do I Wrap a Synchronous, Blocking Call?</a></li>
<li><a href="#faq.chain">C.2. I Used an Operator on my <code>Flux</code> but it Doesn&#8217;t Seem to Apply. What Gives?</a></li>
<li><a href="#faq.monoThen">C.3. My <code>Mono</code> <code>zipWith</code> or <code>zipWhen</code> is never called</a></li>
<li><a href="#faq.retryWhen">C.4. How to Use <code>retryWhen</code> to Emulate <code>retry(3)</code>?</a></li>
<li><a href="#faq.exponentialBackoff">C.5. How can I use <code>retryWhen</code> for Exponential Backoff?</a></li>
<li><a href="#faq.thread-affinity-publishon">C.6. How Do I Ensure Thread Affinity when I Use <code>publishOn()</code>?</a></li>
<li><a href="#faq.mdc">C.7. What Is a Good Pattern for Contextual Logging? (MDC)</a></li>
</ul>
</li>
<li><a href="#reactor-extra">Appendix D: Reactor-Extra</a>
<ul class="sectlevel2">
<li><a href="#extra-tuples">D.1. <code>TupleUtils</code> and Functional Interfaces</a></li>
<li><a href="#extra-math">D.2. Math Operators With <code>MathFlux</code></a></li>
<li><a href="#extra-schedulers">D.3. Schedulers</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="about-doc"><a class="anchor" href="#about-doc"></a>1. About the Documentation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section provides a brief overview of Reactor reference documentation. You do not
need to read this guide in a linear fashion. Each piece stands on its own, though they
often refer to other pieces.</p>
</div>
<div class="sect2">
<h3 id="_latest_version_copyright_notice"><a class="anchor" href="#_latest_version_copyright_notice"></a>1.1. Latest Version &amp; Copyright Notice</h3>
<div class="paragraph">
<p>The Reactor reference guide is available as HTML documents. The latest copy is available
at <a href="https://projectreactor.io/docs/core/release/reference/index.html" class="bare">https://projectreactor.io/docs/core/release/reference/index.html</a></p>
</div>
<div class="paragraph">
<p>Copies of this document may be made for your own use and for distribution to others,
provided that you do not charge any fee for such copies and further provided that each
copy contains this Copyright Notice, whether distributed in print or electronically.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contributing_to_the_documentation"><a class="anchor" href="#_contributing_to_the_documentation"></a>1.2. Contributing to the Documentation</h3>
<div class="paragraph">
<p>The reference guide is written in
<a href="https://asciidoctor.org/docs/asciidoc-writers-guide/">Asciidoc</a>, and you can find its sources at
<a href="https://github.com/reactor/reactor-core/tree/main/docs/asciidoc" class="bare">https://github.com/reactor/reactor-core/tree/main/docs/asciidoc</a>.</p>
</div>
<div class="paragraph">
<p>If you have an improvement or a suggestion, we will be happy to get a pull request from you!</p>
</div>
<div class="paragraph">
<p>We recommend that you check out a local copy of the repository so that you can
generate the documentation by running the <code>asciidoctor</code> gradle task and checking the
rendering. Some of the sections rely on included files, so GitHub rendering is
not always complete.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To facilitate documentation edits, most sections have a link at the end that opens
an edit UI directly on GitHub for the main source file for that section. These links are
only present in the HTML5 version of this reference guide. They look like the following:
<a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/aboutDoc.adoc" class="fa fa-edit" target="_blank" rel="noopener">Suggest Edit</a> to <a href="#about-doc">About the Documentation</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_getting_help"><a class="anchor" href="#_getting_help"></a>1.3. Getting Help</h3>
<div class="paragraph">
<p>You can reach out for help in several ways with Reactor:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Get in touch with the community on <a href="https://gitter.im/reactor/reactor">Gitter</a>.</p>
</li>
<li>
<p>Ask a question on stackoverflow.com at
<a href="https://stackoverflow.com/tags/project-reactor"><code>project-reactor</code></a>.</p>
</li>
<li>
<p>Report bugs in Github issues. We closely monitor the following repositories:
<a href="https://github.com/reactor/reactor-core/issues">reactor-core</a> (which covers the
essential features) and <a href="https://github.com/reactor/reactor-addons/issues">reactor-addons</a>
(which covers reactor-test and adapters issues).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All of Reactor is open source,
<a href="https://github.com/reactor/reactor-core/tree/main/docs/asciidoc">including this
documentation</a>. If you find problems with the docs or if you want to improve them,
please <a href="https://github.com/reactor/.github/blob/main/CONTRIBUTING.md">get involved</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_where_to_go_from_here"><a class="anchor" href="#_where_to_go_from_here"></a>1.4. Where to Go from Here</h3>
<div class="ulist">
<ul>
<li>
<p>Head to <a href="#getting-started">Getting Started</a> if you feel like jumping straight into the code.</p>
</li>
<li>
<p>If you are new to reactive programming, though, you should probably start with the
<a href="#intro-reactive">Introduction to Reactive Programming</a>.</p>
</li>
<li>
<p>If you are familiar with Reactor concepts and are just looking for the right tool
for the job but cannot think of a relevant operator, try the <a href="#which-operator">Which operator do I need?</a> Appendix.</p>
</li>
<li>
<p>In order to dig deeper into the core features of Reactor, head to <a href="#core-features">Reactor Core Features</a> to
learn:</p>
<div class="ulist">
<ul>
<li>
<p>More about Reactor&#8217;s reactive types in the <a href="#flux"><code>Flux</code>, an Asynchronous Sequence of 0-N Items</a> and <a href="#mono"><code>Mono</code>, an Asynchronous 0-1 Result</a>
sections.</p>
</li>
<li>
<p>How to switch threading contexts using <a href="#schedulers">a scheduler</a>.</p>
</li>
<li>
<p>How to handle errors in the <a href="#error.handling">Handling Errors</a> section.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Unit testing? Yes it is possible with the <code>reactor-test</code> project! See <a href="#testing">Testing</a>.</p>
</li>
<li>
<p><a href="#producing">Programmatically creating a sequence</a> offers a more advanced way of creating reactive sources.</p>
</li>
<li>
<p>Other advanced topics are covered in <a href="#advanced">Advanced Features and Concepts</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/aboutDoc.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#about-doc">About the Documentation</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>2. Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section contains information that should help you get going with Reactor. It
includes the following sections:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#getting-started-introducing-reactor">Introducing Reactor</a></p>
</li>
<li>
<p><a href="#prerequisites">Prerequisites</a></p>
</li>
<li>
<p><a href="#getting-started-understanding-bom">Understanding the BOM and versioning scheme</a></p>
</li>
<li>
<p><a href="#getting">Getting Reactor</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="getting-started-introducing-reactor"><a class="anchor" href="#getting-started-introducing-reactor"></a>2.1. Introducing Reactor</h3>
<div class="paragraph">
<p>Reactor is a fully non-blocking reactive programming foundation for the JVM, with
efficient demand management (in the form of managing &#8220;backpressure&#8221;). It integrates
directly with the Java 8 functional APIs, notably <code>CompletableFuture</code>, <code>Stream</code>, and
<code>Duration</code>. It offers composable asynchronous sequence APIs&#8201;&#8212;&#8201;<code>Flux</code> (for [N] elements) and
<code>Mono</code> (for [0|1] elements)&#8201;&#8212;&#8201;and extensively implements the
<a href="https://www.reactive-streams.org/">Reactive Streams</a> specification.</p>
</div>
<div class="paragraph">
<p>Reactor also supports non-blocking inter-process communication with the
<code>reactor-netty</code> project. Suited for Microservices Architecture, Reactor Netty offers
backpressure-ready network engines for HTTP (including Websockets), TCP, and UDP.
Reactive encoding and decoding are fully supported.</p>
</div>
</div>
<div class="sect2">
<h3 id="prerequisites"><a class="anchor" href="#prerequisites"></a>2.2. Prerequisites</h3>
<div class="paragraph">
<p>Reactor Core runs on <code>Java 8</code> and above.</p>
</div>
<div class="paragraph">
<p>It has a transitive dependency on <code>org.reactivestreams:reactive-streams:1.0.3</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Android Support</div>
<div class="ulist">
<ul>
<li>
<p>Reactor 3 does not officially support or target Android (consider using RxJava 2 if
such support is a strong requirement).</p>
</li>
<li>
<p>However, it should work fine with Android SDK 26 (Android O) and above.</p>
</li>
<li>
<p>It will likely work fine with Android SDK 21 (Android 5.0) and above when desugaring
is enabled. See <a href="https://developer.android.com/studio/write/java8-support#library-desugaring" class="bare">https://developer.android.com/studio/write/java8-support#library-desugaring</a></p>
</li>
<li>
<p>We are open to evaluating changes that benefit Android support in a best-effort
fashion. However, we cannot make guarantees. Each decision must be made on a
case-by-case basis.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-understanding-bom"><a class="anchor" href="#getting-started-understanding-bom"></a>2.3. Understanding the BOM and versioning scheme</h3>
<div class="paragraph">
<p>Reactor 3 uses a BOM (Bill of Materials) model (since <code>reactor-core 3.0.4</code>, with the <code>Aluminium</code> release train).
This curated list groups artifacts that are meant to work well together, providing
the relevant versions despite potentially divergent versioning schemes in these artifacts.</p>
</div>
<div class="paragraph">
<p>Note the versioning scheme has changed between 3.3.x and 3.4.x (Dysprosium and Europium).</p>
</div>
<div class="paragraph">
<p>Artifacts follow a versioning scheme of <code>MAJOR.MINOR.PATCH-QUALIFIER</code> while the BOM is versioned using a CalVer inspired scheme of <code>YYYY.MINOR.PATCH-QUALIFIER</code>, where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MAJOR</code> is the current generation of Reactor, where each new generation can bring fundamental changes to the structure of the project (which might imply a more significant migration effort)</p>
</li>
<li>
<p><code>YYYY</code> is the year of the first GA release in a given release cycle (like 3.4.0 for 3.4.x)</p>
</li>
<li>
<p><code>.MINOR</code> is a 0-based number incrementing with each new release cycle</p>
<div class="ulist">
<ul>
<li>
<p>in the case of projects, it generally reflects wider changes and can indicate a moderate migration effort</p>
</li>
<li>
<p>in the case of the BOM it allows discerning between release cycles in case two get first released the same year</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>.PATCH</code> is a 0-based number incrementing with each service release</p>
</li>
<li>
<p><code>-QUALIFIER</code> is a textual qualifier, which is omitted in the case of GA releases (see below)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first release cycle to follow that convention is thus <code>2020.0.x</code>, codename <code>Europium</code>.
The scheme uses the following qualifiers (note the use of dash separator), in order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-M1</code>..<code>-M9</code>: milestones (we don&#8217;t expect more than 9 per service release)</p>
</li>
<li>
<p><code>-RC1</code>..<code>-RC9</code>: release candidates (we don&#8217;t expect more than 9 per service release)</p>
</li>
<li>
<p><code>-SNAPSHOT</code>: snapshots</p>
</li>
<li>
<p><em>no qualifier</em> for GA releases</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
snapshots appear higher in the order above because, conceptually, they&#8217;re always "the freshest pre-release" of any given PATCH.
Even though the first deployed artifact of a PATCH cycle will always be a -SNAPSHOT, a similarly named but more up-to-date snapshot
would also get released after eg. a milestone or between release candidates.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each release cycle is also given a codename, in continuity with the previous codename-based
scheme, which can be used to reference it more informally (like in discussions, blog posts, etc&#8230;&#8203;).
The codenames represent what would traditionally be the MAJOR.MINOR number. They (mostly)
come from the <a href="https://en.wikipedia.org/wiki/Periodic_table#Overview">Periodic Table of
Elements</a>, in increasing alphabetical order.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Up until Dysprosium, the BOM was versioned using a release train scheme with a codename followed by a qualifier, and the qualifiers were slightly different.
For example: Aluminium-RELEASE (first GA release, would now be something like YYYY.0.0), Bismuth-M1, Californium-SR1 (service release
would now be something like YYYY.0.1), Dysprosium-RC1, Dysprosium-BUILD-SNAPSHOT (after each patch, we&#8217;d go back to the same snapshot version. would now be something
like YYYY.0.X-SNAPSHOT so we get 1 snapshot per PATCH)
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting"><a class="anchor" href="#getting"></a>2.4. Getting Reactor</h3>
<div class="paragraph">
<p>As <a href="#getting-started-understanding-bom">mentioned earlier</a>, the easiest way to use Reactor in your core is to use the BOM and
add the relevant dependencies to your project. Note that, when you add such a dependency,
you must omit the version so that the version gets picked up from the BOM.</p>
</div>
<div class="paragraph">
<p>However, if you want to force the use of a specific artifact&#8217;s version, you can specify
it when adding your dependency, as you usually would. You can also forgo the BOM entirely
and specify dependencies by their artifact versions.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
As of this version (reactor-core 3.5.0-SNAPSHOT), the latest stable BOM in the associated
release train line is <code>2022.0.0-M2</code>, which is what is used in snippets below.
There might be newer versions since then (including snapshots, milestones and new release train lines),
see <a href="https://projectreactor.io/docs" class="bare">https://projectreactor.io/docs</a> for the latest artifacts and BOMs.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_maven_installation"><a class="anchor" href="#_maven_installation"></a>2.4.1. Maven Installation</h4>
<div class="paragraph">
<p>Maven natively supports the BOM concept. First, you need to import the BOM by
adding the following snippet to your <code>pom.xml</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependencyManagement&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
            &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt;
            &lt;version&gt;2022.0.0-M2&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Notice the <code>dependencyManagement</code> tag. This is in addition to the regular
<code>dependencies</code> section.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>If the top section (<code>dependencyManagement</code>) already exists in your pom, add only the contents.</p>
</div>
<div class="paragraph">
<p>Next, add your dependencies to the relevant reactor projects, as usual, except without a
<code>&lt;version&gt;</code>, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; <i class="conum" data-value="3"></i><b>(3)</b>
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dependency on the core library.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No version tag here.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>reactor-test</code> provides facilities to unit test reactive streams.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gradle_installation"><a class="anchor" href="#_gradle_installation"></a>2.4.2. Gradle Installation</h4>
<div class="paragraph">
<p>Prior to version 5.0, Gradle has no core support for Maven BOMs, but you can use Spring&#8217;s
<a href="https://github.com/spring-gradle-plugins/dependency-management-plugin">gradle-dependency-management</a>
plugin.</p>
</div>
<div class="paragraph">
<p>First, apply the plugin from the Gradle Plugin Portal, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
    id "io.spring.dependency-management" version "1.0.7.RELEASE" <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>as of this writing, 1.0.7.RELEASE is the latest version of the plugin.
Check for updates.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Then use it to import the BOM, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">dependencyManagement {
     imports {
          mavenBom "io.projectreactor:reactor-bom:2022.0.0-M2"
     }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally add a dependency to your project, without a version number, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">dependencies {
     implementation 'io.projectreactor:reactor-core' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>There is no third <code>:</code> separated section for the version. It is taken from
the BOM.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Since Gradle 5.0, you can use the native Gradle support for BOMs:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">dependencies {
     implementation platform('io.projectreactor:reactor-bom:2022.0.0-M2')
     implementation 'io.projectreactor:reactor-core' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>There is no third <code>:</code> separated section for the version. It is taken from
the BOM.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_milestones_and_snapshots"><a class="anchor" href="#_milestones_and_snapshots"></a>2.4.3. Milestones and Snapshots</h4>
<div class="paragraph">
<p>Milestones and developer previews are distributed through the Spring Milestones
repository rather than Maven Central. To add it to your build configuration
file, use the following snippet:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Milestones in Maven</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For Gradle, use the following snippet:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Milestones in Gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">repositories {
  maven { url 'https://repo.spring.io/milestone' }
  mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly, snapshots are also available in a separate dedicated repository, as the following example show:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. -SNAPSHOTs in Maven</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshot Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 4. -SNAPSHOTs in Gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">repositories {
  maven { url 'https://repo.spring.io/snapshot' }
  mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="support"><a class="anchor" href="#support"></a>2.5. Support and policies</h3>
<div class="paragraph">
<p>The entries below are mirroring <a href="https://github.com/reactor/.github/blob/main/SUPPORT.adoc" class="bare">https://github.com/reactor/.github/blob/main/SUPPORT.adoc</a></p>
</div>
<div class="sect3">
<h4 id="_do_you_have_a_question"><a class="anchor" href="#_do_you_have_a_question"></a>2.5.1. Do you have a question?</h4>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Search Stack Overflow first; discuss if necessary
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you&#8217;re unsure why something isn&#8217;t working or wondering if there is a better
way of doing it please check on <strong>Stack Overflow</strong> first and if necessary start
a discussion. Use relevant tags among the ones we monitor for that purpose:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://stackoverflow.com/questions/tagged/reactor-netty"><code>reactor-netty</code></a> for specific reactor-netty questions</p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/tagged/project-reactor"><code>project-reactor</code></a> for generic reactor questions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you prefer real-time discussion, we also have a few <strong>Gitter channels</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://gitter.im/reactor/reactor"><code>reactor</code></a> is the historic most active one, where most of the community can help</p>
</li>
<li>
<p><a href="https://gitter.im/reactor/reactor-core"><code>reactor-core</code></a> is intended for more advanced pinpointed discussions around the inner workings of the library</p>
</li>
<li>
<p><a href="https://gitter.im/reactor/reactor-netty"><code>reactor-netty</code></a> is intended for netty-specific questions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Refer to each project&#8217;s README for potential other sources of information.</p>
</div>
<div class="paragraph">
<p>We generally discourage opening GitHub issues for questions, in favor of the two channels above.</p>
</div>
</div>
<div class="sect3">
<h4 id="_our_policy_on_deprecations"><a class="anchor" href="#_our_policy_on_deprecations"></a>2.5.2. Our policy on <strong>deprecations</strong></h4>
<div class="paragraph">
<p>When dealing with deprecations, given a version <code>A.B.C</code>, we&#8217;ll ensure that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>deprecations introduced in version <code>A</code>.<code>B</code>.<code>0</code> will be removed <strong>no sooner than</strong> version <code>A</code>.<strong><code>B+1</code></strong>.<code>0</code></p>
</li>
<li>
<p>deprecations introduced in version <code>A</code>.<code>B</code>.<code>1+</code> will be removed <strong>no sooner than</strong> version <code>A</code>.<strong><code>B+2</code></strong>.<code>0</code></p>
</li>
<li>
<p>we&#8217;ll strive to mention the following in the deprecation javadoc:</p>
<div class="ulist">
<ul>
<li>
<p>target minimum version for removal</p>
</li>
<li>
<p>pointers to replacements for the deprecated method</p>
</li>
<li>
<p>version in which method was deprecated</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This policy is officially in effect as of January 2021, for all modules in <code>2020.0</code> BOMs and newer release trains, as well as <code>Dysprosium</code> releases after <code>Dysprosium-SR15</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Deprecation removal targets are not a hard commitment, and the deprecated methods <strong>could live on further than these minimum target GA versions</strong> (ie. only the most problematic deprecated methods will be removed aggressively).
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
That said, deprecated code that has outlived its minimum removal target version may be removed in any subsequent release (including patch releases, aka service releases) without further notice. So users should still strive to update their code as early as possible.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_active_development"><a class="anchor" href="#_active_development"></a>2.5.3. Active Development</h4>
<div class="paragraph">
<p>The following table summarises the development status of the various Reactor release trains:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Supported</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2020.0.0 (codename Europium) (core 3.4.x, netty 1.0.x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check-square fa-2x"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dysprosium Train (core 3.3.x, netty 0.9.x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times fa-2x"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Califonium and below (core &lt; 3.3, netty &lt; 0.9)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times fa-2x"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactor 1.x and 2.x Generations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times fa-2x"></i></span></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/gettingStarted.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#getting-started">Getting Started</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="intro-reactive"><a class="anchor" href="#intro-reactive"></a>3. Introduction to Reactive Programming</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactor is an implementation of the Reactive Programming paradigm, which can be summed up
as follows:</p>
</div>
<div class="quoteblock">
<blockquote>
Reactive programming is an asynchronous programming paradigm concerned with data streams
and the propagation of change. This means that it becomes possible to express static
(e.g. arrays) or dynamic (e.g. event emitters) data streams with ease via the employed
programming language(s).
</blockquote>
<div class="attribution">
&#8212; https://en.wikipedia.org/wiki/Reactive_programming
</div>
</div>
<div class="paragraph">
<p>As a first step in the direction of reactive programming, Microsoft created the Reactive
Extensions (Rx) library in the .NET ecosystem. Then RxJava implemented reactive
programming on the JVM.  As time went on, a standardization for Java emerged through the
Reactive Streams effort, a specification that defines a set of interfaces and
interaction rules for reactive libraries on the JVM. Its interfaces have been
integrated into Java 9 under the <code>Flow</code> class.</p>
</div>
<div class="paragraph">
<p>The reactive programming paradigm is often presented in object-oriented languages as an
extension of the Observer design pattern. You can also compare the main reactive streams
pattern with the familiar Iterator design pattern, as there is a duality to the
<code>Iterable</code>-<code>Iterator</code> pair in all of these libraries. One major difference is that, while
an Iterator is pull-based, reactive streams are push-based.</p>
</div>
<div class="paragraph">
<p>Using an iterator is an imperative programming pattern, even though the method of
accessing values is solely the responsibility of the <code>Iterable</code>. Indeed, it is up to the
developer to choose when to access the <code>next()</code> item in the sequence. In reactive
streams, the equivalent of the above pair is <code>Publisher-Subscriber</code>. But it is the
<code>Publisher</code> that notifies the Subscriber of newly available values <em>as they come</em>, and
this push aspect is the key to being reactive. Also, operations applied to pushed values
are expressed declaratively rather than imperatively: The programmer expresses the logic
of the computation rather than describing its exact control flow.</p>
</div>
<div class="paragraph">
<p>In addition to pushing values, the error-handling and completion aspects are also covered
in a well defined manner. A <code>Publisher</code> can push new values to its <code>Subscriber</code> (by
calling <code>onNext</code>) but can also signal an error (by calling <code>onError</code>) or completion (by
calling <code>onComplete</code>). Both errors and completion terminate the sequence. This can
be summed up as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">onNext x 0..N [onError | onComplete]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This approach is very flexible. The pattern supports use cases where there is no value,
one value, or n values (including an infinite sequence of values, such as the continuing
ticks of a clock).</p>
</div>
<div class="paragraph">
<p>But why do we need such an asynchronous reactive library in the first place?</p>
</div>
<div class="sect2">
<h3 id="_blocking_can_be_wasteful"><a class="anchor" href="#_blocking_can_be_wasteful"></a>3.1. Blocking Can Be Wasteful</h3>
<div class="paragraph">
<p>Modern applications can reach huge numbers of concurrent users, and, even though the
capabilities of modern hardware have continued to improve, performance of
modern software is still a key concern.</p>
</div>
<div class="paragraph">
<p>There are, broadly, two ways one can improve a program&#8217;s performance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>parallelize</strong> to use more threads and more hardware resources.</p>
</li>
<li>
<p><strong>seek more efficiency</strong> in how current resources are used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Usually, Java developers write programs by using blocking code. This practice
is fine until there is a performance bottleneck. Then it is time
to introduce additional threads, running similar blocking code. But this
scaling in resource utilization can quickly introduce contention and concurrency
problems.</p>
</div>
<div class="paragraph">
<p>Worse still, blocking wastes resources. If you look closely, as soon as a
program involves some latency (notably I/O, such as a database request or a
network call), resources are wasted because threads (possibly many threads)
now sit idle, waiting for data.</p>
</div>
<div class="paragraph">
<p>So the parallelization approach is not a silver bullet. It is necessary
to access the full power of the hardware, but it is also complex to
reason about and susceptible to resource wasting.</p>
</div>
</div>
<div class="sect2">
<h3 id="_asynchronicity_to_the_rescue"><a class="anchor" href="#_asynchronicity_to_the_rescue"></a>3.2. Asynchronicity to the Rescue?</h3>
<div class="paragraph">
<p>The second approach mentioned earlier, seeking more efficiency, can be a solution
to the resource wasting problem. By writing asynchronous, non-blocking code,
you let the execution switch to another active task that uses the same underlying
resources and later comes back to the current process when the asynchronous
processing has finished.</p>
</div>
<div class="paragraph">
<p>But how can you produce asynchronous code on the JVM? Java offers two models of
asynchronous programming:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Callbacks</strong>: Asynchronous methods do not have a return value but take an extra
<code>callback</code> parameter (a lambda or anonymous class) that gets called when the result is
available. A well known example is Swing&#8217;s <code>EventListener</code> hierarchy.</p>
</li>
<li>
<p><strong>Futures</strong>: Asynchronous methods <em>immediately</em> return a <code>Future&lt;T&gt;</code>. The asynchronous
process computes a <code>T</code> value, but the <code>Future</code> object wraps access to it. The value is
not immediately available, and the object can be polled until the value is available. For
instance, an <code>ExecutorService</code> running <code>Callable&lt;T&gt;</code> tasks use <code>Future</code> objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Are these techniques good enough? Not for every use case, and both approaches have
limitations.</p>
</div>
<div class="paragraph">
<p>Callbacks are hard to compose together, quickly leading to code that is difficult to read
and maintain (known as &#8220;Callback Hell&#8221;).</p>
</div>
<div class="paragraph">
<p>Consider an example: showing the top five favorites from a user on the UI or suggestions
if she does not have a favorite. This goes through three services (one gives favorite IDs,
the second fetches favorite details, and the third offers suggestions with details), as
follows:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Example of Callback Hell</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">userService.getFavorites(userId, new Callback&lt;List&lt;String&gt;&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>
  public void onSuccess(List&lt;String&gt; list) { <i class="conum" data-value="2"></i><b>(2)</b>
    if (list.isEmpty()) { <i class="conum" data-value="3"></i><b>(3)</b>
      suggestionService.getSuggestions(new Callback&lt;List&lt;Favorite&gt;&gt;() {
        public void onSuccess(List&lt;Favorite&gt; list) { <i class="conum" data-value="4"></i><b>(4)</b>
          UiUtils.submitOnUiThread(() -&gt; { <i class="conum" data-value="5"></i><b>(5)</b>
            list.stream()
                .limit(5)
                .forEach(uiList::show); <i class="conum" data-value="6"></i><b>(6)</b>
            });
        }

        public void onError(Throwable error) { <i class="conum" data-value="7"></i><b>(7)</b>
          UiUtils.errorPopup(error);
        }
      });
    } else {
      list.stream() <i class="conum" data-value="8"></i><b>(8)</b>
          .limit(5)
          .forEach(favId -&gt; favoriteService.getDetails(favId, <i class="conum" data-value="9"></i><b>(9)</b>
            new Callback&lt;Favorite&gt;() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -&gt; uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We have callback-based services: a <code>Callback</code> interface with a method invoked when
the asynchronous process was successful and one invoked when an error occurs.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The first service invokes its callback with the list of favorite IDs.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the list is empty, we must go to the <code>suggestionService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>suggestionService</code> gives a <code>List&lt;Favorite&gt;</code> to a second callback.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Since we deal with a UI, we need to ensure our consuming code runs in the UI
thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>We use a Java 8 <code>Stream</code> to limit the number of suggestions processed to five, and we
show them in a graphical list in the UI.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>At each level, we deal with errors the same way: We show them in a popup.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Back to the favorite ID level. If the service returned a full list, we need to
go to the <code>favoriteService</code> to get detailed <code>Favorite</code> objects. Since we want only five,
we first stream the list of IDs to limit it to five.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Once again, a callback. This time we get a fully-fledged <code>Favorite</code> object that we
push to the UI inside the UI thread.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>That is a lot of code, and it is a bit hard to follow and has repetitive parts.
Consider its equivalent in Reactor:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. Example of Reactor code equivalent to callback code</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">userService.getFavorites(userId) <i class="conum" data-value="1"></i><b>(1)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="2"></i><b>(2)</b>
           .switchIfEmpty(suggestionService.getSuggestions()) <i class="conum" data-value="3"></i><b>(3)</b>
           .take(5) <i class="conum" data-value="4"></i><b>(4)</b>
           .publishOn(UiUtils.uiThreadScheduler()) <i class="conum" data-value="5"></i><b>(5)</b>
           .subscribe(uiList::show, UiUtils::errorPopup); <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start with a flow of favorite IDs.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We <em>asynchronously transform</em> these into detailed <code>Favorite</code> objects
(<code>flatMap</code>). We now have a flow of <code>Favorite</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the flow of <code>Favorite</code> is empty, we switch to a fallback through the
<code>suggestionService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We are only interested in, at most, five elements from the resulting flow.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>At the end, we want to process each piece of data in the UI thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>We trigger the flow by describing what to do with the final form of the data
(show it in a UI list) and what to do in case of an error (show a popup).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>What if you want to ensure the favorite IDs are retrieved in less than 800ms or, if it
takes longer, get them from a cache? In the callback-based code, that is a complicated
task. In Reactor it becomes as easy as adding a <code>timeout</code> operator in the chain, as follows:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Example of Reactor code with timeout and fallback</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">userService.getFavorites(userId)
           .timeout(Duration.ofMillis(800)) <i class="conum" data-value="1"></i><b>(1)</b>
           .onErrorResume(cacheService.cachedFavoritesFor(userId)) <i class="conum" data-value="2"></i><b>(2)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="3"></i><b>(3)</b>
           .switchIfEmpty(suggestionService.getSuggestions())
           .take(5)
           .publishOn(UiUtils.uiThreadScheduler())
           .subscribe(uiList::show, UiUtils::errorPopup);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the part above emits nothing for more than 800ms, propagate an error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In case of an error, fall back to the <code>cacheService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The rest of the chain is similar to the previous example.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Future</code> objects are a bit better than callbacks, but they still do not do well at composition,
despite the improvements brought in Java 8 by <code>CompletableFuture</code>. Orchestrating multiple
<code>Future</code> objects together is doable but not easy. Also, <code>Future</code> has other problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is easy to end up with another blocking situation with <code>Future</code> objects by calling
the <code>get()</code> method.</p>
</li>
<li>
<p>They do not support lazy computation.</p>
</li>
<li>
<p>They lack support for multiple values and advanced error handling.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider another example: We get a list of IDs from which we want to fetch a name and a
statistic and combine these pair-wise, all of it asynchronously. The following example
does so with a list of type <code>CompletableFuture</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Example of <code>CompletableFuture</code> combination</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">CompletableFuture&lt;List&lt;String&gt;&gt; ids = ifhIds(); <i class="conum" data-value="1"></i><b>(1)</b>

CompletableFuture&lt;List&lt;String&gt;&gt; result = ids.thenComposeAsync(l -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
	Stream&lt;CompletableFuture&lt;String&gt;&gt; zip =
			l.stream().map(i -&gt; { <i class="conum" data-value="3"></i><b>(3)</b>
				CompletableFuture&lt;String&gt; nameTask = ifhName(i); <i class="conum" data-value="4"></i><b>(4)</b>
				CompletableFuture&lt;Integer&gt; statTask = ifhStat(i); <i class="conum" data-value="5"></i><b>(5)</b>

				return nameTask.thenCombineAsync(statTask, (name, stat) -&gt; "Name " + name + " has stats " + stat); <i class="conum" data-value="6"></i><b>(6)</b>
			});
	List&lt;CompletableFuture&lt;String&gt;&gt; combinationList = zip.collect(Collectors.toList()); <i class="conum" data-value="7"></i><b>(7)</b>
	CompletableFuture&lt;String&gt;[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);

	CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(combinationArray); <i class="conum" data-value="8"></i><b>(8)</b>
	return allDone.thenApply(v -&gt; combinationList.stream()
			.map(CompletableFuture::join) <i class="conum" data-value="9"></i><b>(9)</b>
			.collect(Collectors.toList()));
});

List&lt;String&gt; results = result.join(); <i class="conum" data-value="10"></i><b>(10)</b>
assertThat(results).contains(
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121");</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start off with a future that gives us a list of <code>id</code> values to process.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We want to start some deeper asynchronous processing once we get the list.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>For each element in the list:</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Asynchronously get the associated name.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Asynchronously get the associated task.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Combine both results.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>We now have a list of futures that represent all the combination tasks. To
execute these tasks, we need to convert the list to an array.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Pass the array to <code>CompletableFuture.allOf</code>, which outputs a <code>Future</code> that completes
when all tasks have completed.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The tricky bit is that <code>allOf</code> returns <code>CompletableFuture&lt;Void&gt;</code>, so we
reiterate over the list of futures, collecting their results by using <code>join()</code>
(which, here, does not block, since <code>allOf</code> ensures the futures are all done).</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Once the whole asynchronous pipeline has been triggered, we wait for it to
be processed and return the list of results that we can assert.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Since Reactor has more combination operators out of the box, this process can be
simplified, as follows:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Example of Reactor code equivalent to future code</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; ids = ifhrIds(); <i class="conum" data-value="1"></i><b>(1)</b>

Flux&lt;String&gt; combinations =
		ids.flatMap(id -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
			Mono&lt;String&gt; nameTask = ifhrName(id); <i class="conum" data-value="3"></i><b>(3)</b>
			Mono&lt;Integer&gt; statTask = ifhrStat(id); <i class="conum" data-value="4"></i><b>(4)</b>

			return nameTask.zipWith(statTask, <i class="conum" data-value="5"></i><b>(5)</b>
					(name, stat) -&gt; "Name " + name + " has stats " + stat);
		});

Mono&lt;List&lt;String&gt;&gt; result = combinations.collectList(); <i class="conum" data-value="6"></i><b>(6)</b>

List&lt;String&gt; results = result.block(); <i class="conum" data-value="7"></i><b>(7)</b>
assertThat(results).containsExactly( <i class="conum" data-value="8"></i><b>(8)</b>
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121"
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This time, we start from an asynchronously provided sequence of <code>ids</code> (a
<code>Flux&lt;String&gt;</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For each element in the sequence, we asynchronously process it (inside the function
that is the body <code>flatMap</code> call) twice.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get the associated name.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Get the associated statistic.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Asynchronously combine the two values.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Aggregate the values into a <code>List</code> as they become available.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>In production, we would continue working with the <code>Flux</code> asynchronously by further
combining it or subscribing to it. Most probably, we would return the <code>result</code> <code>Mono</code>.
Since we are in a test, we instead block, waiting for the processing to finish, and then
directly return the aggregated list of values.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Assert the result.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The perils of using callbacks and <code>Future</code> objects are similar and are what reactive programming
addresses with the <code>Publisher-Subscriber</code> pair.</p>
</div>
</div>
<div class="sect2">
<h3 id="_from_imperative_to_reactive_programming"><a class="anchor" href="#_from_imperative_to_reactive_programming"></a>3.3. From Imperative to Reactive Programming</h3>
<div class="paragraph">
<p>Reactive libraries, such as Reactor, aim to address these drawbacks of &#8220;classic&#8221;
asynchronous approaches on the JVM while also focusing on a few additional aspects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Composability</strong> and <strong>readability</strong></p>
</li>
<li>
<p>Data as a <strong>flow</strong> manipulated with a rich vocabulary of <strong>operators</strong></p>
</li>
<li>
<p>Nothing happens until you <strong>subscribe</strong></p>
</li>
<li>
<p><strong>Backpressure</strong> or <em>the ability for the consumer to signal the producer that the rate of
emission is too high</em></p>
</li>
<li>
<p><strong>High level</strong> but <strong>high value</strong> abstraction that is <em>concurrency-agnostic</em></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_composability_and_readability"><a class="anchor" href="#_composability_and_readability"></a>3.3.1. Composability and Readability</h4>
<div class="paragraph">
<p>By &#8220;composability&#8221;, we mean the ability to orchestrate multiple asynchronous tasks, in
which we use results from previous tasks to feed input to subsequent ones.
Alternatively, we can run several tasks in a fork-join style.
In addition, we can reuse asynchronous tasks as discrete components in a
higher-level system.</p>
</div>
<div class="paragraph">
<p>The ability to orchestrate tasks is tightly coupled to the readability and
maintainability of code. As the layers of asynchronous processes increase in both number
and complexity, being able to compose and read code becomes increasingly difficult. As we
saw, the callback model is simple, but one of its main drawbacks is that, for complex
processes, you need to have a callback executed from a callback, itself nested inside
another callback, and so on. That mess is known as &#8220;Callback Hell&#8221;. As you can guess (or
know from experience), such code is pretty hard to go back to and reason about.</p>
</div>
<div class="paragraph">
<p>Reactor offers rich composition options, wherein code mirrors the organization of the
abstract process, and everything is generally kept at the same level (nesting is
minimized).</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_assembly_line_analogy"><a class="anchor" href="#_the_assembly_line_analogy"></a>3.3.2. The Assembly Line Analogy</h4>
<div class="paragraph">
<p>You can think of data processed by a reactive application as moving through an assembly
line. Reactor is both the conveyor belt and the workstations. The raw material pours from
a source (the original <code>Publisher</code>) and ends up as a finished product ready to be pushed
to the consumer (or <code>Subscriber</code>).</p>
</div>
<div class="paragraph">
<p>The raw material can go through various transformations and other intermediary steps or
be part of a larger assembly line that aggregates intermediate pieces together. If there
is a glitch or clogging at one point (perhaps boxing the products takes a
disproportionately long time), the afflicted workstation can signal upstream to limit the
flow of raw material.</p>
</div>
</div>
<div class="sect3">
<h4 id="_operators"><a class="anchor" href="#_operators"></a>3.3.3. Operators</h4>
<div class="paragraph">
<p>In Reactor, operators are the workstations in our assembly analogy. Each operator adds
behavior to a <code>Publisher</code> and wraps the previous step&#8217;s <code>Publisher</code> into a new instance.
The whole chain is thus linked, such that data originates from the first <code>Publisher</code> and
moves down the chain, transformed by each link. Eventually, a <code>Subscriber</code> finishes the
process. Remember that nothing happens until a <code>Subscriber</code> subscribes to a <code>Publisher</code>,
as we see shortly.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Understanding that operators create new instances can help you avoid a common
mistake that would lead you to believe that an operator you used in your chain is not
being applied. See this <a href="#faq.chain">item</a> in the FAQ.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While the Reactive Streams specification does not specify operators at all, one of the
best added values of reactive libraries, such as Reactor, is the rich vocabulary of
operators that they provide. These cover a lot of ground, from simple transformation and
filtering to complex orchestration and error handling.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.subscribe"><a class="anchor" href="#reactive.subscribe"></a>3.3.4. Nothing Happens Until You <code>subscribe()</code></h4>
<div class="paragraph">
<p>In Reactor, when you write a <code>Publisher</code> chain, data does not start pumping into it by
default. Instead, you create an abstract description of your asynchronous process (which
can help with reusability and composition).</p>
</div>
<div class="paragraph">
<p>By the act of <strong>subscribing</strong>, you tie the <code>Publisher</code> to a <code>Subscriber</code>, which triggers
the flow of data in the whole chain. This is achieved internally by a single <code>request</code>
signal from the <code>Subscriber</code> that is propagated upstream, all the way back to the source
<code>Publisher</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.backpressure"><a class="anchor" href="#reactive.backpressure"></a>3.3.5. Backpressure</h4>
<div class="paragraph">
<p>Propagating signals upstream is also used to implement <strong>backpressure</strong>, which we described
in the assembly line analogy as a feedback signal sent up the line when a workstation
processes more slowly than an upstream workstation.</p>
</div>
<div class="paragraph">
<p>The real mechanism defined by the Reactive Streams specification is pretty close to the
analogy: A subscriber can work in <em>unbounded</em> mode and let the source push all the data
at its fastest achievable rate or it can use the <code>request</code> mechanism to signal the source
that it is ready to process at most <code>n</code> elements.</p>
</div>
<div class="paragraph">
<p>Intermediate operators can also change the request in-transit. Imagine a <code>buffer</code>
operator that groups elements in batches of ten. If the subscriber requests one buffer, it
is acceptable for the source to produce ten elements. Some operators also implement
<strong>prefetching</strong> strategies, which avoid <code>request(1)</code> round-trips and is beneficial
if producing the elements before they are requested is not too costly.</p>
</div>
<div class="paragraph">
<p>This transforms the push model into a <strong>push-pull hybrid</strong>, where the downstream can pull n
elements from upstream if they are readily available. But if the elements are not ready,
they get pushed by the upstream whenever they are produced.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.hotCold"><a class="anchor" href="#reactive.hotCold"></a>3.3.6. Hot vs Cold</h4>
<div class="paragraph">
<p>The Rx family of reactive libraries distinguishes two broad categories of
reactive sequences: <strong>hot</strong> and <strong>cold</strong>. This distinction mainly has to do with how the
reactive stream reacts to subscribers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <strong>Cold</strong> sequence starts anew for each <code>Subscriber</code>, including at the source of data.
For example, if the source wraps an HTTP call, a new HTTP request is made for each subscription.</p>
</li>
<li>
<p>A <strong>Hot</strong> sequence does not start from scratch for each <code>Subscriber</code>. Rather, late
subscribers receive signals emitted <em>after</em> they subscribed. Note, however, that some hot
reactive streams can cache or replay the history of emissions totally or partially. From
a general perspective, a hot sequence can even emit when no subscriber is listening (an
exception to the &#8220;nothing happens before you subscribe&#8221; rule).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information on hot vs cold in the context of Reactor, see
<a href="#reactor.hotCold">this reactor-specific section</a>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/reactiveProgramming.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#intro-reactive">Introduction to Reactive Programming</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="core-features"><a class="anchor" href="#core-features"></a>4. Reactor Core Features</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Reactor project main artifact is <code>reactor-core</code>, a reactive library that focuses on
the Reactive Streams specification and targets Java 8.</p>
</div>
<div class="paragraph">
<p>Reactor introduces composable reactive types that implement <code>Publisher</code> but also provide
a rich vocabulary of operators: <code>Flux</code> and <code>Mono</code>. A <code>Flux</code> object
represents a reactive sequence of 0..N items, while a <code>Mono</code> object represents a
single-value-or-empty (0..1) result.</p>
</div>
<div class="paragraph">
<p>This distinction carries a bit of semantic information into the type, indicating the
rough cardinality of the asynchronous processing. For instance, an HTTP request produces
only one response, so there is not much sense in doing a <code>count</code> operation. Expressing
the result of such an HTTP call as a <code>Mono&lt;HttpResponse&gt;</code> thus makes more sense than
expressing it as a <code>Flux&lt;HttpResponse&gt;</code>, as it offers only operators that are relevant to
a context of zero items or one item.</p>
</div>
<div class="paragraph">
<p>Operators that change the maximum cardinality of the processing also switch to the
relevant type. For instance, the <code>count</code> operator exists in <code>Flux</code>, but it returns a
<code>Mono&lt;Long&gt;</code>.</p>
</div>
<div class="sect2">
<h3 id="flux"><a class="anchor" href="#flux"></a>4.1. <code>Flux</code>, an Asynchronous Sequence of 0-N Items</h3>
<div class="paragraph">
<p>The following image shows how a <code>Flux</code> transforms items:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/flux.svg" alt="Flux">
</div>
</div>
<div class="paragraph">
<p>A <code>Flux&lt;T&gt;</code> is a standard <code>Publisher&lt;T&gt;</code> that represents an asynchronous sequence of 0 to N
emitted items, optionally terminated by either a completion signal or an error.
As in the Reactive Streams spec, these three types of signal translate to calls to a downstream
Subscriber&#8217;s <code>onNext</code>, <code>onComplete</code>, and <code>onError</code> methods.</p>
</div>
<div class="paragraph">
<p>With this large scope of possible signals, <code>Flux</code> is the general-purpose reactive type.
Note that all events, even terminating ones, are optional: no <code>onNext</code> event but an
<code>onComplete</code> event represents an <em>empty</em> finite sequence, but remove the <code>onComplete</code> and
you have an <em>infinite</em> empty sequence (not particularly useful, except for tests around cancellation).
Similarly, infinite sequences are not necessarily empty. For example, <code>Flux.interval(Duration)</code>
produces a <code>Flux&lt;Long&gt;</code> that is infinite and emits regular ticks from a clock.</p>
</div>
</div>
<div class="sect2">
<h3 id="mono"><a class="anchor" href="#mono"></a>4.2. <code>Mono</code>, an Asynchronous 0-1 Result</h3>
<div class="paragraph">
<p>The following image shows how a <code>Mono</code> transforms an item:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/mono.svg" alt="Mono">
</div>
</div>
<div class="paragraph">
<p>A <code>Mono&lt;T&gt;</code> is a specialized <code>Publisher&lt;T&gt;</code> that emits at most one item <em>via</em> the
<code>onNext</code> signal then terminates with an <code>onComplete</code> signal (successful <code>Mono</code>,
with or without value), or only emits a single <code>onError</code> signal (failed <code>Mono</code>).</p>
</div>
<div class="paragraph">
<p>Most <code>Mono</code> implementations are expected to immediately call <code>onComplete</code> on their
<code>Subscriber</code> after having called <code>onNext</code>. <code>Mono.never()</code> is an outlier: it doesn&#8217;t
emit any signal, which is not technically forbidden although not terribly useful outside
of tests. On the other hand, a combination of <code>onNext</code> and <code>onError</code> is explicitly forbidden.</p>
</div>
<div class="paragraph">
<p><code>Mono</code> offers only a subset of the operators that are available for a <code>Flux</code>, and
some operators (notably those that combine the <code>Mono</code> with another <code>Publisher</code>)
switch to a <code>Flux</code>.
For example, <code>Mono#concatWith(Publisher)</code> returns a <code>Flux</code> while <code>Mono#then(Mono)</code>
returns another <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p>Note that you can use a <code>Mono</code> to represent no-value asynchronous processes that only
have the concept of completion (similar to a <code>Runnable</code>). To create one, you can use an empty
<code>Mono&lt;Void&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it"><a class="anchor" href="#_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it"></a>4.3. Simple Ways to Create a Flux or Mono and Subscribe to It</h3>
<div class="paragraph">
<p>The easiest way to get started with <code>Flux</code> and <code>Mono</code> is to use one of the numerous
factory methods found in their respective classes.</p>
</div>
<div class="paragraph">
<p>For instance, to create a sequence of <code>String</code>, you can either enumerate them or put them
in a collection and create the Flux from it, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; seq1 = Flux.just("foo", "bar", "foobar");

List&lt;String&gt; iterable = Arrays.asList("foo", "bar", "foobar");
Flux&lt;String&gt; seq2 = Flux.fromIterable(iterable);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Other examples of factory methods include the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Mono&lt;String&gt; noData = Mono.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

Mono&lt;String&gt; data = Mono.just("foo");

Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(5, 3); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Notice the factory method honors the generic type even though it has no value.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The first parameter is the start of the range, while the second parameter is the
number of items to produce.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>When it comes to subscribing, <code>Flux</code> and <code>Mono</code> make use of Java 8 lambdas. You
have a wide choice of <code>.subscribe()</code> variants that take lambdas for different
combinations of callbacks, as shown in the following method signatures:</p>
</div>
<div id="subscribeMethods" class="exampleblock">
<div class="title">Example 10. Lambda-based subscribe variants for <code>Flux</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">subscribe(); <i class="conum" data-value="1"></i><b>(1)</b>

subscribe(Consumer&lt;? super T&gt; consumer); <i class="conum" data-value="2"></i><b>(2)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer); <i class="conum" data-value="3"></i><b>(3)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer); <i class="conum" data-value="4"></i><b>(4)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&lt;? super Subscription&gt; subscriptionConsumer); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Subscribe and trigger the sequence.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Do something with each produced value.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Deal with values but also react to an error.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Deal with values and errors but also run some code when the sequence successfully
completes.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Deal with values and errors and successful completion but also do something with the
<code>Subscription</code> produced by this <code>subscribe</code> call.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
These variants return a reference to the subscription that you can use to cancel the
subscription when no more data is needed. Upon cancellation, the source should stop
producing values and clean up any resources it created. This cancel-and-clean-up behavior
is represented in Reactor by the general-purpose <code>Disposable</code> interface.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_subscribe_method_examples"><a class="anchor" href="#_subscribe_method_examples"></a>4.3.1. <code>subscribe</code> Method Examples</h4>
<div class="paragraph">
<p>This section contains minimal examples of each of the five signatures for the <code>subscribe</code>
method. The following code shows an example of the basic method with no arguments:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set up a <code>Flux</code> that produces three values when a subscriber attaches.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Subscribe in the simplest way.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces no visible output, but it does work. The <code>Flux</code> produces
three values. If we provide a lambda, we can make the values visible. The next example
for the <code>subscribe</code> method shows one way to make the values appear:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i)); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set up a <code>Flux</code> that produces three values when a subscriber attaches.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Subscribe with a subscriber that will print the values.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">1
2
3</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To demonstrate the next signature, we intentionally introduce an error, as
shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; ints = Flux.range(1, 4) <i class="conum" data-value="1"></i><b>(1)</b>
      .map(i -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
        if (i &lt;= 3) return i; <i class="conum" data-value="3"></i><b>(3)</b>
        throw new RuntimeException("Got to 4"); <i class="conum" data-value="4"></i><b>(4)</b>
      });
ints.subscribe(i -&gt; System.out.println(i), <i class="conum" data-value="5"></i><b>(5)</b>
      error -&gt; System.err.println("Error: " + error));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set up a Flux that produces four values when a subscriber attaches.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We need a map so that we can handle some values differently.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>For most values, return the value.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>For one value, force an error.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Subscribe with a subscriber that includes an error handler.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>We now have two lambda expressions: one for the content we expect and one for
errors. The preceding code produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">1
2
3
Error: java.lang.RuntimeException: Got to 4</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The next signature of the <code>subscribe</code> method includes both an error handler and
a handler for completion events, as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; ints = Flux.range(1, 4); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done")); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set up a Flux that produces four values when a subscriber attaches.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Subscribe with a Subscriber that includes a handler for completion events.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Error signals and completion signals are both terminal events and are exclusive of one
another (you never get both). To make the completion consumer work, we must take care not
to trigger an error.</p>
</div>
<div class="paragraph">
<p>The completion callback has no input, as represented by an empty pair of
parentheses: It matches the <code>run</code> method in the <code>Runnable</code> interface. The preceding code
produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">1
2
3
4
Done</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The last signature of the <code>subscribe</code> method includes a <code>Consumer&lt;Subscription&gt;</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
That variant requires you to do something with the <code>Subscription</code> (perform a
<code>request(long)</code> on it or <code>cancel()</code> it). Otherwise the <code>Flux</code> hangs.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the last signature of the <code>subscribe</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done"),
    sub -&gt; sub.request(10)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>When we subscribe we receive a <code>Subscription</code>. Signal that we want up to <code>10</code>
elements from the source (which will actually emit 4 elements and complete).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancelling_a_subscribe_with_its_disposable"><a class="anchor" href="#_cancelling_a_subscribe_with_its_disposable"></a>4.3.2. Cancelling a <code>subscribe()</code> with Its <code>Disposable</code></h4>
<div class="paragraph">
<p>All these lambda-based variants of <code>subscribe()</code> have a <code>Disposable</code> return type.
In this case, the <code>Disposable</code> interface represents the fact that the subscription
can be <em>cancelled</em>, by calling its <code>dispose()</code> method.</p>
</div>
<div class="paragraph">
<p>For a <code>Flux</code> or <code>Mono</code>, cancellation is a signal that the source should stop
producing elements. However, it is NOT guaranteed to be immediate: Some sources
might produce elements so fast that they could complete even before receiving the
cancel instruction.</p>
</div>
<div class="paragraph">
<p>Some utilities around <code>Disposable</code> are available in the <code>Disposables</code> class.
Among these, <code>Disposables.swap()</code> creates a <code>Disposable</code> wrapper that lets
you atomically cancel and replace a concrete <code>Disposable</code>. This can be useful,
for instance, in a UI scenario where you want to cancel a request and replace it
with a new one whenever the user clicks on a button. Disposing the wrapper itself
closes it. Doing so disposes the current concrete value and all future attempted replacements.</p>
</div>
<div class="paragraph">
<p>Another interesting utility is <code>Disposables.composite(&#8230;&#8203;)</code>. This composite
lets you collect several <code>Disposable</code>&#8201;&#8212;&#8201;for instance, multiple in-flight requests
associated with a service call&#8201;&#8212;&#8201;and dispose all of them at once later on.
Once the composite&#8217;s <code>dispose()</code> method has been called, any attempt to add
another <code>Disposable</code> immediately disposes it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_an_alternative_to_lambdas_basesubscriber"><a class="anchor" href="#_an_alternative_to_lambdas_basesubscriber"></a>4.3.3. An Alternative to Lambdas: <code>BaseSubscriber</code></h4>
<div class="paragraph">
<p>There is an additional <code>subscribe</code> method that is more generic and takes a full-blown
<code>Subscriber</code> rather than composing one out of lambdas. In order to help with writing
such a <code>Subscriber</code>, we provide an extendable class called <code>BaseSubscriber</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Instances of <code>BaseSubscriber</code> (or subclasses of it) are <strong>single-use</strong>,
meaning that a <code>BaseSubscriber</code> cancels its subscription to the first <code>Publisher</code> if it
is subscribed to a second <code>Publisher</code>.
That is because using an instance twice would violate the Reactive Streams rule that
the <code>onNext</code> method of a <code>Subscriber</code> must not be called in parallel.
As a result, anonymous implementations are fine only if they are declared directly within
the call to <code>Publisher#subscribe(Subscriber)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can implement one of these. We call it a <code>SampleSubscriber</code>. The following
example shows how it would be attached to a <code>Flux</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">SampleSubscriber&lt;Integer&gt; ss = new SampleSubscriber&lt;Integer&gt;();
Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(ss);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows what <code>SampleSubscriber</code> could look like, as a minimalistic
implementation of a <code>BaseSubscriber</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package io.projectreactor.samples;

import org.reactivestreams.Subscription;

import reactor.core.publisher.BaseSubscriber;

public class SampleSubscriber&lt;T&gt; extends BaseSubscriber&lt;T&gt; {

	public void hookOnSubscribe(Subscription subscription) {
		System.out.println("Subscribed");
		request(1);
	}

	public void hookOnNext(T value) {
		System.out.println(value);
		request(1);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>SampleSubscriber</code> class extends <code>BaseSubscriber</code>, which is the recommended abstract
class for user-defined <code>Subscribers</code> in Reactor. The class offers hooks that can be
overridden to tune the subscriber&#8217;s behavior. By default, it triggers an unbounded
request and behaves exactly as <code>subscribe()</code>. However, extending <code>BaseSubscriber</code> is
much more useful when you want a custom request amount.</p>
</div>
<div class="paragraph">
<p>For a custom request amount, the bare minimum is to implement <code>hookOnSubscribe(Subscription subscription)</code>
and <code>hookOnNext(T value)</code>, as we did. In our case, the <code>hookOnSubscribe</code> method
prints a statement to standard out and makes the first request. Then the <code>hookOnNext</code>
method prints a statement and performs additional requests, one request
at a time.</p>
</div>
<div class="paragraph">
<p>The <code>SampleSubscriber</code> class produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Subscribed
1
2
3
4</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>BaseSubscriber</code> also offers a <code>requestUnbounded()</code> method to switch to unbounded mode
(equivalent to <code>request(Long.MAX_VALUE)</code>), as well as a <code>cancel()</code> method.</p>
</div>
<div class="paragraph">
<p>It also has additional hooks: <code>hookOnComplete</code>, <code>hookOnError</code>, <code>hookOnCancel</code>, and <code>hookFinally</code>
(which is always called when the sequence terminates, with the type of termination passed
in as a <code>SignalType</code> parameter)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You almost certainly want to implement the <code>hookOnError</code>, <code>hookOnCancel</code>, and
<code>hookOnComplete</code> methods. You may also want to implement the <code>hookFinally</code> method.
<code>SampleSubscriber</code> is the absolute minimum implementation of a <code>Subscriber</code> <em>that performs
bounded requests</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_on_backpressure_and_ways_to_reshape_requests"><a class="anchor" href="#_on_backpressure_and_ways_to_reshape_requests"></a>4.3.4. On Backpressure and Ways to Reshape Requests</h4>
<div class="paragraph">
<p>When implementing backpressure in Reactor, the way consumer pressure is propagated back to the source is by sending a <code>request</code> to the upstream operator.
The sum of current requests is sometimes referenced to as the current &#8220;demand&#8221;, or &#8220;pending request&#8221;.
Demand is capped at <code>Long.MAX_VALUE</code>, representing an unbounded request (meaning &#8220;produce as fast as you can&#8221;&#8201;&#8212;&#8201;basically disabling backpressure).</p>
</div>
<div class="paragraph">
<p>The first request comes from the final subscriber at subscription time, yet the most direct ways of subscribing all immediately trigger an unbounded request of <code>Long.MAX_VALUE</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subscribe()</code> and most of its lambda-based variants (to the exception of the one that has a <code>Consumer&lt;Subscription&gt;</code>)</p>
</li>
<li>
<p><code>block()</code>, <code>blockFirst()</code> and <code>blockLast()</code></p>
</li>
<li>
<p>iterating over a <code>toIterable()</code> or <code>toStream()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The simplest way of customizing the original request is to <code>subscribe</code> with a <code>BaseSubscriber</code> with the <code>hookOnSubscribe</code> method overridden, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.range(1, 10)
    .doOnRequest(r -&gt; System.out.println("request of " + r))
    .subscribe(new BaseSubscriber&lt;Integer&gt;() {

      @Override
      public void hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      public void hookOnNext(Integer integer) {
        System.out.println("Cancelling after having received " + integer);
        cancel();
      }
    });</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding snippet prints out the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">request of 1
Cancelling after having received 1</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When manipulating a request, you must be careful to produce enough demand for
the sequence to advance, or your Flux can get &#8220;stuck&#8221;. That is why <code>BaseSubscriber</code>
defaults to an unbounded request in <code>hookOnSubscribe</code>. When overriding this hook, you should usually
call <code>request</code> at least once.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_operators_that_change_the_demand_from_downstream"><a class="anchor" href="#_operators_that_change_the_demand_from_downstream"></a>Operators that Change the Demand from Downstream</h5>
<div class="paragraph">
<p>One thing to keep in mind is that demand expressed at the subscribe level <strong>can</strong> be reshaped by each operator in the upstream chain.
A textbook case is the <code>buffer(N)</code> operator: If it receives a <code>request(2)</code>, it is interpreted as a demand for <strong>two full buffers</strong>.
As a consequence, since buffers need <code>N</code> elements to be considered full, the <code>buffer</code> operator reshapes the request to <code>2 x N</code>.</p>
</div>
<div class="paragraph">
<p>You might also have noticed that some operators have variants that take an <code>int</code> input parameter called <code>prefetch</code>.
This is another category of operators that modify the downstream request.
These are usually operators that deal with inner sequences, deriving a <code>Publisher</code> from each incoming element (like <code>flatMap</code>).</p>
</div>
<div class="paragraph">
<p><strong>Prefetch</strong> is a way to tune the initial request made on these inner sequences.
If unspecified, most of these operators start with a demand of <code>32</code>.</p>
</div>
<div class="paragraph">
<p>These operators usually also implement a <strong>replenishing optimization</strong>: Once the operator has seen 75% of the prefetch request fulfilled, it re-requests 75% from upstream.
This is a heuristic optimization made so that these operators proactively anticipate the upcoming requests.</p>
</div>
<div class="paragraph">
<p>Finally, a couple of operators let you directly tune the request: <code>limitRate</code> and <code>limitRequest</code>.</p>
</div>
<div class="paragraph">
<p><code>limitRate(N)</code> splits the downstream requests so that they are propagated upstream in smaller batches.
For instance, a request of <code>100</code> made to <code>limitRate(10)</code> would result in, at most, <code>10</code> requests of <code>10</code> being propagated to the upstream.
Note that, in this form, <code>limitRate</code> actually implements the replenishing optimization discussed earlier.</p>
</div>
<div class="paragraph">
<p>The operator has a variant that also lets you tune the replenishing amount (referred to as the <code>lowTide</code> in the variant): <code>limitRate(highTide, lowTide)</code>.
Choosing a <code>lowTide</code> of <code>0</code> results in <strong>strict</strong> batches of <code>highTide</code> requests, instead of batches further reworked by the replenishing strategy.</p>
</div>
<div class="paragraph">
<p><code>limitRequest(N)</code>, on the other hand, <strong>caps</strong> the downstream request to a maximum total demand.
It adds up requests up to <code>N</code>. If a single <code>request</code> does not make the total demand overflow over <code>N</code>, that particular request is wholly propagated upstream.
After that amount has been emitted by the source, <code>limitRequest</code> considers the sequence complete, sends an <code>onComplete</code> signal downstream, and cancels the source.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producing"><a class="anchor" href="#producing"></a>4.4. Programmatically creating a sequence</h3>
<div class="paragraph">
<p>In this section, we introduce the creation of a <code>Flux</code> or a <code>Mono</code> by
programmatically defining its associated events (<code>onNext</code>, <code>onError</code>, and
<code>onComplete</code>). All these methods share the fact that they expose an API to
trigger the events that we call a <strong>sink</strong>. There are actually a few sink
variants, which we&#8217;ll get to shortly.</p>
</div>
<div class="sect3">
<h4 id="producing.generate"><a class="anchor" href="#producing.generate"></a>4.4.1. Synchronous <code>generate</code></h4>
<div class="paragraph">
<p>The simplest form of programmatic creation of a <code>Flux</code> is through the <code>generate</code>
method, which takes a generator function.</p>
</div>
<div class="paragraph">
<p>This is for <strong>synchronous</strong> and <strong>one-by-one</strong> emissions, meaning that
the sink is a <code>SynchronousSink</code> and that its <code>next()</code> method can only be called
at most once per callback invocation. You can then additionally call <code>error(Throwable)</code>
or <code>complete()</code>, but this is optional.</p>
</div>
<div class="paragraph">
<p>The most useful variant is probably the one that also lets you keep a state
that you can refer to in your sink usage to decide what to emit next. The generator
function then becomes a <code>BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt;</code>, with <code>&lt;S&gt;</code> the
type of the state object. You have to provide a <code>Supplier&lt;S&gt;</code> for the initial
state, and your generator function now returns a new state on each round.</p>
</div>
<div class="paragraph">
<p>For instance, you could use an <code>int</code> as the state:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Example of state-based <code>generate</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; flux = Flux.generate(
    () -&gt; 0, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      sink.next("3 x " + state + " = " + 3*state); <i class="conum" data-value="2"></i><b>(2)</b>
      if (state == 10) sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
      return state + 1; <i class="conum" data-value="4"></i><b>(4)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We supply the initial state value of 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We use the state to choose what to emit (a row in the multiplication table
of 3).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We also use it to choose when to stop.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We return a new state that we use in the next invocation (unless the
sequence terminated in this one).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code generates the table of 3, as the following sequence:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>3 x 0 = 0
3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
3 x 6 = 18
3 x 7 = 21
3 x 8 = 24
3 x 9 = 27
3 x 10 = 30</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use a mutable <code>&lt;S&gt;</code>. The example above could for instance be
rewritten using a single <code>AtomicLong</code> as the state, mutating it on each round:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. Mutable state variant</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This time, we generate a mutable object as the state.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We mutate the state here.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We return the <strong>same</strong> instance as the new state.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If your state object needs to clean up some resources, use the
<code>generate(Supplier&lt;S&gt;, BiFunction, Consumer&lt;S&gt;)</code> variant to clean up the last
state instance.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example uses the <code>generate</code> method that includes a <code>Consumer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new,
      (state, sink) -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    }, (state) -&gt; System.out.println("state: " + state)); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Again, we generate a mutable object as the state.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We mutate the state here.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We return the <strong>same</strong> instance as the new state.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We see the last state value (11) as the output of this <code>Consumer</code> lambda.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In the case of the state containing a database connection or other resource
that needs to be handled at the end of the process, the <code>Consumer</code> lambda could
close the connection or  otherwise handle any tasks that should be done at the
end of the process.</p>
</div>
</div>
<div class="sect3">
<h4 id="producing.create"><a class="anchor" href="#producing.create"></a>4.4.2. Asynchronous and Multi-threaded: <code>create</code></h4>
<div class="paragraph">
<p><code>create</code> is a more advanced form of programmatic creation of a <code>Flux</code> which is
suitable for multiple emissions per round, even from multiple threads.</p>
</div>
<div class="paragraph">
<p>It exposes a <code>FluxSink</code>, with its <code>next</code>, <code>error</code>, and <code>complete</code> methods.
Contrary to <code>generate</code>, it doesn&#8217;t have a state-based variant. On the other
hand, it can trigger multi-threaded events in the callback.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>create</code> can be very useful to bridge an existing API with the reactive
world - such as an asynchronous API based on listeners.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>create</code> <strong>doesn&#8217;t parallelize your code nor does it make it asynchronous</strong>, even
though it <em>can</em> be used with asynchronous APIs. If you block within the <code>create</code> lambda,
you expose yourself to deadlocks and similar side effects. Even with the use of <code>subscribeOn</code>,
there&#8217;s the caveat that a long-blocking <code>create</code> lambda (such as an infinite loop calling
<code>sink.next(t)</code>) can lock the pipeline: the requests would never be performed due to the
loop starving the same thread they are supposed to run from. Use the <code>subscribeOn(Scheduler, false)</code>
variant: <code>requestOnSeparateThread = false</code> will use the <code>Scheduler</code> thread for the <code>create</code>
and still let data flow by performing <code>request</code> in the original thread.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Imagine that you use a listener-based API. It processes data by chunks
and has two events: (1) a chunk of data is ready and (2) the processing is
complete (terminal event), as represented in the <code>MyEventListener</code> interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">interface MyEventListener&lt;T&gt; {
    void onDataChunk(List&lt;T&gt; chunk);
    void processComplete();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use <code>create</code> to bridge this into a <code>Flux&lt;T&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myEventProcessor.register( <i class="conum" data-value="4"></i><b>(4)</b>
      new MyEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Bridge to the <code>MyEventListener</code> API</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Each element in a chunk becomes an element in the <code>Flux</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>processComplete</code> event is translated to <code>onComplete</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>All of this is done asynchronously whenever the <code>myEventProcessor</code> executes.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Additionally, since <code>create</code> can bridge asynchronous APIs and manages backpressure, you
can refine how to behave backpressure-wise, by indicating an <code>OverflowStrategy</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IGNORE</code> to Completely ignore downstream backpressure requests.
This may yield <code>IllegalStateException</code> when queues get full downstream.</p>
</li>
<li>
<p><code>ERROR</code> to signal an <code>IllegalStateException</code> when the downstream can&#8217;t keep
up.</p>
</li>
<li>
<p><code>DROP</code> to drop the incoming signal if the downstream is not ready to receive
it.</p>
</li>
<li>
<p><code>LATEST</code> to let downstream only get the latest signals from upstream.</p>
</li>
<li>
<p><code>BUFFER</code> (the default) to buffer all signals if the downstream can&#8217;t keep up.
(this does unbounded buffering and may lead to <code>OutOfMemoryError</code>).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Mono</code> also has a <code>create</code> generator. The <code>MonoSink</code> of Mono&#8217;s create
doesn&#8217;t allow several emissions. It will drop all signals after the first one.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_asynchronous_but_single_threaded_push"><a class="anchor" href="#_asynchronous_but_single_threaded_push"></a>4.4.3. Asynchronous but single-threaded: <code>push</code></h4>
<div class="paragraph">
<p><code>push</code> is a middle ground between <code>generate</code> and <code>create</code> which is suitable for
processing events from a single producer. It is similar to <code>create</code> in the sense
that it can also be asynchronous and can manage backpressure using any of the
overflow strategies supported by <code>create</code>. However, <strong>only one producing thread</strong>
may invoke <code>next</code>, <code>complete</code> or <code>error</code> at a time.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; bridge = Flux.push(sink -&gt; {
    myEventProcessor.register(
      new SingleThreadEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }

        public void processError(Throwable e) {
            sink.error(e); <i class="conum" data-value="4"></i><b>(4)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Bridge to the <code>SingleThreadEventListener</code> API.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Events are pushed to the sink using <code>next</code> from a single listener thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>complete</code> event generated from the same listener thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>error</code> event also generated from the same listener thread.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_a_hybrid_pushpull_model"><a class="anchor" href="#_a_hybrid_pushpull_model"></a>A hybrid push/pull model</h5>
<div class="paragraph">
<p>Most Reactor operators, like <code>create</code>, follow a hybrid <strong>push/pull</strong> model.
What we mean by that is that despite most of the processing being asynchronous
(suggesting a <em>push</em> approach), there is a small <em>pull</em> component to it: the
request.</p>
</div>
<div class="paragraph">
<p>The consumer <em>pulls</em> data from the source in the sense that it won&#8217;t emit anything
until first requested. The source <em>pushes</em> data to the consumer whenever it
becomes available, but within the bounds of its requested amount.</p>
</div>
<div class="paragraph">
<p>Note that <code>push()</code> and <code>create()</code> both allow to set up an <code>onRequest</code> consumer
in order to manage the request amount and to ensure that data is pushed through
the sink only when there is pending request.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myMessageProcessor.register(
      new MyMessageListener&lt;String&gt;() {

        public void onMessage(List&lt;String&gt; messages) {
          for(String s : messages) {
            sink.next(s); <i class="conum" data-value="3"></i><b>(3)</b>
          }
        }
    });
    sink.onRequest(n -&gt; {
        List&lt;String&gt; messages = myMessageProcessor.getHistory(n); <i class="conum" data-value="1"></i><b>(1)</b>
        for(String s : messages) {
           sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Poll for messages when requests are made.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If messages are available immediately, push them to the sink.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The remaining messages that arrive asynchronously later are also delivered.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_cleaning_up_after_push_or_create"><a class="anchor" href="#_cleaning_up_after_push_or_create"></a>Cleaning up after <code>push()</code> or <code>create()</code></h5>
<div class="paragraph">
<p>Two callbacks, <code>onDispose</code> and <code>onCancel</code>, perform any cleanup on cancellation
or termination. <code>onDispose</code> can be used to perform cleanup when the <code>Flux</code>
completes, errors out, or is cancelled. <code>onCancel</code> can be used to perform any
action specific to cancellation prior to cleanup with <code>onDispose</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    sink.onRequest(n -&gt; channel.poll(n))
        .onCancel(() -&gt; channel.cancel()) <i class="conum" data-value="1"></i><b>(1)</b>
        .onDispose(() -&gt; channel.close())  <i class="conum" data-value="2"></i><b>(2)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>onCancel</code> is invoked first, for cancel signal only.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>onDispose</code> is invoked for complete, error, or cancel signals.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handle"><a class="anchor" href="#_handle"></a>4.4.4. Handle</h4>
<div class="paragraph">
<p>The <code>handle</code> method is a bit different: it is an instance method, meaning that
it is chained on an existing source (as are the common operators). It is present
in both <code>Mono</code> and <code>Flux</code>.</p>
</div>
<div class="paragraph">
<p>It is close to <code>generate</code>, in the sense that it uses a <code>SynchronousSink</code> and
only allows one-by-one emissions. However, <code>handle</code> can be used to generate an
arbitrary value out of each source element, possibly skipping some elements. In
this way, it can serve as a combination of <code>map</code> and <code>filter</code>. The signature of
handle is as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;R&gt; handle(BiConsumer&lt;T, SynchronousSink&lt;R&gt;&gt;);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s consider an example. The reactive streams specification disallows <code>null</code>
values in a sequence. What if you want to perform a <code>map</code> but you want to use
a preexisting method as the map function, and that method sometimes returns null?</p>
</div>
<div class="paragraph">
<p>For instance, the following method can be applied safely to a source of
integers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public String alphabet(int letterNumber) {
	if (letterNumber &lt; 1 || letterNumber &gt; 26) {
		return null;
	}
	int letterIndexAscii = 'A' + letterNumber - 1;
	return "" + (char) letterIndexAscii;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We can then use <code>handle</code> to remove any nulls:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. Using <code>handle</code> for a "map and eliminate nulls" scenario</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; alphabet = Flux.just(-1, 30, 13, 9, 20)
    .handle((i, sink) -&gt; {
        String letter = alphabet(i); <i class="conum" data-value="1"></i><b>(1)</b>
        if (letter != null) <i class="conum" data-value="2"></i><b>(2)</b>
            sink.next(letter); <i class="conum" data-value="3"></i><b>(3)</b>
    });

alphabet.subscribe(System.out::println);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Map to letters.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the "map function" returns null&#8230;&#8203;.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Filter it out by not calling <code>sink.next</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Which will print out:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>M
I
T</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schedulers"><a class="anchor" href="#schedulers"></a>4.5. Threading and Schedulers</h3>
<div class="paragraph">
<p>Reactor, like RxJava, can be considered to be <strong>concurrency-agnostic</strong>. That is, it does not
enforce a concurrency model. Rather, it leaves you, the developer, in command. However,
that does not prevent the library from helping you with concurrency.</p>
</div>
<div class="paragraph">
<p>Obtaining a <code>Flux</code> or a <code>Mono</code> does not necessarily mean that it runs in a dedicated
<code>Thread</code>. Instead, most operators continue working in the <code>Thread</code> on which the
previous operator executed. Unless specified, the topmost operator (the source)
itself runs on the <code>Thread</code> in which the <code>subscribe()</code> call was made. The following
example runs a <code>Mono</code> in a new thread:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) throws InterruptedException {
  final Mono&lt;String&gt; mono = Mono.just("hello "); <i class="conum" data-value="1"></i><b>(1)</b>

  Thread t = new Thread(() -&gt; mono
      .map(msg -&gt; msg + "thread ")
      .subscribe(v -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
          System.out.println(v + Thread.currentThread().getName()) <i class="conum" data-value="3"></i><b>(3)</b>
      )
  )
  t.start();
  t.join();

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Mono&lt;String&gt;</code> is assembled in thread <code>main</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>However, it is subscribed to in thread <code>Thread-0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>As a consequence, both the <code>map</code> and the <code>onNext</code> callback actually run in <code>Thread-0</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">hello thread Thread-0</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In Reactor, the execution model and where the execution happens is determined by the
<code>Scheduler</code> that is used. A
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html"><code>Scheduler</code></a>
has scheduling responsibilities similar to an <code>ExecutorService</code>, but having a
dedicated abstraction lets it do more, notably acting as a clock and enabling
a wider range of implementations (virtual time for tests, trampolining or
immediate scheduling, and so on).</p>
</div>
<div class="paragraph">
<p>The <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html"><code>Schedulers</code></a>
class has static methods that give access to the following execution contexts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No execution context (<code>Schedulers.immediate()</code>): at processing time, the submitted <code>Runnable</code>
will be directly executed, effectively running them on the current <code>Thread</code> (can be seen as a "null object" or no-op <code>Scheduler</code>).</p>
</li>
<li>
<p>A single, reusable thread (<code>Schedulers.single()</code>). Note that this method reuses the
same thread for all callers, until the Scheduler is disposed. If you want a per-call
dedicated thread, use <code>Schedulers.newSingle()</code> for each call.</p>
</li>
<li>
<p>An unbounded elastic thread pool (<code>Schedulers.elastic()</code>). This one is no longer preferred
with the introduction of <code>Schedulers.boundedElastic()</code>, as it has a tendency to hide backpressure
problems and lead to too many threads (see below).</p>
</li>
<li>
<p>A bounded elastic thread pool (<code>Schedulers.boundedElastic()</code>). Like its predecessor <code>elastic()</code>, it
creates new worker pools as needed and reuses idle ones. Worker pools that stay idle for too long (the default is 60s) are
also disposed. Unlike its <code>elastic()</code> predecessor, it has a cap on the number of backing threads it can create (default is number of CPU cores x 10).
Up to 100 000 tasks submitted after the cap has been reached are enqueued and will be re-scheduled when a thread becomes available
(when scheduling with a delay, the delay starts when the thread becomes available). This is a better choice for I/O blocking work.
<code>Schedulers.boundedElastic()</code> is a handy way to give a blocking process its own thread so that
it does not tie up other resources. See <a href="#faq.wrap-blocking">How Do I Wrap a Synchronous, Blocking Call?</a>, but doesn&#8217;t pressure the system too much with new threads.</p>
</li>
<li>
<p>A fixed pool of workers that is tuned for parallel work (<code>Schedulers.parallel()</code>). It
creates as many workers as you have CPU cores.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, you can create a <code>Scheduler</code> out of any pre-existing <code>ExecutorService</code> by
using <code>Schedulers.fromExecutorService(ExecutorService)</code>. (You can also create one from an
<code>Executor</code>, although doing so is discouraged.)</p>
</div>
<div class="paragraph">
<p>You can also create new instances of the various scheduler types by using the <code>newXXX</code>
methods. For example, <code>Schedulers.newParallel(yourScheduleName)</code> creates a new parallel
scheduler named <code>yourScheduleName</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While <code>boundedElastic</code> is made to help with legacy blocking code if it cannot be avoided,
<code>single</code> and <code>parallel</code> are not. As a consequence, the use of Reactor blocking APIs
(<code>block()</code>, <code>blockFirst()</code>, <code>blockLast()</code> (as well as iterating over <code>toIterable()</code>
or <code>toStream()</code>) inside the default single and parallel schedulers) results in
an <code>IllegalStateException</code> being thrown.</p>
</div>
<div class="paragraph">
<p>Custom <code>Schedulers</code> can also be marked as "non blocking only" by creating instances of <code>Thread</code>
that implement the <code>NonBlocking</code> marker interface.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some operators use a specific scheduler from <code>Schedulers</code> by default (and usually give
you the option of providing a different one). For instance, calling the
<code>Flux.interval(Duration.ofMillis(300))</code> factory method produces a <code>Flux&lt;Long&gt;</code> that ticks every 300ms.
By default, this is enabled by <code>Schedulers.parallel()</code>. The following line changes the
Scheduler to a new instance similar to <code>Schedulers.single()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.interval(Duration.ofMillis(300), Schedulers.newSingle("test"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Reactor offers two means of switching the execution context (or <code>Scheduler</code>) in a
reactive chain: <code>publishOn</code> and <code>subscribeOn</code>. Both take a <code>Scheduler</code> and let you switch
the execution context to that scheduler. But the placement of <code>publishOn</code> in the chain
matters, while the placement of <code>subscribeOn</code> does not. To understand that difference,
you first have to remember that <a href="#reactive.subscribe">nothing happens until you
subscribe</a>.</p>
</div>
<div class="paragraph">
<p>In Reactor, when you chain operators, you can wrap as many <code>Flux</code> and <code>Mono</code>
implementations inside one another as you need. Once you subscribe, a chain of
<code>Subscriber</code> objects is created, backward (up the chain) to the first
publisher. This is effectively hidden from you. All you can see is the outer layer of
<code>Flux</code> (or <code>Mono</code>) and <code>Subscription</code>, but these intermediate operator-specific
subscribers are where the real work happens.</p>
</div>
<div class="paragraph">
<p>With that knowledge, we can have a closer look at the <code>publishOn</code> and <code>subscribeOn</code>
operators:</p>
</div>
<div class="sect3">
<h4 id="_the_publishon_method"><a class="anchor" href="#_the_publishon_method"></a>4.5.1. The <code>publishOn</code> Method</h4>
<div class="paragraph">
<p><code>publishOn</code> applies in the same way as any other operator, in the middle of the
subscriber chain. It takes signals from upstream and replays them downstream while
executing the callback on a worker from the associated <code>Scheduler</code>. Consequently, it
<strong>affects where the subsequent operators execute</strong> (until another <code>publishOn</code> is
chained in), as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Changes the execution context to one <code>Thread</code> picked by the <code>Scheduler</code></p>
</li>
<li>
<p>as per the specification, <code>onNext</code> calls happen in sequence, so this uses up a single thread</p>
</li>
<li>
<p>unless they work on a specific <code>Scheduler</code>, operators after <code>publishOn</code> continue execution on that same thread</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example uses the <code>publishOn</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .publishOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a new <code>Scheduler</code> backed by four <code>Thread</code> instances.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The first <code>map</code> runs on the anonymous thread in &lt;5&gt;.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>publishOn</code> switches the whole sequence on a <code>Thread</code> picked from &lt;1&gt;.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The second <code>map</code> runs on the <code>Thread</code> from &lt;1&gt;.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This anonymous <code>Thread</code> is the one where the <em>subscription</em> happens.
The print happens on the latest execution context, which is the one from <code>publishOn</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_subscribeon_method"><a class="anchor" href="#_the_subscribeon_method"></a>4.5.2. The <code>subscribeOn</code> Method</h4>
<div class="paragraph">
<p><code>subscribeOn</code> applies to the subscription process, when that backward chain is
constructed. As a consequence, no matter where you place the <code>subscribeOn</code> in the chain,
<strong>it always affects the context of the source emission</strong>. However, this does not affect the
behavior of subsequent calls to <code>publishOn</code>&#8201;&#8212;&#8201;they still switch the execution context for
the part of the chain after them.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Changes the <code>Thread</code> from which the <strong>whole chain</strong> of operators subscribes</p>
</li>
<li>
<p>Picks one thread from the <code>Scheduler</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Only the earliest <code>subscribeOn</code> call in the chain is actually taken into account.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example uses the <code>subscribeOn</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .subscribeOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a new <code>Scheduler</code> backed by four <code>Thread</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The first <code>map</code> runs on one of these four threads&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;because <code>subscribeOn</code> switches the whole sequence right from subscription time (&lt;5&gt;).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The second <code>map</code> also runs on same thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This anonymous <code>Thread</code> is the one where the <em>subscription</em> initially happens, but <code>subscribeOn</code> immediately shifts it to one of the four scheduler threads.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="error.handling"><a class="anchor" href="#error.handling"></a>4.6. Handling Errors</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For a quick look at the available operators for error handling, see
<a href="#which.errors">the relevant operator decision tree</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In Reactive Streams, errors are terminal events. As soon as an error occurs, it stops the
sequence and gets propagated down the chain of operators to the last step, the
<code>Subscriber</code> you defined and its <code>onError</code> method.</p>
</div>
<div class="paragraph">
<p>Such errors should still be dealt with at the application level. For instance, you might
display an error notification in a UI or send a meaningful error payload in a REST
endpoint. For this reason, the subscriber&#8217;s <code>onError</code> method should always be defined.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If not defined, <code>onError</code> throws an <code>UnsupportedOperationException</code>. You can
further detect and triage it with the <code>Exceptions.isErrorCallbackNotImplemented</code> method.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactor also offers alternative means of dealing with errors in the middle of the chain,
as error-handling operators. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.just(1, 2, 0)
    .map(i -&gt; "100 / " + i + " = " + (100 / i)) //this triggers an error with 0
    .onErrorReturn("Divided by zero :("); // error handling example</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Before you learn about error-handling operators, you must keep in mind that
<em>any error in a reactive sequence is a terminal event</em>. Even if an error-handling
operator is used, it does not let the original sequence continue. Rather, it
converts the <code>onError</code> signal into the start of a new sequence (the fallback one). In
other words, it replaces the terminated sequence <em>upstream</em> of it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can consider each means of error handling one-by-one. When relevant, we make a
parallel with imperative programming&#8217;s <code>try</code> patterns.</p>
</div>
<div class="sect3">
<h4 id="_error_handling_operators"><a class="anchor" href="#_error_handling_operators"></a>4.6.1. Error Handling Operators</h4>
<div class="paragraph">
<p>You may be familiar with several ways of dealing with exceptions in a try-catch block.
Most notably, these include the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Catch and return a static default value.</p>
</li>
<li>
<p>Catch and execute an alternative path with a fallback method.</p>
</li>
<li>
<p>Catch and dynamically compute a fallback value.</p>
</li>
<li>
<p>Catch, wrap to a <code>BusinessException</code>, and re-throw.</p>
</li>
<li>
<p>Catch, log an error-specific message, and re-throw.</p>
</li>
<li>
<p>Use the <code>finally</code> block to clean up resources or a Java 7 &#8220;try-with-resource&#8221; construct.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of these have equivalents in Reactor, in the form of error-handling operators.
Before looking into these operators, we first want to establish a parallel between a reactive
chain and a try-catch block.</p>
</div>
<div class="paragraph">
<p>When subscribing, the <code>onError</code> callback at the end of the chain is akin to a <code>catch</code>
block. There, execution skips to the catch in case an <code>Exception</code> is thrown, as the
following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; s = Flux.range(1, 10)
    .map(v -&gt; doSomethingDangerous(v)) <i class="conum" data-value="1"></i><b>(1)</b>
    .map(v -&gt; doSecondTransform(v)); <i class="conum" data-value="2"></i><b>(2)</b>
s.subscribe(value -&gt; System.out.println("RECEIVED " + value), <i class="conum" data-value="3"></i><b>(3)</b>
            error -&gt; System.err.println("CAUGHT " + error) <i class="conum" data-value="4"></i><b>(4)</b>
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A transformation that can throw an exception is performed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If everything went well, a second transformation is performed.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Each successfully transformed value is printed out.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In case of an error, the sequence terminates and an error message is displayed.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example is conceptually similar to the following try-catch block:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">try {
    for (int i = 1; i &lt; 11; i++) {
        String v1 = doSomethingDangerous(i); <i class="conum" data-value="1"></i><b>(1)</b>
        String v2 = doSecondTransform(v1); <i class="conum" data-value="2"></i><b>(2)</b>
        System.out.println("RECEIVED " + v2);
    }
} catch (Throwable t) {
    System.err.println("CAUGHT " + t); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If an exception is thrown here&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;the rest of the loop is skipped&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203; and the execution goes straight to here.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Now that we have established a parallel, we can look at the different error handling cases
and their equivalent operators.</p>
</div>
<div class="sect4">
<h5 id="_static_fallback_value"><a class="anchor" href="#_static_fallback_value"></a>Static Fallback Value</h5>
<div class="paragraph">
<p>The equivalent of &#8220;Catch and return a static default value&#8221; is <code>onErrorReturn</code>.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return "RECOVERED";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the Reactor equivalent:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn("RECOVERED");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You also have the option of applying a <code>Predicate</code> on the exception to decide
whether or not to recover, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(e -&gt; e.getMessage().equals("boom10"), "recovered10"); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Recover only if the message of the exception is <code>"boom10"</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_fallback_method"><a class="anchor" href="#_fallback_method"></a>Fallback Method</h5>
<div class="paragraph">
<p>If you want more than a single default value and you have an alternative (safer) way of
processing your data, you can use <code>onErrorResume</code>. This would be the equivalent of
&#8220;Catch and execute an alternative path with a fallback method&#8221;.</p>
</div>
<div class="paragraph">
<p>For example, if your nominal process is fetching data from an external and unreliable
service but you also keep a local cache of the same data that <em>can</em> be a bit more out of
date but is more reliable, you could do the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String v1;
try {
  v1 = callExternalService("key1");
}
catch (Throwable error) {
  v1 = getFromCache("key1");
}

String v2;
try {
  v2 = callExternalService("key2");
}
catch (Throwable error) {
  v2 = getFromCache("key2");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the Reactor equivalent:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.just("key1", "key2")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .onErrorResume(e -&gt; getFromCache(k)) <i class="conum" data-value="2"></i><b>(2)</b>
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>For each key, asynchronously call the external service.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the external service call fails, fall back to the cache for that key. Note that
we always apply the same fallback, whatever the source error, <code>e</code>, is.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Like <code>onErrorReturn</code>, <code>onErrorResume</code> has variants that let you filter which exceptions
to fall back on, based either on the exception&#8217;s class or on a <code>Predicate</code>. The fact that it
takes a <code>Function</code> also lets you choose a different fallback sequence to switch to,
depending on the error encountered. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.just("timeout1", "unknown", "key2")
    .flatMap(k -&gt; callExternalService(k)
        .onErrorResume(error -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
            if (error instanceof TimeoutException) <i class="conum" data-value="2"></i><b>(2)</b>
                return getFromCache(k);
            else if (error instanceof UnknownKeyException)  <i class="conum" data-value="3"></i><b>(3)</b>
                return registerNewEntry(k, "DEFAULT");
            else
                return Flux.error(error); <i class="conum" data-value="4"></i><b>(4)</b>
        })
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function allows dynamically choosing how to continue.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the source times out, hit the local cache.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the source says the key is unknown, create a new entry.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In all other cases, &#8220;re-throw&#8221;.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_dynamic_fallback_value"><a class="anchor" href="#_dynamic_fallback_value"></a>Dynamic Fallback Value</h5>
<div class="paragraph">
<p>Even if you do not have an alternative (safer) way of processing your data, you might want
to compute a fallback value out of the exception you received. This would be the
equivalent of &#8220;Catch and dynamically compute a fallback value&#8221;.</p>
</div>
<div class="paragraph">
<p>For instance, if your return type (<code>MyWrapper</code>) has a variant dedicated to holding an exception (think
<code>Future.complete(T success)</code> versus <code>Future.completeExceptionally(Throwable error)</code>), you
could instantiate the error-holding variant and pass the exception.</p>
</div>
<div class="paragraph">
<p>An imperative example would look like the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can do this reactively in the same way as the fallback method solution,
by using <code>onErrorResume</code>, with a tiny bit of boilerplate, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">erroringFlux.onErrorResume(error -&gt; Mono.just( <i class="conum" data-value="1"></i><b>(1)</b>
        MyWrapper.fromError(error) <i class="conum" data-value="2"></i><b>(2)</b>
));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Since you expect a <code>MyWrapper</code> representation of the error, you need to get a
<code>Mono&lt;MyWrapper&gt;</code> for <code>onErrorResume</code>. We use <code>Mono.just()</code> for that.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We need to compute the value out of the exception. Here, we achieved that
by wrapping the exception with a relevant <code>MyWrapper</code> factory method.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_catch_and_rethrow"><a class="anchor" href="#_catch_and_rethrow"></a>Catch and Rethrow</h5>
<div class="paragraph">
<p>"Catch, wrap to a <code>BusinessException</code>, and re-throw" looks like the following in the
imperative world:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">try {
  return callExternalService(k);
}
catch (Throwable error) {
  throw new BusinessException("oops, SLA exceeded", error);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the &#8220;fallback method&#8221; example, the last line inside the <code>flatMap</code> gives us a hint
at achieving the same reactively, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorResume(original -&gt; Flux.error(
            new BusinessException("oops, SLA exceeded", original))
    );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>However, there is a more straightforward way of achieving the same effect with <code>onErrorMap</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorMap(original -&gt; new BusinessException("oops, SLA exceeded", original));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_log_or_react_on_the_side"><a class="anchor" href="#_log_or_react_on_the_side"></a>Log or React on the Side</h5>
<div class="paragraph">
<p>For cases where you want the error to continue propagating but still want to react to
it without modifying the sequence (logging it, for instance), you can use the <code>doOnError</code>
operator. This is the equivalent of &#8220;Catch, log an error-specific message, and re-throw&#8221;
pattern, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">try {
  return callExternalService(k);
}
catch (RuntimeException error) {
  //make a record of the error
  log("uh oh, falling back, service failed for key " + k);
  throw error;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>doOnError</code> operator, as well as all operators prefixed with <code>doOn</code> , are sometimes
referred to as having a &#8220;side-effect&#8221;. They let you peek inside the sequence&#8217;s events without
modifying them.</p>
</div>
<div class="paragraph">
<p>Like the imperative example shown earlier, the following example still propagates the error yet
ensures that we at least log that the external service had a failure:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">LongAdder failureStat = new LongAdder();
Flux&lt;String&gt; flux =
Flux.just("unknown")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .doOnError(e -&gt; {
            failureStat.increment();
            log("uh oh, falling back, service failed for key " + k); <i class="conum" data-value="2"></i><b>(2)</b>
        })
        <i class="conum" data-value="3"></i><b>(3)</b>
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The external service call that can fail&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;is decorated with a logging and stats side-effect&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;after which, it still terminates with an error, unless we use an error-recovery operator here.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>We can also imagine we have statistic counters to increment as a second error side-effect.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_resources_and_the_finally_block"><a class="anchor" href="#_using_resources_and_the_finally_block"></a>Using Resources and the Finally Block</h5>
<div class="paragraph">
<p>The last parallel to draw with imperative programming is the cleaning up that can be done
either by using a &#8220;Use of the <code>finally</code> block to clean up resources&#8221; or by using a
&#8220;Java 7 try-with-resource construct&#8221;, both shown below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. Imperative use of finally</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Stats stats = new Stats();
stats.startTimer();
try {
  doSomethingDangerous();
}
finally {
  stats.stopTimerAndRecordTiming();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 15. Imperative use of try-with-resource</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">try (SomeAutoCloseable disposableInstance = new SomeAutoCloseable()) {
  return disposableInstance.toString();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Both have their Reactor equivalents: <code>doFinally</code> and <code>using</code>.</p>
</div>
<div class="paragraph">
<p><code>doFinally</code> is about side-effects that you want to be executed whenever the
sequence terminates (with <code>onComplete</code> or <code>onError</code>) or is cancelled.
It gives you a hint as to what kind of termination triggered the side-effect.
The following example shows how to use <code>doFinally</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Reactive finally: <code>doFinally()</code></div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Stats stats = new Stats();
LongAdder statsCancel = new LongAdder();

Flux&lt;String&gt; flux =
Flux.just("foo", "bar")
    .doOnSubscribe(s -&gt; stats.startTimer())
    .doFinally(type -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
        stats.stopTimerAndRecordTiming();<i class="conum" data-value="2"></i><b>(2)</b>
        if (type == SignalType.CANCEL) <i class="conum" data-value="3"></i><b>(3)</b>
          statsCancel.increment();
    })
    .take(1); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>doFinally</code> consumes a <code>SignalType</code> for the type of termination.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Similarly to <code>finally</code> blocks, we always record the timing.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here we also increment statistics in case of cancellation only.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>take(1)</code> requests exactly 1 from upstream, and cancels after one item is emitted.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>On the other hand, <code>using</code> handles the case where a <code>Flux</code> is derived from a
resource and that resource must be acted upon whenever processing is done.
In the following example, we replace the <code>AutoCloseable</code> interface of &#8220;try-with-resource&#8221; with a
<code>Disposable</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. The Disposable resource</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">AtomicBoolean isDisposed = new AtomicBoolean();
Disposable disposableInstance = new Disposable() {
    @Override
    public void dispose() {
        isDisposed.set(true); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Override
    public String toString() {
        return "DISPOSABLE";
    }
};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now we can do the reactive equivalent of &#8220;try-with-resource&#8221; on it, which looks
like the following:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. Reactive try-with-resource: <code>using()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; flux =
Flux.using(
        () -&gt; disposableInstance, <i class="conum" data-value="1"></i><b>(1)</b>
        disposable -&gt; Flux.just(disposable.toString()), <i class="conum" data-value="2"></i><b>(2)</b>
        Disposable::dispose <i class="conum" data-value="3"></i><b>(3)</b>
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The first lambda generates the resource. Here, we return our mock <code>Disposable</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The second lambda processes the resource, returning a <code>Flux&lt;T&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The third lambda is called when the <code>Flux</code> from &lt;2&gt; terminates or is cancelled, to
clean up resources.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>After subscription and execution of the sequence, the <code>isDisposed</code> atomic boolean
becomes <code>true</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_demonstrating_the_terminal_aspect_of_onerror"><a class="anchor" href="#_demonstrating_the_terminal_aspect_of_onerror"></a>Demonstrating the Terminal Aspect of <code>onError</code></h5>
<div class="paragraph">
<p>In order to demonstrate that all these operators cause the upstream original sequence to
terminate when an error happens, we can use a more visual example with a
<code>Flux.interval</code>. The <code>interval</code> operator ticks every x units of time with an increasing
<code>Long</code> value. The following example uses an <code>interval</code> operator:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; flux =
Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .onErrorReturn("Uh oh");

flux.subscribe(System.out::println);
Thread.sleep(2100); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note that <code>interval</code> executes on a <strong>timer</strong> <code>Scheduler</code> by default. If we want
to run that example in a main class, we would need to add a <code>sleep</code> call here so that the
application does not exit immediately without any value being produced.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example prints out one line every 250ms, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">tick 0
tick 1
tick 2
Uh oh</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Even with one extra second of runtime, no more tick comes in from the <code>interval</code>. The
sequence was indeed terminated by the error.</p>
</div>
</div>
<div class="sect4">
<h5 id="_retrying"><a class="anchor" href="#_retrying"></a>Retrying</h5>
<div class="paragraph">
<p>There is another operator of interest with regards to error handling, and you might be
tempted to use it in the case described in the previous section. <code>retry</code>, as its name
indicates, lets you retry an error-producing sequence.</p>
</div>
<div class="paragraph">
<p>The thing to keep in mind is that it works by <strong>re-subscribing</strong> to the upstream <code>Flux</code>.
This is really a different sequence, and the original one is still terminated.
To verify that, we can re-use the previous example and append a <code>retry(1)</code> to
retry once instead of using <code>onErrorReturn</code>. The following example shows how to do sl:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .retry(1)
    .elapsed() <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(System.out::println, System.err::println); <i class="conum" data-value="2"></i><b>(2)</b>

Thread.sleep(2100); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>elapsed</code> associates each value with the duration since previous value was emitted.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We also want to see when there is an <code>onError</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ensure we have enough time for our 4x2 ticks.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">259,tick 0
249,tick 1
251,tick 2
506,tick 0 <i class="conum" data-value="1"></i><b>(1)</b>
248,tick 1
253,tick 2
java.lang.RuntimeException: boom</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A new <code>interval</code> started, from tick 0. The additional 250ms duration is
coming from the 4th tick, the one that causes the exception and subsequent
retry.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see from the preceding example, <code>retry(1)</code> merely re-subscribed to the original <code>interval</code>
once, restarting the tick from 0. The second time around, since the exception
still occurs, it gives up and propagates the error downstream.</p>
</div>
<div class="paragraph">
<p>There is a more advanced version of <code>retry</code> (called <code>retryWhen</code>) that uses a &#8220;companion&#8221;
<code>Flux</code> to tell whether or not a particular failure should retry. This companion <code>Flux</code> is
created by the operator but decorated by the user, in order to customize the retry
condition.</p>
</div>
<div class="paragraph">
<p>The companion <code>Flux</code> is a <code>Flux&lt;RetrySignal&gt;</code> that gets passed to a <code>Retry</code> strategy/function,
supplied as the sole parameter of <code>retryWhen</code>. As the user, you define that function and make it return a new
<code>Publisher&lt;?&gt;</code>. The <code>Retry</code> class is an abstract class, but it offers a factory method if you
want to transform the companion with a simple lambda (<code>Retry.from(Function)</code>).</p>
</div>
<div class="paragraph">
<p>Retry cycles go as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Each time an error happens (giving potential for a retry), a <code>RetrySignal</code> is emitted into the
companion <code>Flux</code>, which has been decorated by your function. Having a <code>Flux</code> here
gives a bird eye&#8217;s view of all the attempts so far. The <code>RetrySignal</code> gives access to the error
as well as metadata around it.</p>
</li>
<li>
<p>If the companion <code>Flux</code> emits a value, a retry happens.</p>
</li>
<li>
<p>If the companion <code>Flux</code> completes, the error is swallowed, the retry cycle stops,
and the resulting sequence completes, too.</p>
</li>
<li>
<p>If the companion <code>Flux</code> produces an error (<code>e</code>), the retry cycle stops and the
resulting sequence errors with <code>e</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The distinction between the previous two cases is important. Simply completing the
companion would effectively swallow an error. Consider the following way of emulating
<code>retry(3)</code> by using <code>retryWhen</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; flux = Flux
    .&lt;String&gt;error(new IllegalArgumentException()) <i class="conum" data-value="1"></i><b>(1)</b>
    .doOnError(System.out::println) <i class="conum" data-value="2"></i><b>(2)</b>
    .retryWhen(Retry.from(companion -&gt; <i class="conum" data-value="3"></i><b>(3)</b>
        companion.take(3))); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This continuously produces errors, calling for retry attempts.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>doOnError</code> before the retry lets us log and see all failures.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>Retry</code> is adapted from a very simple <code>Function</code> lambda</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Here, we consider the first three errors as retry-able (<code>take(3)</code>) and then give up.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In effect, the preceding example results in an empty <code>Flux</code>, but it completes successfully. Since
<code>retry(3)</code> on the same <code>Flux</code> would have terminated with the latest error, this
<code>retryWhen</code> example is not exactly the same as a <code>retry(3)</code>.</p>
</div>
<div class="paragraph">
<p>Getting to the same behavior involves a few additional tricks:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
		Flux.&lt;String&gt;error(new IllegalArgumentException())
				.doOnError(e -&gt; errorCount.incrementAndGet())
				.retryWhen(Retry.from(companion -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
						companion.map(rs -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
							if (rs.totalRetries() &lt; 3) return rs.totalRetries(); <i class="conum" data-value="3"></i><b>(3)</b>
							else throw Exceptions.propagate(rs.failure()); <i class="conum" data-value="4"></i><b>(4)</b>
						})
				));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We customize <code>Retry</code> by adapting from a <code>Function</code> lambda rather than providing a concrete class</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The companion emits <code>RetrySignal</code> objects, which bear number of retries so far and last failure</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>To allow for three retries, we consider indexes &lt; 3 and return a value to emit (here we simply return the index).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In order to terminate the sequence in error, we throw the original exception after
these three retries.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
One can use the builders exposed in <code>Retry</code> to achieve the same in a more fluent manner, as
well as more finely tuned retry strategies. For example: <code>errorFlux.retryWhen(Retry.max(3));</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can use similar code to implement an &#8220;exponential backoff and retry&#8221; pattern,
as shown in the <a href="#faq.exponentialBackoff">FAQ</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The core-provided <code>Retry</code> helpers, <code>RetrySpec</code> and <code>RetryBackoffSpec</code>, both allow advanced customizations like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>setting the <code>filter(Predicate)</code> for the exceptions that can trigger a retry</p>
</li>
<li>
<p>modifying such a previously set filter through <code>modifyErrorFilter(Function)</code></p>
</li>
<li>
<p>triggering a side effect like logging around the retry trigger (ie for backoff before and after the delay), provided the retry is validated (<code>doBeforeRetry()</code> and <code>doAfterRetry()</code> are additive)</p>
</li>
<li>
<p>triggering an asynchronous <code>Mono&lt;Void&gt;</code> around the retry trigger, which allows to add asynchronous behavior on top of the base delay but thus further delay the trigger (<code>doBeforeRetryAsync</code> and <code>doAfterRetryAsync</code> are additive)</p>
</li>
<li>
<p>customizing the exception in case the maximum number of attempts has been reached, through <code>onRetryExhaustedThrow(BiFunction)</code>.
By default, <code>Exceptions.retryExhausted(&#8230;&#8203;)</code> is used, which can be distinguished with <code>Exceptions.isRetryExhausted(Throwable)</code></p>
</li>
<li>
<p>activating the handling of <em>transient errors</em> (see below)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Transient error handling in the <code>Retry</code> specs makes use of <code>RetrySignal#totalRetriesInARow()</code>: to check whether to retry or not and to compute the retry delays, the index used is an alternative one that is reset to 0 each time an <code>onNext</code> is emitted.
This has the consequence that if a re-subscribed source generates some data before failing again, previous failures don&#8217;t count toward the maximum number of retry attempts.
In the case of exponential backoff strategy, this also means that the next attempt will be back to using the minimum <code>Duration</code> backoff instead of a longer one.
This can be especially useful for long-lived sources that see sporadic bursts of errors (or <em>transient</em> errors), where each burst should be retried with its own backoff.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">AtomicInteger errorCount = new AtomicInteger(); <i class="conum" data-value="1"></i><b>(1)</b>
AtomicInteger transientHelper = new AtomicInteger();
Flux&lt;Integer&gt; transientFlux = Flux.&lt;Integer&gt;generate(sink -&gt; {
	int i = transientHelper.getAndIncrement();
	if (i == 10) { <i class="conum" data-value="2"></i><b>(2)</b>
		sink.next(i);
		sink.complete();
	}
	else if (i % 3 == 0) { <i class="conum" data-value="3"></i><b>(3)</b>
		sink.next(i);
	}
	else {
		sink.error(new IllegalStateException("Transient error at " + i)); <i class="conum" data-value="4"></i><b>(4)</b>
	}
})
		.doOnError(e -&gt; errorCount.incrementAndGet());

transientFlux.retryWhen(Retry.max(2).transientErrors(true))  <i class="conum" data-value="5"></i><b>(5)</b>
             .blockLast();
assertThat(errorCount).hasValue(6); <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We will count the number of errors in the retried sequence.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We <code>generate</code> a source that has bursts of errors. It will successfully complete when the counter reaches 10.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the <code>transientHelper</code> atomic is at a multiple of <code>3</code>, we emit <code>onNext</code> and thus end the current burst.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In other cases we emit an <code>onError</code>. That&#8217;s 2 out of 3 times, so bursts of 2 <code>onError</code> interrupted by 1 <code>onNext</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>We use <code>retryWhen</code> on that source, configured for at most 2 retry attempts, but in <code>transientErrors</code> mode.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>At the end, the sequence reaches <code>onNext(10)</code> and completes, after <code>6</code> errors have been registered in <code>errorCount</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Without the <code>transientErrors(true)</code>, the configured maximum attempt of <code>2</code> would be reached by the second burst and the sequence would fail after having emitted <code>onNext(3)</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handling_exceptions_in_operators_or_functions"><a class="anchor" href="#_handling_exceptions_in_operators_or_functions"></a>4.6.2. Handling Exceptions in Operators or Functions</h4>
<div class="paragraph">
<p>In general, all operators can themselves contain code that potentially trigger an
exception or calls to a user-defined callback that can similarly fail, so they all
contain some form of error handling.</p>
</div>
<div class="paragraph">
<p>As a rule of thumb, an unchecked exception is always propagated through <code>onError</code>. For
instance, throwing a <code>RuntimeException</code> inside a <code>map</code> function translates to an
<code>onError</code> event, as the following code shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.just("foo")
    .map(s -&gt; { throw new IllegalArgumentException(s); })
    .subscribe(v -&gt; System.out.println("GOT VALUE"),
               e -&gt; System.out.println("ERROR: " + e));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code prints out the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">ERROR: java.lang.IllegalArgumentException: foo</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can tune the <code>Exception</code> before it is passed to <code>onError</code>, through the use of a
<a href="#hooks-internal">hook</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactor, however, defines a set of exceptions (such as <code>OutOfMemoryError</code>) that are
always deemed to be fatal. See the <code>Exceptions.throwIfFatal</code> method. These errors mean that
Reactor cannot keep operating and are thrown rather than propagated.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Internally, there are also cases where an unchecked exception still cannot be
propagated (most notably during the subscribe and request phases), due to concurrency
races that could lead to double <code>onError</code> or <code>onComplete</code> conditions. When these races
happen, the error that cannot be propagated is &#8220;dropped&#8221;. These cases can still be
managed to some extent by using customizable hooks. See <a href="#hooks-dropping">Dropping Hooks</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You may ask: &#8220;What about checked exceptions?&#8221;</p>
</div>
<div class="paragraph">
<p>If, for example, you need to call some method that declares it <code>throws</code> exceptions, you
still have to deal with those exceptions in a <code>try-catch</code> block. You have several
options, though:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Catch the exception and recover from it. The sequence continues normally.</p>
</li>
<li>
<p>Catch the exception, wrap it into an <em>unchecked</em> exception, and then throw it
(interrupting the sequence). The <code>Exceptions</code> utility class can help you with that (we
get to that next).</p>
</li>
<li>
<p>If you need to return a <code>Flux</code> (for example, you are in a <code>flatMap</code>), wrap the
exception in an error-producing <code>Flux</code>, as follows: <code>return Flux.error(checkedException)</code>. (The
sequence also terminates.)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Reactor has an <code>Exceptions</code> utility class that you can use to ensure that exceptions are
wrapped only if they are checked exceptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <code>Exceptions.propagate</code> method to wrap exceptions, if necessary. It also calls
<code>throwIfFatal</code> first and does not wrap <code>RuntimeException</code>.</p>
</li>
<li>
<p>Use the <code>Exceptions.unwrap</code> method to get the original unwrapped exception (going back
to the root cause of a hierarchy of reactor-specific exceptions).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following example of a <code>map</code> that uses a conversion method that can throw an
<code>IOException</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public String convert(int i) throws IOException {
    if (i &gt; 3) {
        throw new IOException("boom " + i);
    }
    return "OK " + i;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now imagine that you want to use that method in a <code>map</code>. You must now explicitly catch
the exception, and your map function cannot re-throw it. So you can propagate it to the
map&#8217;s <code>onError</code> method as a <code>RuntimeException</code>, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; converted = Flux
    .range(1, 10)
    .map(i -&gt; {
        try { return convert(i); }
        catch (IOException e) { throw Exceptions.propagate(e); }
    });</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Later on, when subscribing to the preceding <code>Flux</code> and reacting to errors (such as in the
UI), you could revert back to the original exception if you want to do something
special for IOExceptions. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">converted.subscribe(
    v -&gt; System.out.println("RECEIVED: " + v),
    e -&gt; {
        if (Exceptions.unwrap(e) instanceof IOException) {
            System.out.println("Something bad happened with I/O");
        } else {
            System.out.println("Something bad happened");
        }
    }
);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sinks"><a class="anchor" href="#sinks"></a>4.7. Sinks</h3>
<div class="paragraph">
<p>In Reactor a sink is a class that allows safe manual triggering of signals in a standalone fashion, creating a <code>Publisher</code>-like structure capable of dealing with multiple <code>Subscriber</code> (with the exception of <code>unicast()</code> flavors).</p>
</div>
<div class="paragraph">
<p>Before <code>3.5.0</code>, there was also a set of <code>Processor</code> implementations which has been phased out.</p>
</div>
<div class="sect3">
<h4 id="sinks-intro"><a class="anchor" href="#sinks-intro"></a>4.7.1. Safely Produce from Multiple Threads by Using <code>Sinks.One</code> and <code>Sinks.Many</code></h4>
<div class="paragraph">
<p>Default flavors of <code>Sinks</code> exposed by reactor-core ensure that multi-threaded usage is detected
and cannot lead to spec violations or undefined behavior from the perspective of downstream
subscribers. When using the <code>tryEmit*</code> API, parallel calls fail fast. When using the <code>emit*</code>
API, the provided <code>EmissionFailureHandler</code> may allow to retry on contention (eg. busy looping),
otherwise the sink will terminate with an error.</p>
</div>
<div class="paragraph">
<p>This is an improvement over <code>Processor.onNext</code>, which must be synchronized externally or
lead to undefined behavior from the perspective of the downstream subscribers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Processors are a special kind of <code>Publisher</code> that are also a <code>Subscriber</code>.
They were originally intended as a possible representation of an intermediate step that
could then be shared between Reactive Streams implementations.
In Reactor however, such steps are rather represented by operators that are <code>Publisher</code>.</p>
</div>
<div class="paragraph">
<p>A common mistake when coming across a <code>Processor</code> for the first time is the temptation to
directly call the exposed <code>onNext</code>, <code>onComplete</code> and <code>onError</code> methods from the <code>Subscriber</code> interface.</p>
</div>
<div class="paragraph">
<p>Such manual calls should be made with care, especially regarding external synchronization
of calls with respect to the Reactive Streams specification.
Processors are actually probably marginally useful, unless one comes across a Reactive Streams
based API that requires a <code>Subscriber</code> to be passed, rather than exposing a <code>Publisher</code>.</p>
</div>
<div class="paragraph">
<p>Sinks are usually a better alternative.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>Sinks</code> builder provide a guided API to the main supported producer types.
You will recognize some of the behavior found in <code>Flux</code> such as <code>onBackpressureBuffer</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Sinks.Many&lt;Integer&gt; replaySink = Sinks.many().replay().all();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Multiple producer threads may concurrently generate data on the sink by doing the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">//thread1
replaySink.emitNext(1, FAIL_FAST);

//thread2, later
replaySink.emitNext(2, FAIL_FAST);

//thread3, concurrently with thread 2
EmitResult result = replaySink.tryEmitNext(3); //would return FAIL_NON_SERIALIZED</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>Sinks.Many</code> can be presented to downstream consumers as a <code>Flux</code>, like in the below example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; fluxView = replaySink.asFlux();
fluxView
	.takeWhile(i -&gt; i &lt; 10)
	.log()
	.blockLast();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly, the <code>Sinks.Empty</code> and <code>Sinks.One</code> flavors can be viewed as a <code>Mono</code> with the <code>asMono()</code> method.</p>
</div>
<div class="paragraph">
<p>The <code>Sinks</code> categories are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>many().multicast()</code>: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in "after the subscriber&#8217;s subscription").</p>
</li>
<li>
<p><code>many().unicast()</code>: same as above, with the twist that data pushed before the first subscriber registers is buffered.</p>
</li>
<li>
<p><code>many().replay()</code>: a sink that will replay a specified history size of pushed data to new subscribers then continue pushing new data live.</p>
</li>
<li>
<p><code>one()</code>: a sink that will play a single element to its subscribers</p>
</li>
<li>
<p><code>empty()</code>: a sink that will play a terminal signal only to its subscribers (error or complete), but can still be viewed as a <code>Mono&lt;T&gt;</code> (notice the generic type <code>&lt;T&gt;</code>).</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="sinks-overview"><a class="anchor" href="#sinks-overview"></a>4.7.2. Overview of Available Sinks</h4>
<div class="sect4">
<h5 id="_sinks_many_unicast_onbackpressurebufferargs"><a class="anchor" href="#_sinks_many_unicast_onbackpressurebufferargs"></a>Sinks.many().unicast().onBackpressureBuffer(args?)</h5>
<div class="paragraph">
<p>A unicast <code>Sinks.Many</code> can deal with backpressure by using an internal buffer.
The trade-off is that it can have <em>at most one</em> <code>Subscriber</code>.</p>
</div>
<div class="paragraph">
<p>The basic unicast sink is created via <code>Sinks.many().unicast().onBackpressureBuffer()</code>.
But there are a few additional <code>unicast</code> static factory methods in <code>Sinks.many().unicast()</code> allowing finer tuning.</p>
</div>
<div class="paragraph">
<p>For instance, by default, it is unbounded: if you push any amount of data through it while
its <code>Subscriber</code> has not yet requested data, it buffers all of the data.
You can change this by providing a custom <code>Queue</code> implementation for the internal
buffering in the <code>Sinks.many().unicast().onBackpressureBuffer(Queue)</code> factory method.
If that queue is bounded, the sink could reject the push of a value when the buffer
is full and not enough requests from downstream have been received.</p>
</div>
</div>
<div class="sect4">
<h5 id="_sinks_many_multicast_onbackpressurebufferargs"><a class="anchor" href="#_sinks_many_multicast_onbackpressurebufferargs"></a>Sinks.many().multicast().onBackpressureBuffer(args?)</h5>
<div class="paragraph">
<p>A multicast <code>Sinks.Many</code> can emit to several subscribers while honoring backpressure for each of its subscribers.
Subscribers receive only the signals pushed through the sink after they have subscribed.</p>
</div>
<div class="paragraph">
<p>The basic multicast sink is created via <code>Sinks.many().multicast().onBackpressureBuffer()</code>.</p>
</div>
<div class="paragraph">
<p>By default, if all of its subscribers are cancelled (which basically means they have all
un-subscribed), it clears its internal buffer and stops accepting new subscribers.
You can tune this by using the <code>autoCancel</code> parameter in the <code>multicast</code> static factory methods
under <code>Sinks.many().multicast()</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_sinks_many_multicast_directallornothing"><a class="anchor" href="#_sinks_many_multicast_directallornothing"></a>Sinks.many().multicast().directAllOrNothing()</h5>
<div class="paragraph">
<p>A multicast <code>Sinks.Many</code> with a simplistic handling of backpressure: if <strong>any</strong> of the subscribers
is too slow (has zero demand), the <code>onNext</code> is dropped for <strong>all</strong> subscribers.</p>
</div>
<div class="paragraph">
<p>However, the slow subscribers are not terminated and once the slow subscribers have started
requesting again, all will resume receiving elements pushed from there on.</p>
</div>
<div class="paragraph">
<p>Once the <code>Sinks.Many</code> has terminated (usually through its <code>emitError(Throwable)</code> or
<code>emitComplete()</code> methods being called), it lets more subscribers subscribe but replays the
termination signal to them immediately.</p>
</div>
</div>
<div class="sect4">
<h5 id="_sinks_many_multicast_directbesteffort"><a class="anchor" href="#_sinks_many_multicast_directbesteffort"></a>Sinks.many().multicast().directBestEffort()</h5>
<div class="paragraph">
<p>A multicast <code>Sinks.Many</code> with a best effort handling of backpressure: if a subscriber
is too slow (has zero demand), the <code>onNext</code> is dropped for <strong>this slow subscriber only</strong>.</p>
</div>
<div class="paragraph">
<p>However, the slow subscribers are not terminated and once they have started requesting again
they will resume receiving newly pushed elements.</p>
</div>
<div class="paragraph">
<p>Once the <code>Sinks.Many</code> has terminated (usually through its <code>emitError(Throwable)</code> or
<code>emitComplete()</code> methods being called), it lets more subscribers subscribe but replays the
termination signal to them immediately.</p>
</div>
</div>
<div class="sect4">
<h5 id="_sinks_many_replay"><a class="anchor" href="#_sinks_many_replay"></a>Sinks.many().replay()</h5>
<div class="paragraph">
<p>A replay <code>Sinks.Many</code> caches emitted elements and replays them to late subscribers.</p>
</div>
<div class="paragraph">
<p>It can be created in multiple configurations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Caching a limited history (<code>Sinks.many().replay().limit(int)</code>) or an unbounded history (<code>Sinks.many().replay().all()</code>).</p>
</li>
<li>
<p>Caching a time-based replay window (<code>Sinks.many().replay().limit(Duration)</code>).</p>
</li>
<li>
<p>Caching a combination of history size and time window (<code>Sinks.many().replay().limit(int, Duration)</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additional overloads for fine tuning of the above can also be found under <code>Sinks.many().replay()</code>, as well
as a variant that allows caching of a single element (<code>latest()</code> and <code>latestOrDefault(T)</code>).</p>
</div>
</div>
<div class="sect4">
<h5 id="_sinks_unsafe_many"><a class="anchor" href="#_sinks_unsafe_many"></a>Sinks.unsafe().many()</h5>
<div class="paragraph">
<p>Advanced users and operators builders might want to consider using <code>Sinks.unsafe().many()</code>
which will provide the same <code>Sinks.Many</code> factories <em>without</em> the extra producer thread safety.
As a result there will be less overhead per sink, since thread-safe sinks have to detect multi-threaded access.</p>
</div>
<div class="paragraph">
<p>Library developers should not expose unsafe sinks but can use them internally in a controlled
calling environment where they can ensure external synchronization of the calls that lead to
<code>onNext</code>, <code>onComplete</code> and <code>onError</code> signals, in respect of the Reactive Streams specification.</p>
</div>
</div>
<div class="sect4">
<h5 id="_sinks_one"><a class="anchor" href="#_sinks_one"></a>Sinks.one()</h5>
<div class="paragraph">
<p>This method directly construct a simple instance of <code>Sinks.One&lt;T&gt;</code>.
This flavor of <code>Sinks</code> is viewable as a <code>Mono</code> (through its <code>asMono()</code> view method), and
has slightly different <code>emit</code> methods to better convey this Mono-like semantics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>emitValue(T value)</code> generates an <code>onNext(value)</code> signal and - in most implementations - will also trigger an implicit <code>onComplete()</code></p>
</li>
<li>
<p><code>emitEmpty()</code> generates an isolated <code>onComplete()</code> signal, intended as generating the equivalent of an empty <code>Mono</code></p>
</li>
<li>
<p><code>emitError(Throwable t)</code> generates an <code>onError(t)</code> signal</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Sinks.one()</code> accepts <em>one</em> call of any of these methods, effectively generating a <code>Mono</code>
that either completed with a value, completed empty or failed.</p>
</div>
</div>
<div class="sect4">
<h5 id="_sinks_empty"><a class="anchor" href="#_sinks_empty"></a>Sinks.empty()</h5>
<div class="paragraph">
<p>This method directly constructs a simple instance of <code>Sinks.Empty&lt;T&gt;</code>.
This flavor of <code>Sinks</code> is like <code>Sinks.One&lt;T&gt;</code>, except it doesn&#8217;t offer the <code>emitValue</code> method.</p>
</div>
<div class="paragraph">
<p>As a result, it can only generates a <code>Mono</code> that completes empty or fails.</p>
</div>
<div class="paragraph">
<p>The sink is still typed with a generic <code>&lt;T&gt;</code> despite being unable to trigger an <code>onNext</code>,
because it allows easy composition and inclusion in chains of operators that require a specific type.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/coreFeatures.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#core-features">Reactor Core Features</a>"</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kotlin"><a class="anchor" href="#kotlin"></a>5. Kotlin support</h2>
<div class="sectionbody">
<div id="kotlin-introduction" class="paragraph">
<p><a href="https://kotlinlang.org">Kotlin</a> is a statically-typed language targeting the JVM (and other platforms),
which allows writing concise and elegant code while providing very good
<a href="https://kotlinlang.org/docs/reference/java-interop.html">interoperability</a> with
existing libraries written in Java.</p>
</div>
<div class="paragraph">
<p>This section describes Reactor&#8217;s support for Kotlin.</p>
</div>
<div class="sect2">
<h3 id="kotlin-requirements"><a class="anchor" href="#kotlin-requirements"></a>5.1. Requirements</h3>
<div class="paragraph">
<p>Reactor supports Kotlin 1.1+ and requires
<a href="https://search.maven.org/artifact/org.jetbrains.kotlin/kotlin-stdlib"><code>kotlin-stdlib</code></a>
(or one of its <a href="https://search.maven.org/artifact/org.jetbrains.kotlin/kotlin-stdlib-jdk7"><code>kotlin-stdlib-jdk7</code></a>
or <a href="https://search.maven.org/artifact/org.jetbrains.kotlin/kotlin-stdlib-jdk8"><code>kotlin-stdlib-jdk8</code></a> variants).</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-extensions"><a class="anchor" href="#kotlin-extensions"></a>5.2. Extensions</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of <code>Dysprosium-M1</code> (ie. <code>reactor-core 3.3.0.M1</code>), Kotlin extensions are moved to a
dedicated <a href="https://github.com/reactor/reactor-kotlin-extensions"><code>reactor-kotlin-extensions</code></a>
module with new package names that start with <code>reactor.kotlin</code> instead of simply <code>reactor</code>.</p>
</div>
<div class="paragraph">
<p>As a consequence, Kotlin extensions in <code>reactor-core</code> module are deprecated.
The new dependency&#8217;s groupId and artifactId are:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="gradle" class="language-gradle hljs">io.projectreactor.kotlin:reactor-kotlin-extensions</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Thanks to its great <a href="https://kotlinlang.org/docs/reference/java-interop.html">Java interoperability</a>
and to <a href="https://kotlinlang.org/docs/reference/extensions.html">Kotlin extensions</a>, Reactor
Kotlin APIs leverage regular Java APIs and are additionally enhanced by a few Kotlin-specific APIs
that are available out of the box within Reactor artifacts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Keep in mind that Kotlin extensions need to be imported to be used. This means
for example that the <code>Throwable.toFlux</code> Kotlin extension
is available only if <code>import reactor.kotlin.core.publisher.toFlux</code> is imported.
That said, similar to static imports, an IDE should automatically suggest the import in most cases.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, <a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">Kotlin reified type parameters</a>
provide a workaround for JVM <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">generics type erasure</a>,
and Reactor provides some extensions to take advantage of this feature.</p>
</div>
<div class="paragraph">
<p>The following table compares Reactor with Java against Reactor with Kotlin and extensions:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Java</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Kotlin with extensions</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.just("foo")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"foo".toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.fromIterable(list)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>list.toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType(Foo.class)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType&lt;Foo&gt;()</code> or <code>flux.ofType(Foo::class)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StepVerifier.create(flux).verifyComplete()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.test().verifyComplete()</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <a href="https://projectreactor.io/docs/kotlin/release/kdoc-api/">Reactor KDoc API</a> lists and documents
all the available Kotlin extensions.</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-null-safety"><a class="anchor" href="#kotlin-null-safety"></a>5.3. Null Safety</h3>
<div class="paragraph">
<p>One of Kotlin&#8217;s key features is <a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a>,
which cleanly deals with <code>null</code> values at compile time rather than bumping into the famous
<code>NullPointerException</code> at runtime. This makes applications safer through nullability
declarations and expressive &#8220;value or no value&#8221; semantics without paying the cost of wrappers such as <code>Optional</code>.
(Kotlin allows using functional constructs with nullable values. See this
<a href="https://www.baeldung.com/kotlin-null-safety">comprehensive guide to Kotlin null-safety</a>.)</p>
</div>
<div class="paragraph">
<p>Although Java does not let one express null safety in its type-system, Reactor <a href="#null-safety">now
provides null safety</a> of the whole Reactor API through tooling-friendly annotations declared
in the <code>reactor.util.annotation</code> package.
By default, types from Java APIs used in Kotlin are recognized as
<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">platform types</a>
for which null-checks are relaxed.
<a href="https://github.com/Kotlin/KEEP/blob/jsr-305/proposals/jsr-305-custom-nullability-qualifiers.md">Kotlin support for JSR 305 annotations</a>
and Reactor nullability annotations provide null-safety for the whole Reactor API to Kotlin developers,
with the advantage of dealing with <code>null</code>-related issues at compile time.</p>
</div>
<div class="paragraph">
<p>You can configure the JSR 305 checks by adding the <code>-Xjsr305</code> compiler flag with the following
options: <code>-Xjsr305={strict|warn|ignore}</code>.</p>
</div>
<div class="paragraph">
<p>For kotlin versions 1.1.50+, the default behavior is the same as <code>-Xjsr305=warn</code>.
The <code>strict</code> value is required to have the Reactor API full null-safety taken into account
but should be considered experimental, since the Reactor API nullability declaration could evolve
even between minor releases, as more checks may be added in the future).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Nullability for generic type arguments, variable arguments, and array elements is not supported yet,
but itshould be in an upcoming release. See <a href="https://github.com/Kotlin/KEEP/issues/79">this dicussion</a>
for up-to-date information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/kotlin.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#kotlin">Kotlin support</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing"><a class="anchor" href="#testing"></a>6. Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Whether you have written a simple chain of Reactor operators or your own operator,
automated testing is always a good idea.</p>
</div>
<div class="paragraph">
<p>Reactor comes with a few elements dedicated to testing, gathered into their own
artifact: <code>reactor-test</code>. You can find that project
<a href="https://github.com/reactor/reactor-core/tree/main/reactor-test/src">on Github</a>,
inside of the <code>reactor-core</code> repository.</p>
</div>
<div class="paragraph">
<p>To use it in your tests, you must add it as a test dependency.
The following example shows how to add <code>reactor-test</code> as a dependency in Maven:</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. reactor-test in Maven, in <code>&lt;dependencies&gt;</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If you use the <a href="#getting">BOM</a>, you do not need to specify a <code>&lt;version&gt;</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to add <code>reactor-test</code> as a dependency in Gradle:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. reactor-test in Gradle, amend the <code>dependencies</code> block</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">dependencies {
   testCompile 'io.projectreactor:reactor-test'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The three main uses of <code>reactor-test</code> are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Testing that a sequence follows a given scenario, step-by-step, with <code>StepVerifier</code>.</p>
</li>
<li>
<p>Producing data in order to test the behavior of downstream operators (including you own
operators) with <code>TestPublisher</code>.</p>
</li>
<li>
<p>In sequences that can go through several alternative <code>Publisher</code> (for example, a chain that uses
<code>switchIfEmpty</code>, probing such a <code>Publisher</code> to ensure it was used (that is, subscribed to).</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_testing_a_scenario_with_stepverifier"><a class="anchor" href="#_testing_a_scenario_with_stepverifier"></a>6.1. Testing a Scenario with <code>StepVerifier</code></h3>
<div class="paragraph">
<p>The most common case for testing a Reactor sequence is to have a <code>Flux</code> or a <code>Mono</code> defined
in your code (for example, it might be returned by a method) and to want to test how it
behaves when subscribed to.</p>
</div>
<div class="paragraph">
<p>This situation translates well to defining a &#8220;test scenario,&#8221; where you define your
expectations in terms of events, step-by-step. You can ask and answer questions such as
the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>What is the next expected event?</p>
</li>
<li>
<p>Do you expect the <code>Flux</code> to emit a particular value?</p>
</li>
<li>
<p>Or maybe to do nothing for the next 300ms?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can express all of that through the <code>StepVerifier</code> API.</p>
</div>
<div class="paragraph">
<p>For instance, you could have the following utility method in your codebase that
decorates a <code>Flux</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public &lt;T&gt; Flux&lt;T&gt; appendBoomError(Flux&lt;T&gt; source) {
  return source.concatWith(Mono.error(new IllegalArgumentException("boom")));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In order to test it, you want to verify the following scenario:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>I expect this <code>Flux</code> to first emit <code>thing1</code>, then emit <code>thing2</code>, and then <strong>produce an
error</strong> with the message, <code>boom</code>. Subscribe and <strong>verify</strong> these expectations.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In the <code>StepVerifier</code> API, this translates to the following test:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
public void testAppendBoomError() {
  Flux&lt;String&gt; source = Flux.just("thing1", "thing2"); <i class="conum" data-value="1"></i><b>(1)</b>

  StepVerifier.create( <i class="conum" data-value="2"></i><b>(2)</b>
    appendBoomError(source)) <i class="conum" data-value="3"></i><b>(3)</b>
    .expectNext("thing1") <i class="conum" data-value="4"></i><b>(4)</b>
    .expectNext("thing2")
    .expectErrorMessage("boom") <i class="conum" data-value="5"></i><b>(5)</b>
    .verify(); <i class="conum" data-value="6"></i><b>(6)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Since our method needs a source <code>Flux</code>, define a simple one for testing purposes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create a <code>StepVerifier</code> builder that wraps and verifies a <code>Flux</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Pass the <code>Flux</code> to be tested (the result of calling our utility method).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The first signal we expect to happen upon subscription is an <code>onNext</code>, with a value
of <code>thing1</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The last signal we expect to happen is a termination of the sequence with an
<code>onError</code>. The exception should have <code>boom</code> as a message.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>It is important to trigger the test by calling <code>verify()</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The API is a builder. You start by creating a <code>StepVerifier</code> and passing the
sequence to be tested. This offers a choice of methods that let you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Express expectations about the next signals to occur. If any other signal is received
(or the content of the signal does not match the expectation), the whole test fails with
a meaningful <code>AssertionError</code>. For example, you might use <code>expectNext(T&#8230;&#8203;)</code> and
<code>expectNextCount(long)</code>.</p>
</li>
<li>
<p>Consume the next signal. This is used when you want to skip part of the sequence or
when you want to apply a custom <code>assertion</code> on the content of the signal (for example, to
check that there is an <code>onNext</code> event and assert that the emitted item is a list of size
5). For example, you might use <code>consumeNextWith(Consumer&lt;T&gt;)</code>.</p>
</li>
<li>
<p>Take miscellaneous actions such as pausing or running arbitrary code. For example, if
you want to manipulate a test-specific state or context. To that effect, you might use
<code>thenAwait(Duration)</code> and <code>then(Runnable)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For terminal events, the corresponding expectation methods (<code>expectComplete()</code> and
<code>expectError()</code> and all their variants) switch to an API where you cannot express
expectations anymore. In that last step, all you can do is perform some additional
configuration on the <code>StepVerifier</code> and then trigger the verification, often
with <code>verify()</code> or one of its variants.</p>
</div>
<div class="paragraph">
<p>What happens at this point is that the <code>StepVerifier</code> subscribes to the tested <code>Flux</code> or
<code>Mono</code> and plays the sequence, comparing each new signal with the next step in the
scenario. As long as these match, the test is considered a success. As soon as there is a
discrepancy, an <code>AssertionError</code> is thrown.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Remember the <code>verify()</code> step, which triggers the verification. To
help, the API includes a few shortcut methods that combine the terminal expectations with
a call to <code>verify()</code>: <code>verifyComplete()</code>, <code>verifyError()</code>, <code>verifyErrorMessage(String)</code>,
and others.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that, if one of the lambda-based expectations throws an <code>AssertionError</code>, it is
reported as is, failing the test. This is useful for custom assertions.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
By default, the <code>verify()</code> method and derived shortcut methods (<code>verifyThenAssertThat</code>,
<code>verifyComplete()</code>, and so on) have no timeout. They can block indefinitely. You can use
<code>StepVerifier.setDefaultTimeout(Duration)</code> to globally set a timeout for these methods,
or specify one on a per-call basis with <code>verify(Duration)</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_better_identifying_test_failures"><a class="anchor" href="#_better_identifying_test_failures"></a>6.1.1. Better Identifying Test Failures</h4>
<div class="paragraph">
<p><code>StepVerifier</code> provides two options to better identify exactly which expectation step caused
a test to fail:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>as(String)</code>: Used after most <code>expect*</code> methods to give a description
to the preceding expectation. If the expectation fails, its error message contains the
description. Terminal expectations and <code>verify</code> cannot be described that way.</p>
</li>
<li>
<p><code>StepVerifierOptions.create().scenarioName(String)</code>: By using <code>StepVerifierOptions</code> to create
your <code>StepVerifier</code>, you can use the <code>scenarioName</code> method to give the whole scenario a
name, which is also used in assertion error messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that, in both cases, the use of the description or name in messages is only guaranteed for
<code>StepVerifier</code> methods that produce their own <code>AssertionError</code> (for example, throwing an exception
manually or through an assertion library in <code>assertNext</code> does not add the description or name to
the error&#8217;s message).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_manipulating_time"><a class="anchor" href="#_manipulating_time"></a>6.2. Manipulating Time</h3>
<div class="paragraph">
<p>You can use <code>StepVerifier</code> with time-based operators to avoid long run times for
corresponding tests. You can do so through the <code>StepVerifier.withVirtualTime</code> builder.</p>
</div>
<div class="paragraph">
<p>It looks like the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
//... continue expectations here</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This virtual time feature plugs in a custom <code>Scheduler</code> in Reactor&#8217;s <code>Schedulers</code>
factory. Since these timed operators usually use the default <code>Schedulers.parallel()</code>
scheduler, replacing it with a <code>VirtualTimeScheduler</code> does the trick. However, an
important prerequisite is that the operator be instantiated after the virtual time
scheduler has been activated.</p>
</div>
<div class="paragraph">
<p>To increase the chances that this happens correctly, the <code>StepVerifier</code> does not take
a simple <code>Flux</code> as input. <code>withVirtualTime</code> takes a <code>Supplier</code>, which guides you into lazily
creating the instance of the tested flux <em>after</em> having done the scheduler set up.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Take extra care to ensure the <code>Supplier&lt;Publisher&lt;T&gt;&gt;</code> can be used in a lazy
fashion. Otherwise, virtual time is not guaranteed. Especially avoid instantiating the
<code>Flux</code> earlier in the test code and having the <code>Supplier</code> return that variable. Instead,
always instantiate the <code>Flux</code> inside the lambda.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two expectation methods that deal with time, and they are both valid with or
without virtual time:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thenAwait(Duration)</code>: Pauses the evaluation of steps (allowing a few signals to occur
or delays to run out).</p>
</li>
<li>
<p><code>expectNoEvent(Duration)</code>: Also lets the sequence play out for a given duration but
fails the test if <em>any</em> signal occurs during that time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both methods pause the thread for the given duration in classic mode and advance the
virtual clock instead in virtual mode.</p>
</div>
<div id="tip-expectNoEvent" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>expectNoEvent</code> also considers the <code>subscription</code> as an event. If you use it as a
first step, it usually fails because the subscription signal is detected. Use
<code>expectSubscription().expectNoEvent(duration)</code> instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to quickly evaluate the behavior of our <code>Mono.delay</code> above, we can finish
writing our code as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
    .expectSubscription() <i class="conum" data-value="1"></i><b>(1)</b>
    .expectNoEvent(Duration.ofDays(1)) <i class="conum" data-value="2"></i><b>(2)</b>
    .expectNext(0L) <i class="conum" data-value="3"></i><b>(3)</b>
    .verifyComplete(); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>See the preceding <a href="#tip-expectNoEvent">tip</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Expect nothing to happen for a full day.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then expect a delay that emits <code>0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Then expect completion (and trigger the verification).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>We could have used <code>thenAwait(Duration.ofDays(1))</code> above, but <code>expectNoEvent</code> has the
benefit of guaranteeing that nothing happened earlier than it should have.</p>
</div>
<div class="paragraph">
<p>Note that <code>verify()</code> returns a <code>Duration</code> value. This is the real-time duration of the
entire test.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Virtual time is not a silver bullet. All <code>Schedulers</code> are
replaced with the same <code>VirtualTimeScheduler</code>. In some cases, you can lock the
verification process because the virtual clock has not moved forward before an
expectation is expressed, resulting in the expectation waiting on data that can only be
produced by advancing time. In most cases, you need to advance the virtual clock for
sequences to emit. Virtual time also gets very limited with infinite sequences, which
might hog the thread on which both the sequence and its verification run.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_performing_post_execution_assertions_with_stepverifier"><a class="anchor" href="#_performing_post_execution_assertions_with_stepverifier"></a>6.3. Performing Post-execution Assertions with <code>StepVerifier</code></h3>
<div class="paragraph">
<p>After having described the final expectation of your scenario, you can switch to a
complementary assertion API instead of triggering <code>verify()</code>. To do so, use
<code>verifyThenAssertThat()</code> instead.</p>
</div>
<div class="paragraph">
<p><code>verifyThenAssertThat()</code> returns a <code>StepVerifier.Assertions</code> object, which you can use to
assert a few elements of state once the whole scenario has played out successfully
(because it also calls <code>verify()</code>). Typical (albeit advanced) usage is to capture
elements that have been dropped by some operator and assert them (see the section on
<a href="#hooks">Hooks</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_testing_the_context"><a class="anchor" href="#_testing_the_context"></a>6.4. Testing the <code>Context</code></h3>
<div class="paragraph">
<p>For more information about the <code>Context</code>, see <a href="#context">Adding a Context to a Reactive Sequence</a>.</p>
</div>
<div class="paragraph">
<p><code>StepVerifier</code> comes with a couple of expectations around the propagation of a <code>Context</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectAccessibleContext</code>: Returns a <code>ContextExpectations</code> object that you can use
to set up expectations on the propagated <code>Context</code>. Be sure to call <code>then()</code> to return
to the set of sequence expectations.</p>
</li>
<li>
<p><code>expectNoAccessibleContext</code>: Sets up an expectation that NO <code>Context</code> can be propagated
up the chain of operators under test. This most likely occurs when the <code>Publisher</code> under
test is not a Reactor one or does not have any operator that can propagate the <code>Context</code>
(for example, a generator source).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, you can associate a test-specific initial <code>Context</code> to a <code>StepVerifier</code> by
using <code>StepVerifierOptions</code> to create the verifier.</p>
</div>
<div class="paragraph">
<p>These features are demonstrated in the following snippet:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">StepVerifier.create(Mono.just(1).map(i -&gt; i + 10),
				StepVerifierOptions.create().withInitialContext(Context.of("thing1", "thing2"))) <i class="conum" data-value="1"></i><b>(1)</b>
		            .expectAccessibleContext() <i class="conum" data-value="2"></i><b>(2)</b>
		            .contains("thing1", "thing2") <i class="conum" data-value="3"></i><b>(3)</b>
		            .then() <i class="conum" data-value="4"></i><b>(4)</b>
		            .expectNext(11)
		            .verifyComplete(); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create the <code>StepVerifier</code> by using <code>StepVerifierOptions</code> and pass in an initial <code>Context</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Start setting up expectations about <code>Context</code> propagation. This alone ensures that a
<code>Context</code> was propagated.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>An example of a <code>Context</code>-specific expectation. It must contain value "thing2" for key "thing1".</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We <code>then()</code> switch back to setting up normal expectations on the data.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Let us not forget to <code>verify()</code> the whole set of expectations.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_manually_emitting_with_testpublisher"><a class="anchor" href="#_manually_emitting_with_testpublisher"></a>6.5. Manually Emitting with <code>TestPublisher</code></h3>
<div class="paragraph">
<p>For more advanced test cases, it might be useful to have complete mastery over the source
of data, to trigger finely chosen signals that closely match the particular
situation you want to test.</p>
</div>
<div class="paragraph">
<p>Another situation is when you have implemented your own operator and you want to verify
how it behaves with regards to the Reactive Streams specification, especially if its
source is not well behaved.</p>
</div>
<div class="paragraph">
<p>For both cases, <code>reactor-test</code> offers the <code>TestPublisher</code> class. This is a <code>Publisher&lt;T&gt;</code>
that lets you programmatically trigger various signals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>next(T)</code> and <code>next(T, T&#8230;&#8203;)</code> triggers 1-n <code>onNext</code> signals.</p>
</li>
<li>
<p><code>emit(T&#8230;&#8203;)</code> triggers 1-n <code>onNext</code> signals and does <code>complete()</code>.</p>
</li>
<li>
<p><code>complete()</code> terminates with an <code>onComplete</code> signal.</p>
</li>
<li>
<p><code>error(Throwable)</code> terminates with an <code>onError</code> signal.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can get a well behaved <code>TestPublisher</code> through the <code>create</code> factory method. Also,
you can create a misbehaving <code>TestPublisher</code> by using the <code>createNonCompliant</code> factory
method. The latter takes a value or multiple values from the <code>TestPublisher.Violation</code>
enum. The values define which parts of the specification the publisher can overlook.
These enum values include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>REQUEST_OVERFLOW</code>: Allows <code>next</code> calls to be made despite an insufficient request,
without triggering an <code>IllegalStateException</code>.</p>
</li>
<li>
<p><code>ALLOW_NULL</code>: Allows <code>next</code> calls to be made with a <code>null</code> value without triggering a
<code>NullPointerException</code>.</p>
</li>
<li>
<p><code>CLEANUP_ON_TERMINATE</code>: Allows termination signals to be sent several times in a row.
This includes <code>complete()</code>, <code>error()</code>, and <code>emit()</code>.</p>
</li>
<li>
<p><code>DEFER_CANCELLATION</code>: Allows the <code>TestPublisher</code> to ignore cancellation signals and continue
emitting signals as if the cancellation lost the race against said signals.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, the <code>TestPublisher</code> keeps track of internal state after subscription, which can
be asserted through its various <code>assert*</code> methods.</p>
</div>
<div class="paragraph">
<p>You can use it as a <code>Flux</code> or <code>Mono</code> by using the conversion methods, <code>flux()</code> and
<code>mono()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_checking_the_execution_path_with_publisherprobe"><a class="anchor" href="#_checking_the_execution_path_with_publisherprobe"></a>6.6. Checking the Execution Path with <code>PublisherProbe</code></h3>
<div class="paragraph">
<p>When building complex chains of operators, you could come across cases where
there are several possible execution paths, materialized by distinct sub-sequences.</p>
</div>
<div class="paragraph">
<p>Most of the time, these sub-sequences produce a specific-enough <code>onNext</code> signal
that you can assert that it was executed by looking at the end result.</p>
</div>
<div class="paragraph">
<p>For instance, consider the following method, which builds a chain of operators from a
source and uses a <code>switchIfEmpty</code> to fall back to a particular alternative if the source
is empty:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public Flux&lt;String&gt; processOrFallback(Mono&lt;String&gt; source, Publisher&lt;String&gt; fallback) {
    return source
            .flatMapMany(phrase -&gt; Flux.fromArray(phrase.split("\\s+")))
            .switchIfEmpty(fallback);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can test which logical branch of the switchIfEmpty was used, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
public void testSplitPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.just("just a  phrase with    tabs!"),
            Mono.just("EMPTY_PHRASE")))
                .expectNext("just", "a", "phrase", "with", "tabs!")
                .verifyComplete();
}

@Test
public void testEmptyPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.empty(), Mono.just("EMPTY_PHRASE")))
                .expectNext("EMPTY_PHRASE")
                .verifyComplete();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>However, think about an example where the method produces a <code>Mono&lt;Void&gt;</code> instead. It waits
for the source to complete, performs an additional task, and completes. If the source
is empty, a fallback <code>Runnable</code>-like task must be performed instead. The following example
shows such a case:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">private Mono&lt;String&gt; executeCommand(String command) {
    return Mono.just(command + " DONE");
}

public Mono&lt;Void&gt; processOrFallback(Mono&lt;String&gt; commandSource, Mono&lt;Void&gt; doWhenEmpty) {
    return commandSource
            .flatMap(command -&gt; executeCommand(command).then()) <i class="conum" data-value="1"></i><b>(1)</b>
            .switchIfEmpty(doWhenEmpty); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>then()</code> forgets about the command result. It cares only that it was completed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>How to distinguish between two cases that are both empty sequences?</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>To verify that your <code>processOrFallback</code> method does indeed go through the <code>doWhenEmpty</code> path,
you need to write a bit of boilerplate. Namely you need a <code>Mono&lt;Void&gt;</code> that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Captures the fact that it has been subscribed to.</p>
</li>
<li>
<p>Lets you assert that fact <em>after</em> the whole process has terminated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before version 3.1, you would need to manually maintain one <code>AtomicBoolean</code> per state you
wanted to assert and attach a corresponding <code>doOn*</code> callback to the publisher you wanted
to evaluate. This could be a lot of boilerplate when having to apply this pattern
regularly. Fortunately, 3.1.0 introduced an alternative with <code>PublisherProbe</code>. The
following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
public void testCommandEmptyPathIsUsed() {
    PublisherProbe&lt;Void&gt; probe = PublisherProbe.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

    StepVerifier.create(processOrFallback(Mono.empty(), probe.mono())) <i class="conum" data-value="2"></i><b>(2)</b>
                .verifyComplete();

    probe.assertWasSubscribed(); <i class="conum" data-value="3"></i><b>(3)</b>
    probe.assertWasRequested(); <i class="conum" data-value="4"></i><b>(4)</b>
    probe.assertWasNotCancelled(); <i class="conum" data-value="5"></i><b>(5)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a probe that translates to an empty sequence.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use the probe in place of <code>Mono&lt;Void&gt;</code> by calling <code>probe.mono()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>After completion of the sequence, the probe lets you assert that it was used. You
can check that is was subscribed to&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>&#8230;&#8203;as well as actually requested data&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>&#8230;&#8203;and whether or not it was cancelled.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use the probe in place of a <code>Flux&lt;T&gt;</code> by calling <code>.flux()</code> instead of
<code>.mono()</code>. For cases where you need to probe an execution path but also need the
probe to emit data, you can wrap any <code>Publisher&lt;T&gt;</code> by using <code>PublisherProbe.of(Publisher)</code>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/testing.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#testing">Testing</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging"><a class="anchor" href="#debugging"></a>7. Debugging Reactor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Switching from an imperative and synchronous programming paradigm to a reactive and
asynchronous one can sometimes be daunting. One of the steepest steps in the learning
curve is how to analyze and debug when something goes wrong.</p>
</div>
<div class="paragraph">
<p>In the imperative world, debugging is usually pretty straightforward. You can read the
stacktrace and see where the problem originated. Was it entirely a failure
of your code? Did the failure occur in some library code? If so, what part of your code
called the library, potentially passing in improper parameters that ultimately caused the
failure?</p>
</div>
<div class="sect2">
<h3 id="_the_typical_reactor_stack_trace"><a class="anchor" href="#_the_typical_reactor_stack_trace"></a>7.1. The Typical Reactor Stack Trace</h3>
<div class="paragraph">
<p>When you shift to asynchronous code, things can get much more complicated.</p>
</div>
<div class="paragraph">
<p>Consider the following stack trace:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. A typical Reactor stack trace</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">java.lang.IndexOutOfBoundsException: Source emitted more than one item
    at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:129)
    at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmitScalar(FluxFlatMap.java:445)
    at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:379)
    at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)
    at reactor.core.publisher.FluxRange$RangeSubscription.slowPath(FluxRange.java:154)
    at reactor.core.publisher.FluxRange$RangeSubscription.request(FluxRange.java:109)
    at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)
    at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:332)
    at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)
    at reactor.core.publisher.FluxRange.subscribe(FluxRange.java:68)
    at reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63)
    at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97)
    at reactor.core.publisher.MonoSingle.subscribe(MonoSingle.java:58)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3096)
    at reactor.core.publisher.Mono.subscribeWith(Mono.java:3204)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3090)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3057)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3029)
    at reactor.guide.GuideTests.debuggingCommonStacktrace(GuideTests.java:995)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There is a lot going on there. We get an <code>IndexOutOfBoundsException</code>, which tells us that
a <code>source emitted more than one item</code>.</p>
</div>
<div class="paragraph">
<p>We can probably quickly come to assume that this source is a Flux or a Mono, as confirmed by
the next line, which mentions <code>MonoSingle</code>. So it appears to be some sort of complaint
from a <code>single</code> operator.</p>
</div>
<div class="paragraph">
<p>Referring to the Javadoc for the <code>Mono#single</code> operator, we see that <code>single</code> has a contract:
The source must emit exactly one element. It appears we had a source that emitted more
than one and thus violated that contract.</p>
</div>
<div class="paragraph">
<p>Can we dig deeper and identify that source? The following rows are not very helpful. They
take us through the internals of what seems to be a reactive chain, through
multiple calls to <code>subscribe</code> and <code>request</code>.</p>
</div>
<div class="paragraph">
<p>By skimming over these rows, we can at least start to form a picture of the kind of chain
that went wrong: It seems to involve a <code>MonoSingle</code>, a <code>FluxFlatMap</code>, and a <code>FluxRange</code>
(each gets several rows in the trace, but overall these three classes are involved). So a
<code>range().flatMap().single()</code> chain maybe?</p>
</div>
<div class="paragraph">
<p>But what if we use that pattern a lot in our application? This still does not tell us
much, and simply searching for <code>single</code> is not going to find the problem. Then the last
line refers to some of our code. Finally, we are getting close.</p>
</div>
<div class="paragraph">
<p>Hold on, though. When we go to the source file, all we see is that a
pre-existing <code>Flux</code> is subscribed to, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">toDebug
    .subscribeOn(Schedulers.immediate())
    .subscribe(System.out::println, Throwable::printStackTrace);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>All of this happened at subscription time, but the <code>Flux</code> itself was not
declared there. Worse, when we go to where the variable is declared, we see the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public Mono&lt;String&gt; toDebug; //please overlook the public class attribute</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The variable is not instantiated where it is declared. We must assume a worst-case
scenario where we find out that there could be a few different code paths that set it in
the application. We remain unsure of which one caused the issue.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is kind of the Reactor equivalent of a runtime error, as opposed to a
compilation error.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What we want to find out more easily is where the operator was added into the chain -
that is,  where the <code>Flux</code> was declared. We usually refer to that as the &#8220;assembly&#8221; of
the <code>Flux</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="debug-activate"><a class="anchor" href="#debug-activate"></a>7.2. Activating Debug Mode - aka tracebacks</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
this section describes the easiest but also the slowest way to enable
the debugging capabilities due to the fact that it captures the stacktrace on every operator.
See <a href="#checkpoint-alternative">The <code>checkpoint()</code> Alternative</a> for a more fine grained way of debugging,
and <a href="#reactor-tools-debug">Production-ready Global Debugging</a> for a more advanced and performant global option.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Even though the stacktrace was still able to convey some information for someone with a
bit of experience, we can see that it is not ideal by itself in more advanced cases.</p>
</div>
<div class="paragraph">
<p>Fortunately, Reactor comes with  assembly-time instrumentation that is designed for debugging.</p>
</div>
<div class="paragraph">
<p>This is done by activating a global debug mode via the <code>Hooks.onOperatorDebug()</code> method at application start (or at
least before the incriminated <code>Flux</code> or <code>Mono</code> can be instantiated), as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Hooks.onOperatorDebug();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This starts instrumenting the calls to Reactor operator methods (where
they are assembled into the chain) by wrapping the construction of the operator and
capturing a stack trace there. Since this is done when the operator chain is declared, the
hook should be activated before that, so the safest way is to activate it right at the
start of your application.</p>
</div>
<div class="paragraph">
<p>Later on, if an exception occurs, the failing operator is able to refer to that capture
and to rework the stack trace, appending additional information.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
We call this captured assembly information (and additional information added to the
exceptions by Reactor in general) a <strong>traceback</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the next section, we see how the stack trace differs and how to interpret
that new information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reading_a_stack_trace_in_debug_mode"><a class="anchor" href="#_reading_a_stack_trace_in_debug_mode"></a>7.3. Reading a Stack Trace in Debug Mode</h3>
<div class="paragraph">
<p>When we reuse our initial example but activate the <code>operatorStacktrace</code> debug feature,
several things happen:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The stack trace, which points to subscription site and is thus less interesting, is cut after the first frame and set aside.</p>
</li>
<li>
<p>A special suppressed exception is added to the original exception (or amended if already there).</p>
</li>
<li>
<p>A message is constructed for that special exception with several sections.</p>
</li>
<li>
<p>First section will trace back to the assembly site of the operator that fails.</p>
</li>
<li>
<p>Second section will attempt to display the chain(s) that are built from this operator and have seen the error propagate</p>
</li>
<li>
<p>Last section is the original stack trace</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The full stack trace, once printed, is as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">java.lang.IndexOutOfBoundsException: Source emitted more than one item
    at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:127) <i class="conum" data-value="1"></i><b>(1)</b>
    Suppressed: The stacktrace has been enhanced by Reactor, refer to additional information below: <i class="conum" data-value="2"></i><b>(2)</b>
Assembly trace from producer [reactor.core.publisher.MonoSingle] : <i class="conum" data-value="3"></i><b>(3)</b>
    reactor.core.publisher.Flux.single(Flux.java:7915)
    reactor.guide.GuideTests.scatterAndGather(GuideTests.java:1017)
Error has been observed at the following site(s): <i class="conum" data-value="4"></i><b>(4)</b>
    *_______Flux.single â¢ at reactor.guide.GuideTests.scatterAndGather(GuideTests.java:1017) <i class="conum" data-value="5"></i><b>(5)</b>
    |_ Mono.subscribeOn â¢ at reactor.guide.GuideTests.debuggingActivated(GuideTests.java:1071) <i class="conum" data-value="6"></i><b>(6)</b>
Original Stack Trace: <i class="conum" data-value="7"></i><b>(7)</b>
        at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:127)
...
<i class="conum" data-value="8"></i><b>(8)</b>
...
        at reactor.core.publisher.Mono.subscribeWith(Mono.java:4363)
        at reactor.core.publisher.Mono.subscribe(Mono.java:4223)
        at reactor.core.publisher.Mono.subscribe(Mono.java:4159)
        at reactor.core.publisher.Mono.subscribe(Mono.java:4131)
        at reactor.guide.GuideTests.debuggingActivated(GuideTests.java:1067)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The original stack trace is truncated to a single frame.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is new: We see the wrapper operator that captures the stack.
This is where the traceback starts to appear.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>First, we get some details about where the operator was assembled.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Second, we get a notion of operator chain(s) through which the error propagated,
from first to last (error site to subscribe site).</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Each operator that saw the error is mentioned along with the user class and line where it
was used. Here we have a "root".</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Here we have a simple part of the chain.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The rest of the stack trace is moved at the end&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>&#8230;&#8203;showing a bit of the operator&#8217;s internals (so we removed a bit of the snippet here).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The captured stack trace is appended to the original error as a
suppressed <code>OnAssemblyException</code>. There are three parts to it, but the first section is the
most interesting. It shows the path of construction for the operator that triggered the
exception. Here, it shows that the <code>single</code> that caused our issue was actually created in the
<code>scatterAndGather</code> method.</p>
</div>
<div class="paragraph">
<p>Now that we are armed with enough information to find the culprit, we can have
a meaningful look at that <code>scatterAndGather</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">private Mono&lt;String&gt; scatterAndGather(Flux&lt;String&gt; urls) {
    return urls.flatMap(url -&gt; doRequest(url))
           .single(); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Sure enough, here is our <code>single</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Now we can see what the root cause of the error was a <code>flatMap</code> that performs
several HTTP calls to a few URLs but that is chained with <code>single</code>, which is too
restrictive. After a short <code>git blame</code> and a quick discussion with the author of
that line, we find out he meant to use the less restrictive <code>take(1)</code> instead.</p>
</div>
<div class="paragraph">
<p>We have solved our problem.</p>
</div>
<div class="paragraph">
<p>Now consider the following section in the stack trace:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Error has been observed at the following site(s):</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That second part of the traceback was not necessarily interesting in
this particular example, because the error was actually happening in the last
operator in the chain (the one closest to <code>subscribe</code>). Considering another
example might make it more clear:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">FakeRepository.findAllUserByName(Flux.just("pedro", "simon", "stephane"))
              .transform(FakeUtils1.applyFilters)
              .transform(FakeUtils2.enrichUser)
              .blockLast();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now imagine that, inside <code>findAllUserByName</code>, there is a <code>map</code> that fails. Here,
we would see the following in the second part of the traceback:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Error has been observed at the following site(s):
    *________Flux.map â¢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)
    |_       Flux.map â¢ at reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)
    |_    Flux.filter â¢ at reactor.guide.FakeUtils1.lambda$static$1(FakeUtils1.java:29)
    |_ Flux.transform â¢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:39)
    |_   Flux.elapsed â¢ at reactor.guide.FakeUtils2.lambda$static$0(FakeUtils2.java:30)
    |_ Flux.transform â¢ at reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:40)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This corresponds to the section of the chain(s) of operators that gets notified of the error:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The exception originates in the first <code>map</code>. This one is identified as a root by the <code>*</code> connector and the fact <code>_</code>
are used for indentation.</p>
</li>
<li>
<p>The exception is seen by a second <code>map</code> (both in fact correspond to the <code>findAllUserByName</code>
method).</p>
</li>
<li>
<p>It is then seen by a <code>filter</code> and a <code>transform</code>, which indicate that part of the chain
is constructed by a reusable transformation function (here, the <code>applyFilters</code> utility
method).</p>
</li>
<li>
<p>Finally, it is seen by an <code>elapsed</code> and a <code>transform</code>. Once again, <code>elapsed</code> is applied
by the transformation function of that second transform.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In some cases where the same exception is propagated through multiple chains, the "root" marker <code>*_</code>
allows us to better separate such chains.
If a site is seen several time, there will be an <code>(observed x times)</code> after the call site information.</p>
</div>
<div class="paragraph">
<p>For instance, let us consider the following snippet:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MyClass {
    public void myMethod() {
        Flux&lt;String&gt; source = Flux.error(sharedError);
        Flux&lt;String&gt; chain1 = source.map(String::toLowerCase).filter(s -&gt; s.length() &lt; 4);
        Flux&lt;String&gt; chain2 = source.filter(s -&gt; s.length() &gt; 5).distinct();

        Mono&lt;Void&gt; when = Mono.when(chain1, chain2);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the code above, error propagates to the <code>when</code>, going through two separate chains <code>chain1</code> and <code>chain2</code>.
It would lead to a traceback containing the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Error has been observed at the following site(s):
    *_____Flux.error â¢ at myClass.myMethod(MyClass.java:3) (observed 2 times)
    |_      Flux.map â¢ at myClass.myMethod(MyClass.java:4)
    |_   Flux.filter â¢ at myClass.myMethod(MyClass.java:4)
    *_____Flux.error â¢ at myClass.myMethod(MyClass.java:3) (observed 2 times)
    |_   Flux.filter â¢ at myClass.myMethod(MyClass.java:5)
    |_ Flux.distinct â¢ at myClass.myMethod(MyClass.java:5)
    *______Mono.when â¢ at myClass.myMethod(MyClass.java:7)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We see that:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>there are 3 "root" elements (the <code>when</code> is the true root).</p>
</li>
<li>
<p>two chains starting from <code>Flux.error</code> are visible.</p>
</li>
<li>
<p>both chains seem to be based on the same <code>Flux.error</code> source (<code>observed 2 times</code>).</p>
</li>
<li>
<p>first chain is <code>Flux.error().map().filter</code></p>
</li>
<li>
<p>second chain is `Flux.error().filter().distinct()</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<strong>A note on tracebacks and suppressed exceptions</strong>:
As tracebacks are appended to original errors as suppressed exceptions, this can somewhat
interfere with another type of exception that uses this mechanism: composite exceptions.
Such exceptions can be created directly via <code>Exceptions.multiple(Throwable&#8230;&#8203;)</code>, or by some
operators that might join multiple erroring sources (like <code>Flux#flatMapDelayError</code>). They
can be unwrapped into a <code>List</code> via <code>Exceptions.unwrapMultiple(Throwable)</code>, in which case the traceback
would be considered a component of the composite and be part of the returned <code>List</code>.
If that is somehow not desirable, tracebacks can be identified thanks to <code>Exceptions.isTraceback(Throwable)</code>
check, and excluded from such an unwrap by using <code>Exceptions.unwrapMultipleExcludingTracebacks(Throwable)</code>
instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We deal with a form of instrumentation here, and creating a stack trace is costly. That
is why this debugging feature should only be activated in a controlled manner, as a last
resort.</p>
</div>
<div class="sect3">
<h4 id="checkpoint-alternative"><a class="anchor" href="#checkpoint-alternative"></a>7.3.1. The <code>checkpoint()</code> Alternative</h4>
<div class="paragraph">
<p>The debug mode is global and affects every single operator assembled into a <code>Flux</code> or a
<code>Mono</code> inside the application. This has the benefit of allowing after-the-fact
debugging: Whatever the error, we can obtain additional information to debug it.</p>
</div>
<div class="paragraph">
<p>As we saw earlier, this global knowledge comes at the cost of an impact on performance
(due to the number of populated stack traces). That cost can be reduced if we have an
idea of likely problematic operators. However, we usually do not know which operators are
likely to be problematic unless we observed an error in the wild, saw we were missing
assembly information, and then modified the code to activate assembly tracking, hoping to
observe the same error again.</p>
</div>
<div class="paragraph">
<p>In that scenario, we have to switch into debugging mode and make preparations in order to
better observe a second occurrence of the error, this time capturing all the additional
information.</p>
</div>
<div class="paragraph">
<p>If you can identify reactive chains that you assemble in your application for which
serviceability is critical, you can achieve a mix of both techniques with the
<code>checkpoint()</code> operator.</p>
</div>
<div class="paragraph">
<p>You can chain this operator into a method chain. The <code>checkpoint</code> operator works like the
hook version but only for its link of that particular chain.</p>
</div>
<div class="paragraph">
<p>There is also a <code>checkpoint(String)</code> variant that lets you add a unique <code>String</code> identifier
to the assembly traceback. This way, the stack trace is omitted and you rely on the
description to identify the assembly site. <code>checkpoint(String)</code> imposes less processing
cost than a regular <code>checkpoint</code>.</p>
</div>
<div class="paragraph">
<p>Last but not least, if you want to add a more generic description to the checkpoint but
still rely on the stack trace mechanism to identify the assembly site, you can force that
behavior by using the <code>checkpoint("description", true)</code> version. We are now back to the
initial message for the traceback, augmented with a <code>description</code>, as shown in the
following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] : <i class="conum" data-value="1"></i><b>(1)</b>
	reactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:215)
	reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)
Error has been observed at the following site(s):
	|_	ParallelFlux.checkpoint â¢ reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>descriptionCorrelation1234</code> is the description provided in the <code>checkpoint</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The description could be a static identifier or user-readable description or a wider
correlation ID (for instance, coming from a header in the case of an HTTP request).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When global debugging is enabled in conjunction with checkpoints, the global debugging
traceback style is applied and checkpoints are only reflected in the
"Error has been observed&#8230;&#8203;" section.
As a result, the name of heavy checkpoints is not visible in this case.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor-tools-debug"><a class="anchor" href="#reactor-tools-debug"></a>7.4. Production-ready Global Debugging</h3>
<div class="paragraph">
<p>Project Reactor comes with a separate Java Agent that instruments your code and adds
debugging info without paying the cost of capturing the stacktrace on every operator call.
The behaviour is very similar to <a href="#debug-activate">Activating Debug Mode - aka tracebacks</a>, but without the runtime performance overhead.</p>
</div>
<div class="paragraph">
<p>To use it in your app, you must add it as a dependency.</p>
</div>
<div class="paragraph">
<p>The following example shows how to add <code>reactor-tools</code> as a dependency in Maven:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. reactor-tools in Maven, in <code>&lt;dependencies&gt;</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-tools&lt;/artifactId&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If you use the <a href="#getting">BOM</a>, you do not need to specify a <code>&lt;version&gt;</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to add <code>reactor-tools</code> as a dependency in Gradle:</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. reactor-tools in Gradle, amend the <code>dependencies</code> block</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">dependencies {
   compile 'io.projectreactor:reactor-tools'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It also needs to be explicitly initialized with:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ReactorDebugAgent.init();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Since the implementation will instrument your classes when they are loaded,
the best place to put it is before everything else in your main(String[]) methood:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) {
    ReactorDebugAgent.init();
    SpringApplication.run(Application.class, args);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may also re-process existing classes if you cannot run the init eagerly (e.g. in the tests):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ReactorDebugAgent.init();
ReactorDebugAgent.processExistingClasses();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Be aware that the re-processing takes a couple of seconds due to the need to iterate over
all loaded classes and apply the transformation.
Use it only if you see that some call-sites are not instrumented.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_limitations"><a class="anchor" href="#_limitations"></a>7.4.1. Limitations</h4>
<div class="paragraph">
<p><code>ReactorDebugAgent</code> is implemented as a Java Agent and uses <a href="https://bytebuddy.net/#/">ByteBuddy</a>
to perform the self-attach.
Self-attach may not work on some JVMs, please refer to ByteBuddy&#8217;s documentation for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_running_reactordebugagent_as_a_java_agent"><a class="anchor" href="#_running_reactordebugagent_as_a_java_agent"></a>7.4.2. Running ReactorDebugAgent as a Java Agent</h4>
<div class="paragraph">
<p>If your environment does not support ByteBuddy&#8217;s self-attachment, you can run <code>reactor-tools</code> as a
Java Agent:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">java -javaagent reactor-tools.jar -jar app.jar</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_running_reactordebugagent_at_build_time"><a class="anchor" href="#_running_reactordebugagent_at_build_time"></a>7.4.3. Running ReactorDebugAgent at build time</h4>
<div class="paragraph">
<p>It is also possible to run <code>reactor-tools</code> at build time. To do so, you need to apply it as a
plugin for ByteBuddy&#8217;s build instrumentation.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The transformation will only be applied to your project&#8217;s classes. The classpath libraries will not be instrumented.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 23. reactor-tools with <a href="https://github.com/raphw/byte-buddy/tree/byte-buddy-1.10.9/byte-buddy-maven-plugin">ByteBuddy&#8217;s Maven plugin</a></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
		&lt;artifactId&gt;reactor-tools&lt;/artifactId&gt;
		<i class="conum" data-value="1"></i><b>(1)</b>
		&lt;classifier&gt;original&lt;/classifier&gt; <i class="conum" data-value="2"></i><b>(2)</b>
		&lt;scope&gt;runtime&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;
			&lt;artifactId&gt;byte-buddy-maven-plugin&lt;/artifactId&gt;
			&lt;configuration&gt;
				&lt;transformations&gt;
					&lt;transformation&gt;
						&lt;plugin&gt;reactor.tools.agent.ReactorDebugByteBuddyPlugin&lt;/plugin&gt;
					&lt;/transformation&gt;
				&lt;/transformations&gt;
			&lt;/configuration&gt;
		&lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If you use the <a href="#getting">BOM</a>, you do not need to specify a <code>&lt;version&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>classifier</code> here is important.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 24. reactor-tools with <a href="https://github.com/raphw/byte-buddy/tree/byte-buddy-1.10.9/byte-buddy-gradle-plugin">ByteBuddy&#8217;s Gradle plugin</a></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	id 'net.bytebuddy.byte-buddy-gradle-plugin' version '1.10.9'
}

configurations {
	byteBuddyPlugin
}

dependencies {
	byteBuddyPlugin(
			group: 'io.projectreactor',
			name: 'reactor-tools',
			<i class="conum" data-value="1"></i><b>(1)</b>
			classifier: 'original', <i class="conum" data-value="2"></i><b>(2)</b>
	)
}

byteBuddy {
	transformation {
		plugin = "reactor.tools.agent.ReactorDebugByteBuddyPlugin"
		classPath = configurations.byteBuddyPlugin
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If you use the <a href="#getting">BOM</a>, you do not need to specify a <code>version</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>classifier</code> here is important.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_logging_a_sequence"><a class="anchor" href="#_logging_a_sequence"></a>7.5. Logging a Sequence</h3>
<div class="paragraph">
<p>In addition to stack trace debugging and analysis, another powerful tool to have in your
toolkit is the ability to trace and log events in an asynchronous sequence.</p>
</div>
<div class="paragraph">
<p>The <code>log()</code> operator can do just that. Chained inside a sequence, it peeks at every
event of the <code>Flux</code> or <code>Mono</code> upstream of it (including <code>onNext</code>, <code>onError</code>, and
<code>onComplete</code> as well as subscriptions, cancellations, and requests).</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A note on logging implementation</div>
<div class="paragraph">
<p>The <code>log</code> operator uses the <code>Loggers</code> utility class, which picks up common logging
frameworks such as Log4J and Logback through <code>SLF4J</code> and defaults to logging to the
console if SLF4J is unavailable.</p>
</div>
<div class="paragraph">
<p>The console fallback uses <code>System.err</code> for the <code>WARN</code> and <code>ERROR</code> log levels and
<code>System.out</code> for everything else.</p>
</div>
<div class="paragraph">
<p>If you prefer a JDK <code>java.util.logging</code> fallback, as in 3.0.x, you can get it by setting
the <code>reactor.logging.fallback</code> system property to <code>JDK</code>.</p>
</div>
<div class="paragraph">
<p>In all cases, when logging in production <strong>you should take care to configure the
underlying logging framework to use its most asynchronous and non-blocking approach</strong>&#8201;&#8212;&#8201;for instance, an <code>AsyncAppender</code> in Logback or <code>AsyncLogger</code> in Log4j 2.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>For instance, suppose we have Logback activated and configured and a chain like
<code>range(1,10).take(3)</code>. By placing a <code>log()</code> before the <code>take</code>, we can get some
insight into how it works and what kind of events it propagates upstream to the range,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; flux = Flux.range(1, 10)
                         .log()
                         .take(3);
flux.subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This prints out the following (through the logger&#8217;s console appender):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>10:45:20.200 [main] INFO  reactor.Flux.Range.1 - | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription) <i class="conum" data-value="1"></i><b>(1)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | request(3) <i class="conum" data-value="2"></i><b>(2)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(1) <i class="conum" data-value="3"></i><b>(3)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(2)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(3)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | cancel() <i class="conum" data-value="4"></i><b>(4)</b></pre>
</div>
</div>
<div class="paragraph">
<p>Here, in addition to the logger&#8217;s own formatter (time, thread, level, message), the
<code>log()</code> operator outputs a few things in its own format:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>reactor.Flux.Range.1</code> is an automatic category for the log, in case you use the
operator several times in a chain. It lets you distinguish which operator&#8217;s events
are logged (in this case, the <code>range</code>). You can overwrite the identifier with your own
custom category by using the <code>log(String)</code> method signature. After a few separating
characters, the actual event gets printed. Here, we get an <code>onSubscribe</code> call, a
<code>request</code> call, three <code>onNext</code> calls, and a <code>cancel</code> call. For the first line,
<code>onSubscribe</code>, we get the implementation of the <code>Subscriber</code>, which usually corresponds
to the operator-specific implementation. Between square brackets, we get additional
information, including whether the operator can be automatically optimized through
synchronous or asynchronous fusion.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>On the second line, we can see that take limited the request to upstream to 3.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then the range sends three values in a row.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>On the last line, we see <code>cancel()</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The second (2) and last lines (4) are the most interesting. We can see the <code>take</code> in action there.
It leverages backpressure in order to ask the source for exactly the expected amount of elements.
After having received enough elements, it tells the source no more items will be needed by calling <code>cancel()</code>.
Note that if downstream had itself used backpressure, eg. by requesting only 1 element,
the <code>take</code> operator would have honored that (it <em>caps</em> the request when propagating it from downstream
to upstream).</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/debugging.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#debugging">Debugging Reactor</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="metrics"><a class="anchor" href="#metrics"></a>8. Exposing Reactor metrics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Project Reactor is a library designed for performance and better utilization of resources.
But to truly understand the performance of a system, it is best to be able to monitor its various components.</p>
</div>
<div class="paragraph">
<p>This is why Reactor provides a built-in integration with <a href="https://micrometer.io">Micrometer</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If Micrometer is not on the classpath, metrics will be a no-op.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_scheduler_metrics"><a class="anchor" href="#_scheduler_metrics"></a>8.1. Scheduler metrics</h3>
<div class="paragraph">
<p>Every async operation in Reactor is done via the Scheduler abstraction described in <a href="#schedulers">Threading and Schedulers</a>.
This is why it is important to monitor your schedulers, watch out for key metrics that start to look suspicious and react accordingly.</p>
</div>
<div class="paragraph">
<p>To enable scheduler metrics, you will need to use the following method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Schedulers.enableMetrics();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The instrumentation is performed when a scheduler is created. It is recommended to call this method as early as possible.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you&#8217;re using Spring Boot, it is a good idea to place the invocation before <code>SpringApplication.run(Application.class, args)</code> call.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once scheduler metrics are enabled and provided it is on the classpath, Reactor will use Micrometer&#8217;s support for instrumenting the executors that back most schedulers.</p>
</div>
<div class="paragraph">
<p>Please refer to <a href="https://micrometer.io/docs/ref/jvm">Micrometer&#8217;s documentation</a> for the exposed metrics, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>executor_active_threads</p>
</li>
<li>
<p>executor_completed_tasks_total</p>
</li>
<li>
<p>executor_pool_size_threads</p>
</li>
<li>
<p>executor_queued_tasks</p>
</li>
<li>
<p>executor_secounds_{count, max, sum}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since one scheduler may have multiple executors, every executor metric has a <code>reactor_scheduler_id</code> tag.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Grafana + Prometheus users can use <a href="https://raw.githubusercontent.com/reactor/reactor-monitoring-demo/master/dashboards/schedulers.json">a pre-built dashboard</a> which includes panels for threads, completed tasks, task queues and other handy metrics.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_publisher_metrics"><a class="anchor" href="#_publisher_metrics"></a>8.2. Publisher metrics</h3>
<div class="paragraph">
<p>Sometimes it is useful to be able to record metrics at some stage in your reactive pipeline.</p>
</div>
<div class="paragraph">
<p>One way to do it would be to manually push the values to your metrics backend of choice.
Another option would be to use Reactor&#8217;s built-in metrics integration for <code>Flux</code>/<code>Mono</code> and interpret them.</p>
</div>
<div class="paragraph">
<p>Consider the following pipeline:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">listenToEvents()
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To enable the metrics for this source <code>Flux</code> (returned from <code>listenToEvents()</code>), we need to turn on the metrics collecting:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">listenToEvents()
    .name("events") <i class="conum" data-value="1"></i><b>(1)</b>
    .metrics() <i class="conum" data-value="2"></i><b>(2)</b>
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Every metric at this stage will be identified as "events" (optional).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Flux#metrics</code> operator enables the reporting of metrics, using the name provided in when calling <code>Flux#name</code> operator. In case <code>Flux#name</code> operator has not been used, the default name will be <code>reactor</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Just adding these two operators will expose a whole bunch of useful metrics!</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">metric name</th>
<th class="tableblock halign-left valign-top">type</th>
<th class="tableblock halign-left valign-top">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].subscribed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counts how many Reactor sequences have been subscribed to</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].malformed.source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counts the number of events received from a malformed source (ie an onNext after an onComplete)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].requested</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DistributionSummary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counts the amount requested to a named Flux by all subscribers, until at least one requests an unbounded amount</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].onNext.delay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Measures delays between onNext signals (or between onSubscribe and first onNext)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].flow.duration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Times the duration elapsed between a subscription and the termination or cancellation of the sequence. A status tag is added to specify what event caused the timer to end (<code>completed</code>, <code>completedEmpty</code>, <code>error</code>, <code>cancelled</code>).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Want to know how many times your event processing has restarted due to some error? Read <code>[name].subscribed</code>, because <code>retry()</code> operator will re-subscribe to the source publisher on error.</p>
</div>
<div class="paragraph">
<p>Interested in "events per second" metric? Measure the rate of <code>[name].onNext.delay</code> 's count.</p>
</div>
<div class="paragraph">
<p>Want to be alerted when the listener throws an error? <code>[name].flow.duration</code> with <code>status=error</code> tag is your friend.
Similarly, <code>status=completed</code> and <code>status=completedEmpty</code> will allow you to distinguish sequences that completed with elements from sequences that completed empty.</p>
</div>
<div class="paragraph">
<p>Please note that when giving a name to a sequence, this sequence could not be aggregated with others anymore. As a compromise if you want to identify your sequence but still make it possible to aggregate with other views, you can use a <a href="#_tags">Tags</a> for the name by calling <code>(tag("flow", "events"))</code> for example.</p>
</div>
<div class="sect3">
<h4 id="_tags"><a class="anchor" href="#_tags"></a>8.2.1. Tags</h4>
<div class="paragraph">
<p>Every metric will have a <code>type</code> tag in common, which value will be either <code>Flux</code> or <code>Mono</code> depending on the publisher&#8217;s nature.</p>
</div>
<div class="paragraph">
<p>Users are allowed to add custom tags to their reactive chains:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">listenToEvents()
    .name("events") <i class="conum" data-value="1"></i><b>(1)</b>
    .tag("source", "kafka") <i class="conum" data-value="2"></i><b>(2)</b>
    .metrics() <i class="conum" data-value="3"></i><b>(3)</b>
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Every metric at this stage will be identified as "events".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Set a custom tag "source" to value "kafka".</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>All reported metrics will have <code>source=kafka</code> tag assigned in addition to the common tag described above.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Please note that depending on the monitoring system you&#8217;re using, using a name can be considered mandatory when using tags, since it would otherwise result in a different set of tags between two default-named sequences.
Some systems like Prometheus might also require to have the exact same set of tags for each metric with the same name.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/metrics.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#metrics">Exposing Reactor metrics</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced"><a class="anchor" href="#advanced"></a>9. Advanced Features and Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers advanced features and concepts of Reactor, including the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#advanced-mutualizing-operator-usage">Mutualizing Operator Usage</a></p>
</li>
<li>
<p><a href="#reactor.hotCold">Hot Versus Cold</a></p>
</li>
<li>
<p><a href="#advanced-broadcast-multiple-subscribers-connectableflux">Broadcasting to Multiple Subscribers with <code>ConnectableFlux</code></a></p>
</li>
<li>
<p><a href="#advanced-three-sorts-batching">Three Sorts of Batching</a></p>
</li>
<li>
<p><a href="#advanced-parallelizing-parralelflux">Parallelizing Work with <code>ParallelFlux</code></a></p>
</li>
<li>
<p><a href="#scheduler-factory">Replacing Default <code>Schedulers</code></a></p>
</li>
<li>
<p><a href="#hooks">Using Global Hooks</a></p>
</li>
<li>
<p><a href="#context">Adding a Context to a Reactive Sequence</a></p>
</li>
<li>
<p><a href="#null-safety">Null Safety</a></p>
</li>
<li>
<p><a href="#cleanup">Dealing with Objects that Need Cleanup</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="advanced-mutualizing-operator-usage"><a class="anchor" href="#advanced-mutualizing-operator-usage"></a>9.1. Mutualizing Operator Usage</h3>
<div class="paragraph">
<p>From a clean-code perspective, code reuse is generally a good thing. Reactor offers a few
patterns that can help you reuse and mutualize code, notably for operators or combinations
of operators that you might want to apply regularly in your codebase. If you think of a
chain of operators as a recipe, you can create a &#8220;cookbook&#8221; of operator recipes.</p>
</div>
<div class="sect3">
<h4 id="_using_the_transform_operator"><a class="anchor" href="#_using_the_transform_operator"></a>9.1.1. Using the <code>transform</code> Operator</h4>
<div class="paragraph">
<p>The <code>transform</code> operator lets you encapsulate a piece of an operator chain into a
function. That function is applied to an original operator chain at assembly time to
augment it with the encapsulated operators. Doing so applies the same operations to all
the subscribers of a sequence and is basically equivalent to chaining the operators
directly. The following code shows an example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap =
f -&gt; f.filter(color -&gt; !color.equals("orange"))
      .map(String::toUpperCase);

Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
	.doOnNext(System.out::println)
	.transform(filterAndMap)
	.subscribe(d -&gt; System.out.println("Subscriber to Transformed MapAndFilter: "+d));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows how the <code>transform</code> operator encapsulates flows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gs-transform.png" alt="Transform Operator : encapsulate flows">
</div>
</div>
<div class="paragraph">
<p>The preceding example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber to Transformed MapAndFilter: BLUE
green
Subscriber to Transformed MapAndFilter: GREEN
orange
purple
Subscriber to Transformed MapAndFilter: PURPLE</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_transformdeferred_operator"><a class="anchor" href="#_using_the_transformdeferred_operator"></a>9.1.2. Using the <code>transformDeferred</code> Operator</h4>
<div class="paragraph">
<p>The <code>transformDeferred</code> operator is similar to <code>transform</code> and also lets you encapsulate operators
in a function. The major difference is that this function is applied to the original
sequence <em>on a per-subscriber basis</em>. It means that the function can actually produce a
different operator chain for each subscription (by maintaining some state). The
following code shows an example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">AtomicInteger ai = new AtomicInteger();
Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap = f -&gt; {
	if (ai.incrementAndGet() == 1) {
return f.filter(color -&gt; !color.equals("orange"))
        .map(String::toUpperCase);
	}
	return f.filter(color -&gt; !color.equals("purple"))
	        .map(String::toUpperCase);
};

Flux&lt;String&gt; composedFlux =
Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
    .doOnNext(System.out::println)
    .transformDeferred(filterAndMap);

composedFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Composed MapAndFilter :"+d));
composedFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Composed MapAndFilter: "+d));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows how the <code>transformDeferred</code> operator works with per-subscriber transformations:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gs-compose.png" alt="Compose Operator : Per Subscriber transformation">
</div>
</div>
<div class="paragraph">
<p>The preceding example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber 1 to Composed MapAndFilter :BLUE
green
Subscriber 1 to Composed MapAndFilter :GREEN
orange
purple
Subscriber 1 to Composed MapAndFilter :PURPLE
blue
Subscriber 2 to Composed MapAndFilter: BLUE
green
Subscriber 2 to Composed MapAndFilter: GREEN
orange
Subscriber 2 to Composed MapAndFilter: ORANGE
purple</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor.hotCold"><a class="anchor" href="#reactor.hotCold"></a>9.2. Hot Versus Cold</h3>
<div class="paragraph">
<p>So far, we have considered that all <code>Flux</code> (and <code>Mono</code>) are the same: They all represent
an asynchronous sequence of data, and nothing happens before you subscribe.</p>
</div>
<div class="paragraph">
<p>Really, though, there are two broad families of publishers: hot and cold.</p>
</div>
<div class="paragraph">
<p>The earlier description applies to the cold family of publishers. They generate data anew
for each subscription. If no subscription is created, data never gets generated.</p>
</div>
<div class="paragraph">
<p>Think of an HTTP request: Each new subscriber triggers an HTTP call, but no call is
made if no one is interested in the result.</p>
</div>
<div class="paragraph">
<p>Hot publishers, on the other hand, do not depend on any number of subscribers. They
might start publishing data right away and would continue doing so whenever a new
<code>Subscriber</code> comes in (in which case, the subscriber would see only new elements emitted
<em>after</em> it subscribed). For hot publishers, <em>something</em> does indeed happen before you
subscribe.</p>
</div>
<div class="paragraph">
<p>One example of the few hot operators in Reactor is <code>just</code>: It directly captures the value
at assembly time and replays it to anybody subscribing to it later. To re-use the HTTP
call analogy, if the captured data is the result of an HTTP call, then only one network
call is made, when instantiating <code>just</code>.</p>
</div>
<div class="paragraph">
<p>To transform <code>just</code> into a cold publisher, you can use <code>defer</code>. It defers the HTTP
request in our example to subscription time (and would result in a separate network call
for each new subscription).</p>
</div>
<div class="paragraph">
<p>On the opposite, <code>share()</code> and <code>replay(&#8230;&#8203;)</code> can be used to turn a cold publisher into
a hot one (at least once a first subscription has happened). Both of these also have
<code>Sinks.Many</code> equivalents in the <code>Sinks</code> class, which allow programmatically
feeding the sequence.</p>
</div>
<div class="paragraph">
<p>Consider two examples, one that demonstrates a cold Flux and the other that makes use of the
<code>Sinks</code> to simulate a hot Flux. The following code shows the first example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; source = Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
                          .map(String::toUpperCase);

source.subscribe(d -&gt; System.out.println("Subscriber 1: "+d));
source.subscribe(d -&gt; System.out.println("Subscriber 2: "+d));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This first example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Subscriber 1: BLUE
Subscriber 1: GREEN
Subscriber 1: ORANGE
Subscriber 1: PURPLE
Subscriber 2: BLUE
Subscriber 2: GREEN
Subscriber 2: ORANGE
Subscriber 2: PURPLE</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows the replay behavior:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gs-cold.png" alt="Replaying behavior">
</div>
</div>
<div class="paragraph">
<p>Both subscribers catch all four colors, because each subscriber causes the
process defined by the operators on the <code>Flux</code> to run.</p>
</div>
<div class="paragraph">
<p>Compare the first example to the second example, shown in the following code:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Sinks.Many&lt;String&gt; hotSource = Sinks.unsafe().many().multicast().directBestEffort();

Flux&lt;String&gt; hotFlux = hotSource.asFlux().map(String::toUpperCase);

hotFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Hot Source: "+d));

hotSource.emitNext("blue", FAIL_FAST); <i class="conum" data-value="1"></i><b>(1)</b>
hotSource.tryEmitNext("green").orThrow(); <i class="conum" data-value="2"></i><b>(2)</b>

hotFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Hot Source: "+d));

hotSource.emitNext("orange", FAIL_FAST);
hotSource.emitNext("purple", FAIL_FAST);
hotSource.emitComplete(FAIL_FAST);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>for more details about sinks, see <a href="#sinks">Sinks</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>side note: <code>orThrow()</code> here is an alternative to <code>emitNext</code> + <code>Sinks.EmitFailureHandler.FAIL_FAST</code>
that is suitable for tests, since throwing there is acceptable (more so than in reactive
applications).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The second example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Subscriber 1 to Hot Source: BLUE
Subscriber 1 to Hot Source: GREEN
Subscriber 1 to Hot Source: ORANGE
Subscriber 2 to Hot Source: ORANGE
Subscriber 1 to Hot Source: PURPLE
Subscriber 2 to Hot Source: PURPLE</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows how a subscription is broadcast:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gs-hot.png" alt="Broadcasting a subscription">
</div>
</div>
<div class="paragraph">
<p>Subscriber 1 catches all four colors. Subscriber 2, having been created after the first
two colors were produced, catches only the last two colors. This difference accounts for
the doubling of <code>ORANGE</code> and <code>PURPLE</code> in the output. The process described by the
operators on this Flux runs regardless of when subscriptions have been attached.</p>
</div>
</div>
<div class="sect2">
<h3 id="advanced-broadcast-multiple-subscribers-connectableflux"><a class="anchor" href="#advanced-broadcast-multiple-subscribers-connectableflux"></a>9.3. Broadcasting to Multiple Subscribers with <code>ConnectableFlux</code></h3>
<div class="paragraph">
<p>Sometimes, you may want to not defer only some processing to the subscription time of one
subscriber, but you might actually want for several of them to rendezvous and then
trigger the subscription and data generation.</p>
</div>
<div class="paragraph">
<p>This is what <code>ConnectableFlux</code> is made for. Two main patterns are covered in the <code>Flux</code>
API that return a <code>ConnectableFlux</code>: <code>publish</code> and <code>replay</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>publish</code> dynamically tries to respect the demand from its various subscribers, in
terms of backpressure, by forwarding these requests to the source. Most notably, if any
subscriber has a pending demand of <code>0</code>, publish pauses its requesting to the source.</p>
</li>
<li>
<p><code>replay</code> buffers data seen through the first subscription, up to configurable limits
(in time and buffer size). It replays the data to subsequent subscribers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>ConnectableFlux</code> offers additional methods to manage subscriptions downstream
versus subscriptions to the original source. These additional methods include the
following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>connect()</code> can be called manually once you reach enough subscriptions to the <code>Flux</code>. That
triggers the subscription to the upstream source.</p>
</li>
<li>
<p><code>autoConnect(n)</code> can do the same job automatically once <code>n</code> subscriptions have been
made.</p>
</li>
<li>
<p><code>refCount(n)</code> not only automatically tracks incoming subscriptions but also detects
when these subscriptions are cancelled. If not enough subscribers are tracked, the source
is &#8220;disconnected&#8221;, causing a new subscription to the source later if additional
subscribers appear.</p>
</li>
<li>
<p><code>refCount(int, Duration)</code> adds a &#8220;grace period.&#8221; Once the number of tracked subscribers
becomes too low, it waits for the <code>Duration</code> before disconnecting the source, potentially
allowing for enough new subscribers to come in and cross the connection threshold again.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

ConnectableFlux&lt;Integer&gt; co = source.publish();

co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});

System.out.println("done subscribing");
Thread.sleep(500);
System.out.println("will now connect");

co.connect();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>done subscribing
will now connect
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following code uses <code>autoConnect</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

Flux&lt;Integer&gt; autoCo = source.publish().autoConnect(2);

autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
System.out.println("subscribed first");
Thread.sleep(500);
System.out.println("subscribing second");
autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>subscribed first
subscribing second
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-three-sorts-batching"><a class="anchor" href="#advanced-three-sorts-batching"></a>9.4. Three Sorts of Batching</h3>
<div class="paragraph">
<p>When you have lots of elements and you want to separate them into batches, you have three
broad solutions in Reactor: grouping, windowing, and buffering. These three are
conceptually close, because they redistribute a <code>Flux&lt;T&gt;</code> into an aggregate. Grouping and
windowing create a <code>Flux&lt;Flux&lt;T&gt;&gt;</code>, while buffering aggregates into a <code>Collection&lt;T&gt;</code>.</p>
</div>
<div class="sect3">
<h4 id="_grouping_with_fluxgroupedfluxt"><a class="anchor" href="#_grouping_with_fluxgroupedfluxt"></a>9.4.1. Grouping with <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code></h4>
<div class="paragraph">
<p>Grouping is the act of splitting the source <code>Flux&lt;T&gt;</code> into multiple batches, each of which
matches a key.</p>
</div>
<div class="paragraph">
<p>The associated operator is <code>groupBy</code>.</p>
</div>
<div class="paragraph">
<p>Each group is represented as a <code>GroupedFlux&lt;T&gt;</code>, which lets you retrieve the key by calling its
<code>key()</code> method.</p>
</div>
<div class="paragraph">
<p>There is no necessary continuity in the content of the groups. Once a source element
produces a new key, the group for this key is opened and elements that match the key end
up in the group (several groups could be open at the same time).</p>
</div>
<div class="paragraph">
<p>This means that groups:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Are always disjoint (a source element belongs to one and only one group).</p>
</li>
<li>
<p>Can contain elements from different places in the original sequence.</p>
</li>
<li>
<p>Are never empty.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following example groups values by whether they are even or odd:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.groupBy(i -&gt; i % 2 == 0 ? "even" : "odd")
		.concatMap(g -&gt; g.defaultIfEmpty(-1) //if empty groups, show them
				.map(String::valueOf) //map to string
				.startWith(g.key())) //start with the group's key
	)
	.expectNext("odd", "1", "3", "5", "11", "13")
	.expectNext("even", "2", "4", "6", "12")
	.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Grouping is best suited for when you have a medium to low number of groups. The
groups must also imperatively be consumed (such as by a <code>flatMap</code>) so that <code>groupBy</code>
continues fetching data from upstream and feeding more groups. Sometimes, these two
constraints multiply and lead to hangs, such as when you have a high cardinality and the
concurrency of the <code>flatMap</code> consuming the groups is too low.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_windowing_with_fluxfluxt"><a class="anchor" href="#_windowing_with_fluxfluxt"></a>9.4.2. Windowing with <code>Flux&lt;Flux&lt;T&gt;&gt;</code></h4>
<div class="paragraph">
<p>Windowing is the act of splitting the source <code>Flux&lt;T&gt;</code> into <em>windows</em>, by criteria of
size, time, boundary-defining predicates, or boundary-defining <code>Publisher</code>.</p>
</div>
<div class="paragraph">
<p>The associated operators are <code>window</code>, <code>windowTimeout</code>, <code>windowUntil</code>, <code>windowWhile</code>, and
<code>windowWhen</code>.</p>
</div>
<div class="paragraph">
<p>Contrary to <code>groupBy</code>, which randomly overlaps according to incoming keys,
windows are (most of the time) opened sequentially.</p>
</div>
<div class="paragraph">
<p>Some variants can still overlap, though. For instance, in <code>window(int maxSize, int skip)</code>
the <code>maxSize</code> parameter is the number of elements after which a window
closes, and the <code>skip</code> parameter is the number of elements in the source after which a
new window is opened. So if <code>maxSize &gt; skip</code>, a new window opens before the previous one
closes and the two windows overlap.</p>
</div>
<div class="paragraph">
<p>The following example shows overlapping windows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">StepVerifier.create(
	Flux.range(1, 10)
		.window(5, 3) //overlapping windows
		.concatMap(g -&gt; g.defaultIfEmpty(-1)) //show empty windows as -1
	)
		.expectNext(1, 2, 3, 4, 5)
		.expectNext(4, 5, 6, 7, 8)
		.expectNext(7, 8, 9, 10)
		.expectNext(10)
		.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
With the reverse configuration (<code>maxSize</code> &lt; <code>skip</code>), some elements from
the source are dropped and are not part of any window.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the case of predicate-based windowing through <code>windowUntil</code> and <code>windowWhile</code>,
having subsequent source elements that do not match the predicate can also lead
to empty windows, as demonstrated in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.windowWhile(i -&gt; i % 2 == 0)
		.concatMap(g -&gt; g.defaultIfEmpty(-1))
	)
		.expectNext(-1, -1, -1) //respectively triggered by odd 1 3 5
		.expectNext(2, 4, 6) // triggered by 11
		.expectNext(12) // triggered by 13
		// however, no empty completion window is emitted (would contain extra matching elements)
		.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buffering_with_fluxlistt"><a class="anchor" href="#_buffering_with_fluxlistt"></a>9.4.3. Buffering with <code>Flux&lt;List&lt;T&gt;&gt;</code></h4>
<div class="paragraph">
<p>Buffering is similar to windowing, with the following twist: Instead of emitting
<em>windows</em> (each of which is each a <code>Flux&lt;T&gt;</code>), it emits <em>buffers</em> (which are <code>Collection&lt;T&gt;</code>&#8201;&#8212;&#8201;by default, <code>List&lt;T&gt;</code>).</p>
</div>
<div class="paragraph">
<p>The operators for buffering mirror those for windowing: <code>buffer</code>, <code>bufferTimeout</code>,
<code>bufferUntil</code>, <code>bufferWhile</code>, and <code>bufferWhen</code>.</p>
</div>
<div class="paragraph">
<p>Where the corresponding windowing operator opens a window, a buffering operator creates a
new collection and starts adding elements to it. Where a window closes, the buffering
operator emits the collection.</p>
</div>
<div class="paragraph">
<p>Buffering can also lead to dropping source elements or having overlapping buffers, as
the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">StepVerifier.create(
	Flux.range(1, 10)
		.buffer(5, 3) //overlapping buffers
	)
		.expectNext(Arrays.asList(1, 2, 3, 4, 5))
		.expectNext(Arrays.asList(4, 5, 6, 7, 8))
		.expectNext(Arrays.asList(7, 8, 9, 10))
		.expectNext(Collections.singletonList(10))
		.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Unlike in windowing, <code>bufferUntil</code> and <code>bufferWhile</code> do not emit an empty buffer, as
the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.bufferWhile(i -&gt; i % 2 == 0)
	)
	.expectNext(Arrays.asList(2, 4, 6)) // triggered by 11
	.expectNext(Collections.singletonList(12)) // triggered by 13
	.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-parallelizing-parralelflux"><a class="anchor" href="#advanced-parallelizing-parralelflux"></a>9.5. Parallelizing Work with <code>ParallelFlux</code></h3>
<div class="paragraph">
<p>With multi-core architectures being a commodity nowadays, being able to easily
parallelize work is important. Reactor helps with that by providing a special type,
<code>ParallelFlux</code>, that exposes operators that are optimized for parallelized work.</p>
</div>
<div class="paragraph">
<p>To obtain a <code>ParallelFlux</code>, you can use the <code>parallel()</code> operator on any <code>Flux</code>.
By itself, this method does not parallelize the work. Rather, it divides
the workload into &#8220;rails&#8221; (by default, as many rails as there are CPU cores).</p>
</div>
<div class="paragraph">
<p>In order to tell the resulting <code>ParallelFlux</code> where to run each rail (and, by
extension, to run rails in parallel) you have to use <code>runOn(Scheduler)</code>. Note that
there is a recommended dedicated <code>Scheduler</code> for parallel work: <code>Schedulers.parallel()</code>.</p>
</div>
<div class="paragraph">
<p>Compare the next two examples:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.range(1, 10)
    .parallel(2) <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We force a number of rails instead of relying on the number of CPU cores.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.range(1, 10)
    .parallel(2)
    .runOn(Schedulers.parallel())
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>main -&gt; 1
main -&gt; 2
main -&gt; 3
main -&gt; 4
main -&gt; 5
main -&gt; 6
main -&gt; 7
main -&gt; 8
main -&gt; 9
main -&gt; 10</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The second correctly parallelizes on two threads, as shown in the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>parallel-1 -&gt; 1
parallel-2 -&gt; 2
parallel-1 -&gt; 3
parallel-2 -&gt; 4
parallel-1 -&gt; 5
parallel-2 -&gt; 6
parallel-1 -&gt; 7
parallel-1 -&gt; 9
parallel-2 -&gt; 8
parallel-2 -&gt; 10</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If, once you process your sequence in parallel, you want to revert back to a &#8220;normal&#8221;
<code>Flux</code> and apply the rest of the operator chain in a sequential manner, you can use the
<code>sequential()</code> method on <code>ParallelFlux</code>.</p>
</div>
<div class="paragraph">
<p>Note that <code>sequential()</code> is implicitly applied if you <code>subscribe</code> to the <code>ParallelFlux</code>
with a <code>Subscriber</code> but not when using the lambda-based variants of <code>subscribe</code>.</p>
</div>
<div class="paragraph">
<p>Note also that <code>subscribe(Subscriber&lt;T&gt;)</code> merges all the rails, while
<code>subscribe(Consumer&lt;T&gt;)</code> runs all the rails. If the <code>subscribe()</code> method has a lambda,
each lambda is executed as many times as there are rails.</p>
</div>
<div class="paragraph">
<p>You can also access individual rails or &#8220;groups&#8221; as a <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code> through the
<code>groups()</code> method and apply additional operators to them through the <code>composeGroup()</code>
method.</p>
</div>
</div>
<div class="sect2">
<h3 id="scheduler-factory"><a class="anchor" href="#scheduler-factory"></a>9.6. Replacing Default <code>Schedulers</code></h3>
<div class="paragraph">
<p>As we described in the <a href="#schedulers">Threading and Schedulers</a> section, Reactor Core comes with several
<code>Scheduler</code> implementations. While you can always create new instances through the <code>new*</code>
factory methods, each <code>Scheduler</code> flavor also has a default singleton instance that is
accessible through the direct factory method (such as <code>Schedulers.boundedElastic()</code> versus
<code>Schedulers.newBoundedElastic(&#8230;&#8203;)</code>).</p>
</div>
<div class="paragraph">
<p>These default instances are the ones used by operators that need a <code>Scheduler</code> to work
when you do not explicitly specify one. For example, <code>Flux#delayElements(Duration)</code> uses
the <code>Schedulers.parallel()</code> instance.</p>
</div>
<div class="paragraph">
<p>In some cases, however, you might need to change these default instances with something
else in a cross-cutting way, without having to make sure every single operator you call
has your specific <code>Scheduler</code> as a parameter. An example is measuring the time every
single scheduled task takes by wrapping the real schedulers, for instrumentation
purposes. In other words, you might want to change the default <code>Schedulers</code>.</p>
</div>
<div class="paragraph">
<p>Changing the default schedulers is possible through the <code>Schedulers.Factory</code> class. By
default, a <code>Factory</code> creates all the standard <code>Scheduler</code> through similarly named
methods. You can override each of these with your custom implementation.</p>
</div>
<div class="paragraph">
<p>Additionally, the factory exposes one additional customization method:
<code>decorateExecutorService</code>. It is invoked during the creation of every Reactor Core
<code>Scheduler</code> that is backed by a <code>ScheduledExecutorService</code> (even non-default instances,
such as those created by calls to <code>Schedulers.newParallel()</code>).</p>
</div>
<div class="paragraph">
<p>This lets you tune the <code>ScheduledExecutorService</code> to be used: The default one is exposed
as a <code>Supplier</code> and, depending on the type of <code>Scheduler</code> being configured, you can choose
to entirely bypass that supplier and return your own instance or you can <code>get()</code> the
default instance and wrap it.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Once you create a <code>Factory</code> that fits your needs, you must install it by calling
<code>Schedulers.setFactory(Factory)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, there is a last customizable hook in <code>Schedulers</code>: <code>onHandleError</code>. This hook is
invoked whenever a <code>Runnable</code> task submitted to a <code>Scheduler</code> throws an <code>Exception</code> (note
that if there is an <code>UncaughtExceptionHandler</code> set for the <code>Thread</code> that ran the task,
both the handler and the hook are invoked).</p>
</div>
</div>
<div class="sect2">
<h3 id="hooks"><a class="anchor" href="#hooks"></a>9.7. Using Global Hooks</h3>
<div class="paragraph">
<p>Reactor has another category of configurable callbacks that are invoked by Reactor
operators in various situations. They are all set in the <code>Hooks</code> class, and they fall into
three categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#hooks-dropping">Dropping Hooks</a></p>
</li>
<li>
<p><a href="#hooks-internal">Internal Error Hook</a></p>
</li>
<li>
<p><a href="#hooks-assembly">Assembly Hooks</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="hooks-dropping"><a class="anchor" href="#hooks-dropping"></a>9.7.1. Dropping Hooks</h4>
<div class="paragraph">
<p>Dropping hooks are invoked when the source of an operator does not comply with the
Reactive Streams specification. These kind of errors are outside of the normal execution
path (that is, they cannot be propagated through <code>onError</code>).</p>
</div>
<div class="paragraph">
<p>Typically, a <code>Publisher</code> calls <code>onNext</code> on the operator despite having already called
<code>onCompleted</code> on it previously. In that case, the <code>onNext</code> value is dropped. The same
is true for an extraneous <code>onError</code> signal.</p>
</div>
<div class="paragraph">
<p>The corresponding hooks, <code>onNextDropped</code> and <code>onErrorDropped</code>, let you provide a global
<code>Consumer</code> for these drops. For example, you can use it to log the drop and clean up
resources associated with a value if needed (as it never makes it to the rest of the
reactive chain).</p>
</div>
<div class="paragraph">
<p>Setting the hooks twice in a row is additive: every consumer you provide is invoked. The
hooks can be fully reset to their defaults by using the <code>Hooks.resetOn*Dropped()</code> methods.</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-internal"><a class="anchor" href="#hooks-internal"></a>9.7.2. Internal Error Hook</h4>
<div class="paragraph">
<p>One hook, <code>onOperatorError</code>, is invoked by operators when an unexpected <code>Exception</code> is
thrown during the execution of their <code>onNext</code>, <code>onError</code>, and <code>onComplete</code> methods.</p>
</div>
<div class="paragraph">
<p>Unlike the previous category, this is still within the normal execution path. A typical
example is the <code>map</code> operator with a map function that throws an <code>Exception</code> (such as
division by zero). It is still possible at this point to go through the usual channel of
<code>onError</code>, and that is what the operator does.</p>
</div>
<div class="paragraph">
<p>First, it passes the <code>Exception</code> through <code>onOperatorError</code>. The hook lets you inspect the
error (and the incriminating value, if relevant) and change the <code>Exception</code>. Of course,
you can also do something on the side, such as log and return the original <code>Exception</code>.</p>
</div>
<div class="paragraph">
<p>Note that you can set the <code>onOperatorError</code> hook multiple times. You can provide a
<code>String</code> identifier for a particular <code>BiFunction</code> and subsequent calls with different
keys concatenates the functions, which are all executed. On the other hand, reusing the
same key twice lets you replace a function you previously set.</p>
</div>
<div class="paragraph">
<p>As a consequence, the default hook behavior can be both fully reset (by using
<code>Hooks.resetOnOperatorError()</code>) or partially reset for a specific <code>key</code> only (by using
<code>Hooks.resetOnOperatorError(String)</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-assembly"><a class="anchor" href="#hooks-assembly"></a>9.7.3. Assembly Hooks</h4>
<div class="paragraph">
<p>These hooks tie in the lifecycle of operators. They are invoked when a chain of operators
is assembled (that is, instantiated). <code>onEachOperator</code> lets you dynamically change each
operator as it is assembled in the chain, by returning a different <code>Publisher</code>.
<code>onLastOperator</code> is similar, except that it is invoked only on the last operator in the
chain before the <code>subscribe</code> call.</p>
</div>
<div class="paragraph">
<p>If you want to decorate all operators with a cross-cutting <code>Subscriber</code> implementation,
you can look into the <code>Operators#lift*</code> methods to help you deal with the various
types of Reactor <code>Publishers</code> out there (<code>Flux</code>, <code>Mono</code>, <code>ParallelFlux</code>, <code>GroupedFlux</code>, and <code>ConnectableFlux</code>),
as well as their <code>Fuseable</code> versions.</p>
</div>
<div class="paragraph">
<p>Like <code>onOperatorError</code>, these hooks are cumulative and can be identified with a key. They
can also be reset partially or totally.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hook_presets"><a class="anchor" href="#_hook_presets"></a>9.7.4. Hook Presets</h4>
<div class="paragraph">
<p>The <code>Hooks</code> utility class provides two preset hooks. These are alternatives to
the default behaviors that you can use by calling their corresponding method, rather than
coming up with the hook yourself:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>onNextDroppedFail()</code>: <code>onNextDropped</code> used to throw a <code>Exceptions.failWithCancel()</code>
exception. It now defaults to logging the dropped value at the DEBUG level. To go back to
the old default behavior of throwing, use <code>onNextDroppedFail()</code>.</p>
</li>
<li>
<p><code>onOperatorDebug()</code>: This method activates <a href="#debug-activate">debug mode</a>. It ties into
the <code>onOperatorError</code> hook, so calling <code>resetOnOperatorError()</code> also resets it. You can
independently reset it by using  <code>resetOnOperatorDebug()</code>, as it uses a specific key internally.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context"><a class="anchor" href="#context"></a>9.8. Adding a Context to a Reactive Sequence</h3>
<div class="paragraph">
<p>One of the big technical challenges encountered when switching from an imperative
programming perspective to a reactive programming mindset lies in how you deal with
threading.</p>
</div>
<div class="paragraph">
<p>Contrary to what you might be used to, in reactive programming, you can use a <code>Thread</code>
to process several asynchronous sequences that run at roughly the same time (actually, in
non-blocking locksteps). The execution can also easily and often jump from one thread to
another.</p>
</div>
<div class="paragraph">
<p>This arrangement is especially hard for developers that use features dependent on the
threading model being more &#8220;stable,&#8221; such as <code>ThreadLocal</code>. As it lets you associate
data with a thread, it becomes tricky to use in a reactive context. As a result,
libraries that rely on <code>ThreadLocal</code> at least introduce new challenges when used with
Reactor. At worst, they work badly or even fail. Using the MDC of Logback to store and
log correlation IDs is a prime example of such a situation.</p>
</div>
<div class="paragraph">
<p>The usual workaround for <code>ThreadLocal</code> usage is to move the contextual data, <code>C</code>, along
your business data, <code>T</code>, in the sequence, by using (for instance) <code>Tuple2&lt;T, C&gt;</code>. This does
not look good and leaks an orthogonal concern (the contextual data) into your method and
<code>Flux</code> signatures.</p>
</div>
<div class="paragraph">
<p>Since version <code>3.1.0</code>, Reactor comes with an advanced feature that is somewhat comparable
to <code>ThreadLocal</code> but can be applied to a <code>Flux</code> or a <code>Mono</code> instead of a <code>Thread</code>.
This feature is called <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>As an illustration of what it looks like, the following example both reads from and
writes to <code>Context</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
    .flatMap(s -&gt; Mono.deferContextual(ctx -&gt;
         Mono.just(s + " " + ctx.get(key))))
    .contextWrite(ctx -&gt; ctx.put(key, "World"));

StepVerifier.create(r)
            .expectNext("Hello World")
            .verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the following sections, we cover <code>Context</code> and how to use it, so that you
can eventually understand the preceding example.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This is an advanced feature that is more targeted at library developers. It
requires good understanding of <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#3-subscription-code">the lifecycle of a <code>Subscription</code></a> and is intended for
libraries that are responsible for the subscriptions.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="context.api"><a class="anchor" href="#context.api"></a>9.8.1. The <code>Context</code> API</h4>
<div class="paragraph">
<p><code>Context</code> is an interface reminiscent of <code>Map</code>.It stores key-value pairs and lets you
fetch a value you stored by its key. It has a simplified version that only exposes read
methods, the <code>ContextView</code>. More specifically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Both key and values are of type <code>Object</code>, so a <code>Context</code> (and <code>ContextView</code>) instance can contain any number of
highly divergent values from different libraries and sources.</p>
</li>
<li>
<p>A <code>Context</code> is immutable. It expose write methods like <code>put</code> and <code>putAll</code> but they produce a new instance.</p>
</li>
<li>
<p>For a read-only API that doesn&#8217;t even expose such write methods, there&#8217;s the <code>ContextView</code> superinterface since 3.4.0</p>
</li>
<li>
<p>You can check whether the key is present with <code>hasKey(Object key)</code>.</p>
</li>
<li>
<p>Use <code>getOrDefault(Object key, T defaultValue)</code> to retrieve a value (cast to a <code>T</code>) or
fall back to a default one if the <code>Context</code> instance does not have that key.</p>
</li>
<li>
<p>Use <code>getOrEmpty(Object key)</code> to get an <code>Optional&lt;T&gt;</code> (the <code>Context</code> instance attempts to cast the
stored value to <code>T</code>).</p>
</li>
<li>
<p>Use <code>put(Object key, Object value)</code> to store a key-value pair, returning a new
<code>Context</code> instance. You can also merge two contexts into a new one by using
<code>putAll(ContextView)</code>.</p>
</li>
<li>
<p>Use <code>delete(Object key)</code> to remove the value associated to a key, returning a new
<code>Context</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When you create a <code>Context</code>, you can create pre-valued <code>Context</code> instances with up to five
key-value pairs by using the static <code>Context.of</code> methods. They take 2, 4, 6, 8 or 10
<code>Object</code> instances, each couple of <code>Object</code> instances being a key-value pair to add to
the <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>Alternatively you can also create an empty <code>Context</code> by using <code>Context.empty()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context.write"><a class="anchor" href="#context.write"></a>9.8.2. Tying a <code>Context</code> to a <code>Flux</code> and Writing</h4>
<div class="paragraph">
<p>To make a <code>Context</code> be useful, it must be tied to a specific sequence and be accessible by
each operator in a chain. Note that the operator must be a Reactor-native operator, as
<code>Context</code> is specific to Reactor.</p>
</div>
<div class="paragraph">
<p>Actually, a <code>Context</code> is tied to each <code>Subscriber</code> in a chain. It uses the <code>Subscription</code>
propagation mechanism to make itself available to each operator, starting with the final
<code>subscribe</code> and moving up the chain.</p>
</div>
<div class="paragraph">
<p>In order to populate the <code>Context</code>, which can only be done at subscription time, you need
to use the <code>contextWrite</code> operator.</p>
</div>
<div class="paragraph">
<p><code>contextWrite(ContextView)</code> merges the <code>ContextView</code> you provide and the
<code>Context</code> from downstream (remember, the <code>Context</code> is propagated from the bottom of the
chain towards the top). This is done through a call to <code>putAll</code>, resulting in a NEW
<code>Context</code> for upstream.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can also use the more advanced <code>contextWrite(Function&lt;Context, Context&gt;)</code>.
It receives a copy of the <code>Context</code> from downstream, lets you put or delete values
as you see fit, and returns the new <code>Context</code> to use. You can even decide to return a
completely different instance, although it is really not recommended (doing so might
impact third-party libraries that depend on the <code>Context</code>).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context.read"><a class="anchor" href="#context.read"></a>9.8.3. Reading a <code>Context</code>, through the <code>ContextView</code></h4>
<div class="paragraph">
<p>Once you have populated a <code>Context</code>, you may want to peek into it at runtime.
Most of the time, the responsibility of putting information into the <code>Context</code>
is on the end user&#8217;s side, while exploiting that information is on the third-party library&#8217;s side,
as such libraries are usually upstream of the client code.</p>
</div>
<div class="paragraph">
<p>The read oriented operators allow to obtain data from the <code>Context</code> in a chain of operators by exposing
its <code>ContextView</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>to access the context from a source-like operator, use <code>deferContextual</code> factory method</p>
</li>
<li>
<p>to access the context from the middle of an operator chain, use <code>transformDeferredContextual(BiFunction)</code></p>
</li>
<li>
<p>alternatively, when dealing with an inner sequence (like inside a <code>flatMap</code>), the <code>ContextView</code>
can be materialized using <code>Mono.deferContextual(Mono::just)</code>. Usually though, you might want
to perform meaningful work directly within the defer&#8217;s lambda, eg. <code>Mono.deferContextual(ctx &#8594; doSomethingAsyncWithContextData(v, ctx.get(key)))</code>
where <code>v</code> is the value being flatMapped.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In order to read from the <code>Context</code> without misleading users into thinking one can write to it
while data is running through the pipeline, only the <code>ContextView</code> is exposed by the operators above.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_simple_context_examples"><a class="anchor" href="#_simple_context_examples"></a>9.8.4. Simple <code>Context</code> Examples</h4>
<div class="paragraph">
<p>The examples in this section are meant as ways to better understand some of the caveats of
using a <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>We first look back at our simple example from the introduction in a bit more detail, as
the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
    .flatMap(s -&gt; Mono.deferContextual(ctx -&gt;
         Mono.just(s + " " + ctx.get(key)))) <i class="conum" data-value="2"></i><b>(2)</b>
    .contextWrite(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello World") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The chain of operators ends with a call to <code>contextWrite(Function)</code> that puts
<code>"World"</code> into the <code>Context</code> under a key of <code>"message"</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We <code>flatMap</code> on the source element, materializing the <code>ContextView</code> with <code>Mono.deferContextual()</code>
and directly extract the data associated to <code>"message"</code> and concatenate that with the original word.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The resulting <code>Mono&lt;String&gt;</code> emits <code>"Hello World"</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The numbering above versus the actual line order is not a mistake. It represents
the execution order. Even though <code>contextWrite</code> is the last piece of the chain, it is
the one that gets executed first (due to its subscription-time nature and the fact that
the subscription signal flows from bottom to top).
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In your chain of operators, the relative positions of where you write to the
<code>Context</code> and where you read from it matters. The <code>Context</code>
is immutable and its content can only be seen by operators above it, as demonstrated in
the following example:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
    .contextWrite(ctx -&gt; ctx.put(key, "World")) <i class="conum" data-value="1"></i><b>(1)</b>
    .flatMap( s -&gt; Mono.deferContextual(ctx -&gt;
        Mono.just(s + " " + ctx.getOrDefault(key, "Stranger")))); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Stranger") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Context</code> is written to too high in the chain.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As a result, in the <code>flatMap</code>, there is no value associated with our key. A default value
is used instead.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The resulting <code>Mono&lt;String&gt;</code> thus emits <code>"Hello Stranger"</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly, in the case of several attempts to write the same key to the <code>Context</code>, the
relative order of the writes matters, too. Operators that read the <code>Context</code> see
the value that was set closest to being under them, as demonstrated in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String key = "message";
Mono&lt;String&gt; r = Mono
    .deferContextual(ctx -&gt; Mono.just("Hello " + ctx.get(key)))
    .contextWrite(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
    .contextWrite(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A write attempt on key <code>"message"</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Another write attempt on key <code>"message"</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>deferContextual</code> only saw the value set closest to it (and below it): <code>"Reactor"</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>Context</code> is populated with <code>"World"</code> during subscription.
Then the subscription signal moves upstream and another write happens. This produces a
second immutable <code>Context</code> with a value of <code>"Reactor"</code>. After that, data starts flowing.
The <code>deferContextual</code> sees the <code>Context</code> closest to it, which is our second <code>Context</code> with the
<code>"Reactor"</code> value (exposed to the user as a <code>ContextView</code>).</p>
</div>
<div class="paragraph">
<p>You might wonder if the <code>Context</code> is propagated along with the data signal. If that was
the case, putting another <code>flatMap</code> between these two writes would use the value from
the top <code>Context</code>. But this is not the case, as demonstrated by the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String key = "message";
Mono&lt;String&gt; r = Mono
    .deferContextual(ctx -&gt; Mono.just("Hello " + ctx.get(key))) <i class="conum" data-value="3"></i><b>(3)</b>
    .contextWrite(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="2"></i><b>(2)</b>
    .flatMap( s -&gt; Mono.deferContextual(ctx -&gt;
        Mono.just(s + " " + ctx.get(key)))) <i class="conum" data-value="4"></i><b>(4)</b>
    .contextWrite(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor World") <i class="conum" data-value="5"></i><b>(5)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the first write to happen.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the second write to happen.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The top context read sees second write.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>flatMap</code> concatenates the result from initial read with the value from the first write.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>Mono</code> emits <code>"Hello Reactor World"</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The reason is that the <code>Context</code> is associated to the <code>Subscriber</code> and each operator
accesses the <code>Context</code> by requesting it from its downstream <code>Subscriber</code>.</p>
</div>
<div class="paragraph">
<p>One last interesting propagation case is the one where the <code>Context</code> is also written to
inside a <code>flatMap</code>, as in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
    .flatMap( s -&gt; Mono
        .deferContextual(ctxView -&gt; Mono.just(s + " " + ctxView.get(key)))
    )
    .flatMap( s -&gt; Mono
        .deferContextual(ctxView -&gt; Mono.just(s + " " + ctxView.get(key)))
        .contextWrite(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
    )
    .contextWrite(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello World Reactor")
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This <code>contextWrite</code> does not impact anything outside of its <code>flatMap</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This <code>contextWrite</code> impacts the main sequence&#8217;s <code>Context</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the final emitted value is <code>"Hello World Reactor"</code> and not "Hello
Reactor World", because the <code>contextWrite</code> that writes <code>"Reactor"</code> does so as part of
the inner sequence of the second <code>flatMap</code>. As a consequence, it is not visible or propagated
through the main sequence and the first <code>flatMap</code> does not see it. Propagation and immutability
isolate the <code>Context</code> in operators that create intermediate inner sequences such as <code>flatMap</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_full_example"><a class="anchor" href="#_full_example"></a>9.8.5. Full Example</h4>
<div class="paragraph">
<p>Now we can consider a more real life example of a library reading information from the <code>Context</code>:
a reactive HTTP client that takes a <code>Mono&lt;String&gt;</code> as the source of data for a <code>PUT</code> but
also looks for a particular Context key to add a correlation ID to the request&#8217;s headers.</p>
</div>
<div class="paragraph">
<p>From the user perspective, it is called as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">doPut("www.example.com", Mono.just("Walter"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In order to propagate a correlation ID, it would be called as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">doPut("www.example.com", Mono.just("Walter"))
	.contextWrite(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As the preceding snippets show, the user code uses <code>contextWrite</code> to populate
a <code>Context</code> with an <code>HTTP_CORRELATION_ID</code> key-value pair. The upstream of the operator is
a <code>Mono&lt;Tuple2&lt;Integer, String&gt;&gt;</code> (a simplistic representation of an HTTP response)
returned by the HTTP client library. So it effectively passes information from the
user code to the library code.</p>
</div>
<div class="paragraph">
<p>The following example shows mock code from the library&#8217;s perspective that reads the
context and &#8220;augments the request&#8221; if it can find the correlation ID:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">static final String HTTP_CORRELATION_ID = "reactive.http.library.correlationId";

Mono&lt;Tuple2&lt;Integer, String&gt;&gt; doPut(String url, Mono&lt;String&gt; data) {
  Mono&lt;Tuple2&lt;String, Optional&lt;Object&gt;&gt;&gt; dataAndContext =
      data.zipWith(Mono.deferContextual(c -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
          Mono.just(c.getOrEmpty(HTTP_CORRELATION_ID))) <i class="conum" data-value="2"></i><b>(2)</b>
      );

  return dataAndContext.&lt;String&gt;handle((dac, sink) -&gt; {
      if (dac.getT2().isPresent()) { <i class="conum" data-value="3"></i><b>(3)</b>
        sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url +
            " with header X-Correlation-ID = " + dac.getT2().get());
      }
      else {
        sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url);
      }
        sink.complete();
      })
      .map(msg -&gt; Tuples.of(200, msg));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Materialize the <code>ContextView</code> through <code>Mono.deferContextual</code> and&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>within the defer, extract a value for the correlation ID key, as an <code>Optional</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the key was present in the context, use the correlation ID as a header.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The library snippet zips the data <code>Mono</code> with <code>Mono.deferContextual(Mono::just)</code>.
This gives the library a <code>Tuple2&lt;String, ContextView&gt;</code>, and that
context contains the <code>HTTP_CORRELATION_ID</code> entry from downstream (as it is on the direct
path to the subscriber).</p>
</div>
<div class="paragraph">
<p>The library code then uses <code>map</code> to extract an <code>Optional&lt;String&gt;</code> for that key, and, if
the entry is present, it uses the passed correlation ID as a <code>X-Correlation-ID</code> header.
That last part is simulated by the <code>handle</code>.</p>
</div>
<div class="paragraph">
<p>The whole test that validates the library code used the correlation ID can be written as
follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
public void contextForLibraryReactivePut() {
  Mono&lt;String&gt; put = doPut("www.example.com", Mono.just("Walter"))
      .contextWrite(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))
      .filter(t -&gt; t.getT1() &lt; 300)
      .map(Tuple2::getT2);

  StepVerifier.create(put)
              .expectNext("PUT &lt;Walter&gt; sent to www.example.com" +
                  " with header X-Correlation-ID = 2-j3r9afaf92j-afkaf")
              .verifyComplete();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cleanup"><a class="anchor" href="#cleanup"></a>9.9. Dealing with Objects that Need Cleanup</h3>
<div class="paragraph">
<p>In very specific cases, your application may deal with types that necessitate some form of cleanup once they are no longer in use.
This is an advanced scenario&#8201;&#8212;&#8201;for, example when you have reference-counted objects or when you deal with off-heap objects.
Netty&#8217;s <code>ByteBuf</code> is a prime example of both.</p>
</div>
<div class="paragraph">
<p>In order to ensure proper cleanup of such objects, you need to account for it on a <code>Flux</code>-by-<code>Flux</code> basis, as well as in several of the global hooks (see <a href="#hooks">Using Global Hooks</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>doOnDiscard</code> <code>Flux</code>/<code>Mono</code> operator</p>
</li>
<li>
<p>The <code>onOperatorError</code> hook</p>
</li>
<li>
<p>The <code>onNextDropped</code> hook</p>
</li>
<li>
<p>Operator-specific handlers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is needed because each hook is made with a specific subset of cleanup in mind, and users might want (for example) to implement specific error-handling logic in addition to cleanup logic within <code>onOperatorError</code>.</p>
</div>
<div class="paragraph">
<p>Note that some operators are less adapted to dealing with objects that need cleanup.
For example, <code>bufferWhen</code> can introduce overlapping buffers, and that means that the discard &#8220;local hook&#8221; we used earlier might see a first buffer as being discarded and cleanup an element in it that is in a second buffer, where it is still valid.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
For the purpose of cleaning up, <strong>all these hooks MUST be IDEMPOTENT</strong>.
They might on some occasions get applied several times to the same object.
Unlike the <code>doOnDiscard</code> operator, which performs a class-level <code>instanceOf</code> check, the global hooks are also dealing with instances that can be any <code>Object</code>. It is up to the user&#8217;s implementation to distinguish between which instances need cleanup and which do not.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_the_doondiscard_operator_or_local_hook"><a class="anchor" href="#_the_doondiscard_operator_or_local_hook"></a>9.9.1. The <code>doOnDiscard</code> Operator or Local Hook</h4>
<div class="paragraph">
<p>This hook has been specifically put in place for cleanup of objects that would otherwise never be exposed to user code.
It is intended as a cleanup hook for flows that operate under normal circumstances (not malformed sources that push too many items, which is covered by <code>onNextDropped</code>).</p>
</div>
<div class="paragraph">
<p>It is local, in the sense that it is activated through an operator and applies only to a given <code>Flux</code> or <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p>Obvious cases include operators that filter elements from upstream.
These elements never reach the next operator (or final subscriber), but this is part of the normal path of execution.
As such, they are passed to the <code>doOnDiscard</code> hook.
Examples of when you might use the <code>doOnDiscard</code> hook include the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filter</code>: Items that do not match the filter are considered to be &#8220;discarded.&#8221;</p>
</li>
<li>
<p><code>skip</code>: Skipped items are discarded.</p>
</li>
<li>
<p><code>buffer(maxSize, skip)</code> with <code>maxSize &lt; skip</code>: A &#8220;dropping buffer&#8221;&#8201;&#8212;&#8201;items in between buffers are discarded.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But <code>doOnDiscard</code> is not limited to filtering operators, and is also used by operators that internally queue data for backpressure purposes.
More specifically, most of the time, this is important during cancellation. An operator that prefetches data from its source and later drains to its subscriber upon demand could have un-emitted data when it gets cancelled.
Such operators use the <code>doOnDiscard</code> hook during cancellation to clear up their internal backpressure <code>Queue</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Each call to <code>doOnDiscard(Class, Consumer)</code> is additive with the others, to the extent that it is visible and used by only operators upstream of it.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_the_onoperatorerror_hook"><a class="anchor" href="#_the_onoperatorerror_hook"></a>9.9.2. The <code>onOperatorError</code> hook</h4>
<div class="paragraph">
<p>The <code>onOperatorError</code> hook is intended to modify errors in a transverse manner (similar to an AOP catch-and-rethrow).</p>
</div>
<div class="paragraph">
<p>When the error happens during the processing of an <code>onNext</code> signal, the element that was being emitted is passed to <code>onOperatorError</code>.</p>
</div>
<div class="paragraph">
<p>If that type of element needs cleanup, you need to implement it in the <code>onOperatorError</code> hook, possibly on top of error-rewriting code.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_onnextdropped_hook"><a class="anchor" href="#_the_onnextdropped_hook"></a>9.9.3. The <code>onNextDropped</code> Hook</h4>
<div class="paragraph">
<p>With malformed <code>Publishers</code>, there could be cases where an operator receives an element when it expected none (typically, after having received the <code>onError</code> or <code>onComplete</code> signals).
In such cases, the unexpected element is &#8220;dropped&#8221;&#8201;&#8212;&#8201;that is, passed to the <code>onNextDropped</code> hook.
If you have types that need cleanup, you must detect these in the <code>onNextDropped</code> hook and implement cleanup code there as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_operator_specific_handlers"><a class="anchor" href="#_operator_specific_handlers"></a>9.9.4. Operator-specific Handlers</h4>
<div class="paragraph">
<p>Some operators that deal with buffers or collect values as part of their operations have specific handlers for cases where collected data is not propagated downstream.
If you use such operators with the type(s) that need cleanup, you need to perform cleanup in these handlers.</p>
</div>
<div class="paragraph">
<p>For example, <code>distinct</code> has such a callback that is invoked when the operator terminates (or is cancelled) in order to clear the collection it uses to judge whether an element is distinct or not.
By default, the collection is a <code>HashSet</code>, and the cleanup callback is a <code>HashSet::clear</code>.
However, if you deal with reference-counted objects, you might want to change that to a more involved handler that would <code>release</code> each element in the set before calling <code>clear()</code> on it.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="null-safety"><a class="anchor" href="#null-safety"></a>9.10. Null Safety</h3>
<div class="paragraph">
<p>Although Java does not allow expressing null-safety with its type system, Reactor
now provides annotations to declare nullability of APIs, similar to those provided by
Spring Framework 5.</p>
</div>
<div class="paragraph">
<p>Reactor uses these annotations, but they can also be used in any Reactor-based
Java project to declare null-safe APIs. Nullability of the types used inside method bodies
is outside of the scope of this feature.</p>
</div>
<div class="paragraph">
<p>These annotations are meta-annotated with <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>
annotations (a dormant JSR that is supported by tools such as IntelliJ IDEA) to provide
useful warnings to Java developers related to null-safety in order to avoid
<code>NullPointerException</code> at runtime. JSR 305 meta-annotations let tooling vendors
provide null safety support in a generic way, without having to hard-code support for Reactor annotations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is not necessary nor recommended with Kotlin 1.1.5+ to have a dependency on JSR 305 in
your project classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>They are also used by Kotlin, which natively supports
<a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a>. See
<a href="#kotlin-null-safety">this dedicated section</a> for more details.</p>
</div>
<div class="paragraph">
<p>The following annotations are provided in the <code>reactor.util.annotation</code> package:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNull.html"><code>@NonNull</code></a>:
Indicates that a specific parameter, return value, or field cannot be <code>null</code>.
(It is not needed on parameters and return values where <code>@NonNullApi</code> applies) .</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/Nullable.html"><code>@Nullable</code></a>:
Indicates that a parameter, return value, or field can be <code>null</code>.</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNullApi.html"><code>@NonNullApi</code></a>:
Package-level annotation that indicates non-null is the default behavior for
parameters and return values.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Nullability for generic type arguments, variable arguments, and array elements is not yet supported.
See <a href="https://github.com/reactor/reactor-core/issues/878">issue #878</a> for up-to-date
information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/advancedFeatures.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#advanced">Advanced Features and Concepts</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="which-operator"><a class="anchor" href="#which-operator"></a>Appendix A: Which operator do I need?</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In this section, if an operator is specific to <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> or <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>, it is prefixed and linked accordingly, like this: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-">Flux#fromArray</a>. Common operators have no prefix, and links to both implementations are provided, for example: <code>just</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-">Mono</a>). When a specific use case is covered by a combination of operators, it is presented as a method call, with a leading dot and parameters in parentheses, as follows: <code>.methodCall(parameter)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>I want to deal with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#which.create">Creating a New Sequence&#8230;&#8203;</a></p>
</li>
<li>
<p><a href="#which.values">Transforming an Existing Sequence</a></p>
</li>
<li>
<p><a href="#which.filtering">Filtering a Sequence</a></p>
</li>
<li>
<p><a href="#which.peeking">Peeking into a Sequence</a></p>
</li>
<li>
<p><a href="#which.errors">Handling Errors</a></p>
</li>
<li>
<p><a href="#which.time">Working with Time</a></p>
</li>
<li>
<p><a href="#which.window">Splitting a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a></a></p>
</li>
<li>
<p><a href="#which.blocking">Going Back to the Synchronous World</a></p>
</li>
<li>
<p><a href="#which.multicasting">Multicasting a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> to several <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true">Subscribers</a></a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="which.create"><a class="anchor" href="#which.create"></a>A.1. Creating a New Sequence&#8230;&#8203;</h3>
<div class="ulist">
<ul>
<li>
<p>that emits a <code>T</code>, and I already have: <code>just</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;from an <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Optional&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-java.util.Optional-">Mono#justOrEmpty(Optional&lt;T&gt;)</a></p>
</li>
<li>
<p>&#8230;&#8203;from a potentially <code>null</code> T: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-T-">Mono#justOrEmpty(T)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>that emits a <code>T</code> returned by a method: <code>just</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-">Mono</a>) as well</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but lazily captured: use <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-">Mono#fromSupplier</a> or wrap <code>just</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-">Mono</a>) inside <code>defer</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>that emits several <code>T</code> I can explicitly enumerate: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux#just(T&#8230;&#8203;)</a></p>
</li>
<li>
<p>that iterates over:</p>
<div class="ulist">
<ul>
<li>
<p>an array: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-">Flux#fromArray</a></p>
</li>
<li>
<p>a collection or iterable: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromIterable-java.lang.Iterable-">Flux#fromIterable</a></p>
</li>
<li>
<p>a range of integers: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#range-int-int-">Flux#range</a></p>
</li>
<li>
<p>a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a> supplied for each Subscription: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromStream-java.util.function.Supplier-">Flux#fromStream(Supplier&lt;Stream&gt;)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>that emits from various single-valued sources such as:</p>
<div class="ulist">
<ul>
<li>
<p>a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html">Supplier&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-">Mono#fromSupplier</a></p>
</li>
<li>
<p>a task: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-">Mono#fromCallable</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromRunnable-java.lang.Runnable-">Mono#fromRunnable</a></p>
</li>
<li>
<p>a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromFuture-java.util.concurrent.CompletableFuture-">Mono#fromFuture</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>that completes: <code>empty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#empty--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--">Mono</a>)</p>
</li>
<li>
<p>that errors immediately: <code>error</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but lazily build the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html">Throwable</a>: <code>error(Supplier&lt;Throwable&gt;)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>that never does anything: <code>never</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#never--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#never--">Mono</a>)</p>
</li>
<li>
<p>that is decided at subscription: <code>defer</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-">Mono</a>)</p>
</li>
<li>
<p>that depends on a disposable resource: <code>using</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>that generates events programmatically (can use state):</p>
<div class="ulist">
<ul>
<li>
<p>synchronously and one-by-one: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#generate-java.util.concurrent.Callable-java.util.function.BiFunction-">Flux#generate</a></p>
</li>
<li>
<p>asynchronously (can also be sync), multiple emissions possible in one pass: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#create-java.util.function.Consumer-">Flux#create</a>
(<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#create-java.util.function.Consumer-">Mono#create</a> as well, without the multiple emission aspect)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.values"><a class="anchor" href="#which.values"></a>A.2. Transforming an Existing Sequence</h3>
<div class="ulist">
<ul>
<li>
<p>I want to transform existing data:</p>
<div class="ulist">
<ul>
<li>
<p>on a 1-to-1 basis (eg. strings to their length): <code>map</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#map-java.util.function.Function-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;by just casting it: <code>cast</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cast-java.lang.Class-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cast-java.lang.Class-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;in order to materialize each source value&#8217;s index: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#index--">Flux#index</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>on a 1-to-n basis (eg. strings to their characters): <code>flatMap</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-">Mono</a>) + use a factory method</p>
</li>
<li>
<p>on a 1-to-n basis with programmatic behavior for each source element and/or state: <code>handle</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#handle-java.util.function.BiConsumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#handle-java.util.function.BiConsumer-">Mono</a>)</p>
</li>
<li>
<p>running an asynchronous task for each source item (eg. urls to http request): <code>flatMap</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-">Mono</a>) + an async <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true">Publisher</a>-returning method</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;ignoring some data: conditionally return a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--">Mono.empty()</a> in the flatMap lambda</p>
</li>
<li>
<p>&#8230;&#8203;retaining the original sequence order: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-">Flux#flatMapSequential</a> (this triggers the async processes immediately but reorders the results)</p>
</li>
<li>
<p>&#8230;&#8203;where the async task can return multiple values, from a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> source: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMapMany-java.util.function.Function-">Mono#flatMapMany</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to add pre-set elements to an existing sequence:</p>
<div class="ulist">
<ul>
<li>
<p>at the start: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#startWith-T%2E%2E%2E-">Flux#startWith(T&#8230;&#8203;)</a></p>
</li>
<li>
<p>at the end: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWithValues-T%2E%2E%2E-">Flux#concatWithValues(T&#8230;&#8203;)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to aggregate a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a>: (the <code>Flux#</code> prefix is assumed below)</p>
<div class="ulist">
<ul>
<li>
<p>into a List: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectList--">collectList</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectSortedList--">collectSortedList</a></p>
</li>
<li>
<p>into a Map: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-">collectMap</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-">collectMultiMap</a></p>
</li>
<li>
<p>into an arbitrary container: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collect-java.util.stream.Collector-">collect</a></p>
</li>
<li>
<p>into the size of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#count--">count</a></p>
</li>
<li>
<p>by applying a function between each element (eg. running sum): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#reduce-A-java.util.function.BiFunction-">reduce</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but emitting each intermediary value: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction-">scan</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>into a boolean value from a predicate:</p>
<div class="ulist">
<ul>
<li>
<p>applied to all values (AND): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#all-java.util.function.Predicate-">all</a></p>
</li>
<li>
<p>applied to at least one value (OR): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#any-java.util.function.Predicate-">any</a></p>
</li>
<li>
<p>testing the presence of any value: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElements--">hasElements</a> <em>(there is a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> equivalent in <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#hasElement--">hasElement</a>)</em></p>
</li>
<li>
<p>testing the presence of a specific value: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElement-T-">hasElement(T)</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to combine publishers&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>in sequential order: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher%2E%2E%2E-">Flux#concat</a> or <code>.concatWith(other)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWith-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#concatWith-org.reactivestreams.Publisher-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but delaying any error until remaining publishers have been emitted: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatDelayError-org.reactivestreams.Publisher-">Flux#concatDelayError</a></p>
</li>
<li>
<p>&#8230;&#8203;but eagerly subscribing to subsequent publishers: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeSequential-int-org.reactivestreams.Publisher%2E%2E%2E-">Flux#mergeSequential</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>in emission order (combined items emitted as they come): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#merge-int-org.reactivestreams.Publisher%2E%2E%2E-">Flux#merge</a> / <code>.mergeWith(other)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeWith-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#mergeWith-org.reactivestreams.Publisher-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with different types (transforming merge): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-">Flux#zip</a> / <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-">Flux#zipWith</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by pairing values:</p>
<div class="ulist">
<ul>
<li>
<p>from 2 Monos into a <a href="https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html">Tuple2</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zipWith-reactor.core.publisher.Mono-">Mono#zipWith</a></p>
</li>
<li>
<p>from n Monos when they all completed: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zip-java.util.function.Function-reactor.core.publisher.Mono%2E%2E%2E-">Mono#zip</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by coordinating their termination:</p>
<div class="ulist">
<ul>
<li>
<p>from 1 Mono and any source into a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono&lt;Void&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#and-org.reactivestreams.Publisher-">Mono#and</a></p>
</li>
<li>
<p>from n sources when they all completed: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#when-java.lang.Iterable-">Mono#when</a></p>
</li>
<li>
<p>into an arbitrary container type:</p>
<div class="ulist">
<ul>
<li>
<p>each time all sides have emitted: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-">Flux#zip</a> (up to the smallest cardinality)</p>
</li>
<li>
<p>each time a new value arrives at either side: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#combineLatest-java.util.function.Function-int-org.reactivestreams.Publisher%2E%2E%2E-">Flux#combineLatest</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>selecting the first publisher which&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>produces a <em>value</em> (<code>onNext</code>): <code>firstWithValue</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithValue-java.lang.Iterable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithValue-java.lang.Iterable-">Mono</a>)</p>
</li>
<li>
<p>produces <em>any signal</em>: <code>firstWithSignal</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithSignal-java.lang.Iterable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithSignal-java.lang.Iterable-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>triggered by the elements in a source sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchMap-java.util.function.Function-">switchMap</a> (each source element is mapped to a Publisher)</p>
</li>
<li>
<p>triggered by the start of the next publisher in a sequence of publishers: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchOnNext-org.reactivestreams.Publisher-">switchOnNext</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to repeat an existing sequence: <code>repeat</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#repeat--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#repeat--">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but at time intervals: <code>Flux.interval(duration).flatMap(tick &#8594; myExistingPublisher)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I have an empty sequence but&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>I want a value instead: <code>defaultIfEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defaultIfEmpty-T-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defaultIfEmpty-T-">Mono</a>)</p>
</li>
<li>
<p>I want another sequence instead: <code>switchIfEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchIfEmpty-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#switchIfEmpty-reactor.core.publisher.Mono-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>I have a sequence but I am not interested in values: <code>ignoreElements</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--">Flux.ignoreElements()</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--">Mono.ignoreElement()</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;and I want the completion represented as a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono&lt;Void&gt;</a>: <code>then</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#then--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then--">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;and I want to wait for another task to complete at the end: <code>thenEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenEmpty-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenEmpty-org.reactivestreams.Publisher-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;and I want to switch to another <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> at the end: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then-reactor.core.publisher.Mono-">Mono#then(mono)</a></p>
</li>
<li>
<p>&#8230;&#8203;and I want to emit a single value at the end: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenReturn-V-">Mono#thenReturn(T)</a></p>
</li>
<li>
<p>&#8230;&#8203;and I want to switch to a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> at the end: <code>thenMany</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenMany-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenMany-org.reactivestreams.Publisher-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>I have a Mono for which I want to defer completion&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;until another publisher, which is derived from this value, has completed: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayUntil-java.util.function.Function-">Mono#delayUntil(Function)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to expand elements recursively into a graph of sequences and emit the combination&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;expanding the graph breadth first: <code>expand(Function)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expand-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expand-java.util.function.Function-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;expanding the graph depth first: <code>expandDeep(Function)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expandDeep-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expandDeep-java.util.function.Function-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.peeking"><a class="anchor" href="#which.peeking"></a>A.3. Peeking into a Sequence</h3>
<div class="ulist">
<ul>
<li>
<p>Without modifying the final sequence, I want to:</p>
<div class="ulist">
<ul>
<li>
<p>get notified of / execute additional behavior (sometimes referred to as "side-effects") on:</p>
<div class="ulist">
<ul>
<li>
<p>emissions: <code>doOnNext</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnNext-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>completion: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-">Flux#doOnComplete</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSuccess-java.util.function.Consumer-">Mono#doOnSuccess</a> (includes the result, if any)</p>
</li>
<li>
<p>error termination: <code>doOnError</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnError-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>cancellation: <code>doOnCancel</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnCancel-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnCancel-java.lang.Runnable-">Mono</a>)</p>
</li>
<li>
<p>"start" of the sequence: <code>doFirst</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFirst-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFirst-java.lang.Runnable-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>this is tied to <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true#subscribe(org.reactivestreams.Subscriber)">Publisher#subscribe(Subscriber)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>post-subscription : <code>doOnSubscribe</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSubscribe-java.util.function.Consumer-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p><code>Subscription</code> acknowledgment after <code>subscribe</code></p>
</li>
<li>
<p>this is tied to <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true#onSubscribe(org.reactivestreams.Subscription)">Subscriber#onSubscribe(Subscription)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>request: <code>doOnRequest</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnRequest-java.util.function.LongConsumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnRequest-java.util.function.LongConsumer-">Mono</a>)</p>
</li>
<li>
<p>completion or error: <code>doOnTerminate</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnTerminate-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnTerminate-java.lang.Runnable-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>but <strong>after</strong> it has been propagated downstream: <code>doAfterTerminate</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doAfterTerminate-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doAfterTerminate-java.lang.Runnable-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>any type of signal, represented as a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html">Signal</a>: <code>doOnEach</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>any terminating condition (complete, error, cancel): <code>doFinally</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>log what happens internally: <code>log</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to know of all events:</p>
<div class="ulist">
<ul>
<li>
<p>each represented as <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html">Signal</a> object:</p>
<div class="ulist">
<ul>
<li>
<p>in a callback outside the sequence: <code>doOnEach</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>instead of the original onNext emissions: <code>materialize</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#materialize--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#materialize--">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;and get back to the onNexts: <code>dematerialize</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#dematerialize--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#dematerialize--">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>as a line in a log: <code>log</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.filtering"><a class="anchor" href="#which.filtering"></a>A.4. Filtering a Sequence</h3>
<div class="ulist">
<ul>
<li>
<p>I want to filter a sequence:</p>
<div class="ulist">
<ul>
<li>
<p>based on an arbitrary criteria: <code>filter</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filter-java.util.function.Predicate-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;that is asynchronously computed: <code>filterWhen</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filterWhen-java.util.function.Function-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>restricting on the type of the emitted objects: <code>ofType</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ofType-java.lang.Class-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ofType-java.lang.Class-">Mono</a>)</p>
</li>
<li>
<p>by ignoring the values altogether: <code>ignoreElements</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--">Flux.ignoreElements()</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--">Mono.ignoreElement()</a>)</p>
</li>
<li>
<p>by ignoring duplicates:</p>
<div class="ulist">
<ul>
<li>
<p>in the whole sequence (logical set): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinct--">Flux#distinct</a></p>
</li>
<li>
<p>between subsequently emitted items (deduplication): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinctUntilChanged--">Flux#distinctUntilChanged</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to keep only a subset of the sequence:</p>
<div class="ulist">
<ul>
<li>
<p>by taking N elements:</p>
<div class="ulist">
<ul>
<li>
<p>at the beginning of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-">Flux#take(long)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;requesting an unbounded amount from upstream: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-boolean-">Flux#take(long, false)</a></p>
</li>
<li>
<p>&#8230;&#8203;based on a duration: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-java.time.Duration-">Flux#take(Duration)</a></p>
</li>
<li>
<p>&#8230;&#8203;only the first element, as a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#next--">Flux#next()</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>at the end of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-">Flux#takeLast</a></p>
</li>
<li>
<p>until a criteria is met (inclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntil-java.util.function.Predicate-">Flux#takeUntil</a> (predicate-based), <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntilOther-org.reactivestreams.Publisher-">Flux#takeUntilOther</a> (companion publisher-based)</p>
</li>
<li>
<p>while a criteria is met (exclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeWhile-java.util.function.Predicate-">Flux#takeWhile</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by taking at most 1 element:</p>
<div class="ulist">
<ul>
<li>
<p>at a specific position: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elementAt-int-">Flux#elementAt</a></p>
</li>
<li>
<p>at the end: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-">.takeLast(1)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;and emit an error if empty: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last--">Flux#last()</a></p>
</li>
<li>
<p>&#8230;&#8203;and emit a default value if empty: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last-T-">Flux#last(T)</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>by skipping elements:</p>
<div class="ulist">
<ul>
<li>
<p>at the beginning of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-long-">Flux#skip(long)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;based on a duration: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-java.time.Duration-">Flux#skip(Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>at the end of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipLast-int-">Flux#skipLast</a></p>
</li>
<li>
<p>until a criteria is met (inclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntil-java.util.function.Predicate-">Flux#skipUntil</a> (predicate-based), <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntilOther-org.reactivestreams.Publisher-">Flux#skipUntilOther</a> (companion publisher-based)</p>
</li>
<li>
<p>while a criteria is met (exclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipWhile-java.util.function.Predicate-">Flux#skipWhile</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by sampling items:</p>
<div class="ulist">
<ul>
<li>
<p>by duration: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-java.time.Duration-">Flux#sample(Duration)</a></p>
<div class="ulist">
<ul>
<li>
<p>but keeping the first element in the sampling window instead of the last: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleFirst-java.time.Duration-">sampleFirst</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by a publisher-based window: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-org.reactivestreams.Publisher-">Flux#sample(Publisher)</a></p>
</li>
<li>
<p>based on a publisher "timing out": <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleTimeout-java.util.function.Function-">Flux#sampleTimeout</a> (each element triggers a publisher, and is emitted if that publisher does not overlap with the next)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I expect at most 1 element (error if more than one)&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>and I want an error if the sequence is empty: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single--">Flux#single()</a></p>
</li>
<li>
<p>and I want a default value if the sequence is empty: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single-T-">Flux#single(T)</a></p>
</li>
<li>
<p>and I accept an empty sequence as well: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#singleOrEmpty--">Flux#singleOrEmpty</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.errors"><a class="anchor" href="#which.errors"></a>A.5. Handling Errors</h3>
<div class="ulist">
<ul>
<li>
<p>I want to create an erroring sequence: <code>error</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-">Mono</a>)&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;to replace the completion of a successful <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a>: <code>.concat(Flux.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;to replace the <strong>emission</strong> of a successful <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>: <code>.then(Mono.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;if too much time elapses between onNexts: <code>timeout</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;lazily: <code>error(Supplier&lt;Throwable&gt;)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>I want the try/catch equivalent of:</p>
<div class="ulist">
<ul>
<li>
<p>throwing: <code>error</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-">Mono</a>)</p>
</li>
<li>
<p>catching an exception:</p>
<div class="ulist">
<ul>
<li>
<p>and falling back to a default value: <code>onErrorReturn</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-">Mono</a>)</p>
</li>
<li>
<p>and falling back to another <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> or <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>: <code>onErrorResume</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-">Mono</a>)</p>
</li>
<li>
<p>and wrapping and re-throwing: <code>.onErrorMap(t &#8594; new RuntimeException(t))</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorMap-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorMap-java.util.function.Function-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>the finally block: <code>doFinally</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>the using pattern from Java 7: <code>using</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Mono</a>) factory method</p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to recover from errors&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>by falling back:</p>
<div class="ulist">
<ul>
<li>
<p>to a value: <code>onErrorReturn</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-">Mono</a>)</p>
</li>
<li>
<p>to a <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true">Publisher</a> or <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>, possibly different ones depending on the error: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-">Flux#onErrorResume</a> and <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-">Mono#onErrorResume</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by retrying&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with a simple policy (max number of attempts): <code>retry()</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry--">Mono</a>), <code>retry(long)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry-long-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry-long-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;triggered by a companion control Flux: <code>retryWhen</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;using a standard backoff strategy (exponential backoff with jitter): <code>retryWhen(Retry.backoff(&#8230;&#8203;))</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-">Mono</a>) (see also other factory methods in <a href="https://projectreactor.io/docs/core/release/api/reactor/util/retry/Retry.html">Retry</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to deal with backpressure "errors" (request max from upstream and apply the strategy when downstream does not produce enough request)&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>by throwing a special <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html?is-external=true">IllegalStateException</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureError--">Flux#onBackpressureError</a></p>
</li>
<li>
<p>by dropping excess values: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureDrop--">Flux#onBackpressureDrop</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;except the last one seen: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureLatest--">Flux#onBackpressureLatest</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by buffering excess values (bounded or unbounded): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer--">Flux#onBackpressureBuffer</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;and applying a strategy when bounded buffer also overflows: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer-int-reactor.core.publisher.BufferOverflowStrategy-">Flux#onBackpressureBuffer</a> with a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BufferOverflowStrategy.html">BufferOverflowStrategy</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.time"><a class="anchor" href="#which.time"></a>A.6. Working with Time</h3>
<div class="ulist">
<ul>
<li>
<p>I want to associate emissions with a timing measured&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with best available precision and versatility of provided data: <code>timed</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timed--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timed--">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsed--">Timed&lt;T&gt;#elapsed()</a> for <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a> since last <code>onNext</code></p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#timestamp--">Timed&lt;T&gt;#timestamp()</a> for <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html?is-external=true">Instant</a> representation of the epoch timestamp (milliseconds resolution)</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsedSinceSubscription--">Timed&lt;T&gt;#elapsedSinceSubcription()</a> for <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a> since subscription (rather than last onNext)</p>
</li>
<li>
<p>can have nanoseconds resolution for elapsed <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a>s</p>
</li>
</ul>
</div>
</li>
<li>
<p>&#8230;&#8203;as a (legacy) <a href="https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html">Tuple2&lt;Long, T&gt;</a>&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>since last onNext: <code>elapsed</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elapsed--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#elapsed--">Mono</a>)</p>
</li>
<li>
<p>since the dawn of time (well, computer time): <code>timestamp</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timestamp--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timestamp--">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want my sequence to be interrupted if there is too much delay between emissions: <code>timeout</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-">Mono</a>)</p>
</li>
<li>
<p>I want to get ticks from a clock, regular time intervals: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#interval-java.time.Duration-">Flux#interval</a></p>
</li>
<li>
<p>I want to emit a single <code>0</code> after an initial delay: static <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delay-java.time.Duration-">Mono.delay</a>.</p>
</li>
<li>
<p>I want to introduce a delay:</p>
<div class="ulist">
<ul>
<li>
<p>between each onNext signal: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayElement-java.time.Duration-">Mono#delayElement</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delayElements-java.time.Duration-">Flux#delayElements</a></p>
</li>
<li>
<p>before the subscription happens: <code>delaySubscription</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delaySubscription-java.time.Duration-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.window"><a class="anchor" href="#which.window"></a>A.7. Splitting a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a></h3>
<div class="ulist">
<ul>
<li>
<p>I want to split a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux&lt;T&gt;</a> into a <code>Flux&lt;Flux&lt;T&gt;&gt;</code>, by a boundary criteria:</p>
<div class="ulist">
<ul>
<li>
<p>of size: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-">window(int)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with overlapping or dropping windows: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-int-">window(int, int)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>of time <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-">window(Duration)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with overlapping or dropping windows: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-java.time.Duration-">window(Duration, Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>of size OR time (window closes when count is reached or timeout elapsed): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-">windowTimeout(int, Duration)</a></p>
</li>
<li>
<p>based on a predicate on elements: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-">windowUntil</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;â¦emitting the element that triggered the boundary in the next window (<code>cutBefore</code> variant): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-boolean-">.windowUntil(predicate, true)</a></p>
</li>
<li>
<p>&#8230;&#8203;keeping the window open while elements match a predicate: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhile-java.util.function.Predicate-">windowWhile</a> (non-matching elements are not emitted)</p>
</li>
</ul>
</div>
</li>
<li>
<p>driven by an arbitrary boundary represented by onNexts in a control Publisher: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-org.reactivestreams.Publisher-">window(Publisher)</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhen-org.reactivestreams.Publisher-java.util.function.Function-">windowWhen</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to split a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux&lt;T&gt;</a> and buffer elements within boundaries together&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>into <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true">List</a>:</p>
<div class="ulist">
<ul>
<li>
<p>by a size boundary: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-">buffer(int)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with overlapping or dropping buffers: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-int-">buffer(int, int)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by a duration boundary: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-">buffer(Duration)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with overlapping or dropping buffers: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-">buffer(Duration, Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by a size OR duration boundary: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-">bufferTimeout(int, Duration)</a></p>
</li>
<li>
<p>by an arbitrary criteria boundary: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-">bufferUntil(Predicate)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;putting the element that triggered the boundary in the next buffer: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-boolean-">.bufferUntil(predicate, true)</a></p>
</li>
<li>
<p>&#8230;&#8203;buffering while predicate matches and dropping the element that triggered the boundary: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhile-java.util.function.Predicate-">bufferWhile(Predicate)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>driven by an arbitrary boundary represented by onNexts in a control Publisher: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-org.reactivestreams.Publisher-">buffer(Publisher)</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-">bufferWhen</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>into an arbitrary "collection" type <code>C</code>: use variants like <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-java.util.function.Supplier-">buffer(int, Supplier&lt;C&gt;)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to split a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux&lt;T&gt;</a> so that element that share a characteristic end up in the same sub-flux: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-">groupBy(Function&lt;T,K&gt;)</a>
TIP: Note that this returns a <code>Flux&lt;GroupedFlux&lt;K, T&gt;&gt;</code>, each inner <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html">GroupedFlux</a> shares the same <code>K</code> key accessible through <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html#key--">key()</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.blocking"><a class="anchor" href="#which.blocking"></a>A.8. Going Back to the Synchronous World</h3>
<div class="paragraph">
<p>Note: all of these methods except <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--">Mono#toFuture</a> will throw an <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html?is-external=true">UnsupportedOperatorException</a> if called from
within a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html">Scheduler</a> marked as "non-blocking only" (by default <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#parallel--">parallel()</a> and <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#single--">single()</a>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>I have a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux&lt;T&gt;</a> and I want to:</p>
<div class="ulist">
<ul>
<li>
<p>block until I can get the first element: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst--">Flux#blockFirst</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with a timeout: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst-java.time.Duration-">Flux#blockFirst(Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>block until I can get the last element (or null if empty): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast--">Flux#blockLast</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with a timeout: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast-java.time.Duration-">Flux#blockLast(Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>synchronously switch to an <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html?is-external=true">Iterable&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toIterable--">Flux#toIterable</a></p>
</li>
<li>
<p>synchronously switch to a Java 8 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toStream--">Flux#toStream</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>I have a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono&lt;T&gt;</a> and I want:</p>
<div class="ulist">
<ul>
<li>
<p>to block until I can get the value: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block--">Mono#block</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with a timeout: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block-java.time.Duration-">Mono#block(Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--">Mono#toFuture</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.multicasting"><a class="anchor" href="#which.multicasting"></a>A.9. Multicasting a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> to several <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true">Subscribers</a></h3>
<div class="ulist">
<ul>
<li>
<p>I want to connect multiple <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true">Subscriber</a> to a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a>:</p>
<div class="ulist">
<ul>
<li>
<p>and decide when to trigger the source with <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#connect--">connect()</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#publish--">publish()</a> (returns a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html">ConnectableFlux</a>)</p>
</li>
<li>
<p>and trigger the source immediately (late subscribers see later data): <code>share()</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#share--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#share--">Mono</a>)</p>
</li>
<li>
<p>and permanently connect the source when enough subscribers have registered: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#autoConnect-int-">.publish().autoConnect(n)</a></p>
</li>
<li>
<p>and automatically connect and cancel the source when subscribers go above/below the threshold: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-">.publish().refCount(n)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but giving a chance for new subscribers to come in before cancelling: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-java.time.Duration-">.publish().refCount(n, Duration)</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to cache data from a <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true">Publisher</a> and replay it to later subscribers:</p>
<div class="ulist">
<ul>
<li>
<p>up to <code>n</code> elements: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-">cache(int)</a></p>
</li>
<li>
<p>caching latest elements seen within a <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a> (Time-To-Live): <code>cache(Duration)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cache-java.time.Duration-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but retain no more than <code>n</code> elements: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-java.time.Duration-">cache(int, Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>but without immediately triggering the source: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#replay--">Flux#replay</a> (returns a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html">ConnectableFlux</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/apdx-operatorChoice.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#which-operator">Which operator do I need?</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howtoReadMarbles"><a class="anchor" href="#howtoReadMarbles"></a>Appendix B: How to read marble diagrams?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When we introduced <code>Flux</code> and <code>Mono</code>, we showed an example of a "marble diagram".
These are found throughout the javadoc in order to explain the behavior of an operator in a more visual way.</p>
</div>
<div class="paragraph">
<p>In this section we&#8217;ll dig a little deeper into the conventions used by the Reactor documentation for these marble diagrams.
First, let&#8217;s see how the most common patterns of operators are represented.</p>
</div>
<div class="paragraph">
<p>Some operators are instance methods: their output is produced by calling a method on a source <code>Flux</code> instance (like <code>Flux&lt;T&gt; output = source.fluxOperator()</code>):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/legend-operator-method.svg" alt="A common operator">
</div>
</div>
<div class="paragraph">
<p>Other operators are static methods. They can still take a source as an input parameter, like in <code>Flux&lt;T&gt; output = Flux.merge(sourceFlux1, sourcePublisher2)</code>.
These are represented like below:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/legend-operator-static.svg" alt="A static operator">
</div>
</div>
<div class="paragraph">
<p>Note that sometimes we represent multiple variants or behaviors depending on the operator&#8217;s input, in which case there&#8217;s a single operator "box", but the source and output variants are separated like below:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/legend-operator-double-source.svg" alt="An operator with two examples of input">
</div>
</div>
<div class="paragraph">
<p>These are the basic cases, yet some operators display slightly more advanced patterns.</p>
</div>
<div class="paragraph">
<p>For instance, <code>ParallelFlux</code> creates multiple rails so they have multiple output <code>Flux</code>.
These are represented one below the other, like in the following diagram:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/legend-operator-parallel.svg" alt="A parallel operator">
</div>
</div>
<div class="paragraph">
<p>Windowing operators produce a <code>Flux&lt;Flux&lt;T&gt;&gt;</code>: the main <code>Flux</code> notifies of each window opening, while inner <code>Flux</code> represent the windows content and termination.
Windows are represented as branching out of the main <code>Flux</code>, like in the following diagram:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/legend-operator-windowing.svg" alt="The output of a windowing operator">
</div>
</div>
<div class="paragraph">
<p>Sometimes, operators take a "companion publisher" as input (a <code>Flux</code>, <code>Mono</code> or arbitrary Reactive Stream <code>Publisher</code>).
Such companion publishers help to customize the operator&#8217;s behavior, which will use some of the companion&#8217;s signals as trigger for its own internal behavior.
They are represented like in the following diagram:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/legend-operator-companion.svg" alt="An operator with a companion Publisher">
</div>
</div>
<div class="paragraph">
<p>Now that we&#8217;ve seen the most common operator patterns, let&#8217;s show the graphical representation of all the different signals, events and elements that can occur in a <code>Flux</code> or <code>Mono</code>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/legend-events.svg" alt="All types of signals and events">
</div>
</div>
<div class="paragraph">
<p>Finally, in the same vein we have the graphical representation of <em>side effects</em>, which occur alongside the Reactive Stream signals:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/legend-sideEffects1.svg" alt="Side effects: representation of doOn* handlers">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/legend-sideEffects2.svg" alt="Side effects: in a diagram">
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/apdx-howtoReadMarbles.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#howtoReadMarbles">How to read marble diagrams?</a>"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="faq"><a class="anchor" href="#faq"></a>Appendix C: FAQ, Best Practices, and "How do I&#8230;&#8203;?"</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section covers the following content:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#faq.wrap-blocking">How Do I Wrap a Synchronous, Blocking Call?</a></p>
</li>
<li>
<p><a href="#faq.chain">I Used an Operator on my <code>Flux</code> but it Doesn&#8217;t Seem to Apply. What Gives?</a></p>
</li>
<li>
<p><a href="#faq.monoThen">My <code>Mono</code> <code>zipWith</code> or <code>zipWhen</code> is never called</a></p>
</li>
<li>
<p><a href="#faq.retryWhen">How to Use <code>retryWhen</code> to Emulate <code>retry(3)</code>?</a></p>
</li>
<li>
<p><a href="#faq.exponentialBackoff">How can I use <code>retryWhen</code> for Exponential Backoff?</a></p>
</li>
<li>
<p><a href="#faq.thread-affinity-publishon">How Do I Ensure Thread Affinity when I Use <code>publishOn()</code>?</a></p>
</li>
<li>
<p><a href="#faq.mdc">What Is a Good Pattern for Contextual Logging? (MDC)</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="faq.wrap-blocking"><a class="anchor" href="#faq.wrap-blocking"></a>C.1. How Do I Wrap a Synchronous, Blocking Call?</h3>
<div class="paragraph">
<p>It is often the case that a source of information is synchronous and blocking.
To deal with such sources in your Reactor applications, apply the following
pattern:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Mono blockingWrapper = Mono.fromCallable(() -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    return /* make a remote synchronous call */ <i class="conum" data-value="2"></i><b>(2)</b>
});
blockingWrapper = blockingWrapper.subscribeOn(Schedulers.boundedElastic()); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a new <code>Mono</code> by using <code>fromCallable</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Return the asynchronous, blocking resource.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ensure each subscription happens on a dedicated single-threaded worker
from <code>Schedulers.boundedElastic()</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>You should use a <code>Mono</code>, because the source returns one value. You should use
<code>Schedulers.boundedElastic</code>, because it creates a dedicated thread to wait for the
blocking resource without impacting other non-blocking processing, while also ensuring
that there is a limit to the amount of threads that can be created, and blocking tasks
that can be enqueued and deferred during a spike.</p>
</div>
<div class="paragraph">
<p>Note that <code>subscribeOn</code> does not subscribe to the <code>Mono</code>. It specifies what
kind of <code>Scheduler</code> to use when a subscribe call happens.</p>
</div>
</div>
<div class="sect2">
<h3 id="faq.chain"><a class="anchor" href="#faq.chain"></a>C.2. I Used an Operator on my <code>Flux</code> but it Doesn&#8217;t Seem to Apply. What Gives?</h3>
<div class="paragraph">
<p>Make sure that the variable you <code>.subscribe()</code> to has been affected by the
operators you think should have been applied to it.</p>
</div>
<div class="paragraph">
<p>Reactor operators are decorators. They return a different instance that wraps
the source sequence and add behavior. That is why the preferred way of using
operators is to <em>chain</em> the calls.</p>
</div>
<div class="paragraph">
<p>Compare the following two examples:</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. without chaining (incorrect)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; flux = Flux.just("something", "chain");
flux.map(secret -&gt; secret.replaceAll(".", "*")); <i class="conum" data-value="1"></i><b>(1)</b>
flux.subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The mistake is here. The result is not attached to the <code>flux</code> variable.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 26. without chaining (correct)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;String&gt; flux = Flux.just("something", "chain");
flux = flux.map(secret -&gt; secret.replaceAll(".", "*"));
flux.subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following sample is even better (because it is simpler):</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. with chaining (best)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux.just("something", "chain")
    .map(secret -&gt; secret.replaceAll(".", "*"))
    .subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first version outputs the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Received: something
Received: chain</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The two other versions output the expected values, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Received: *********
Received: *****</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.monoThen"><a class="anchor" href="#faq.monoThen"></a>C.3. My <code>Mono</code> <code>zipWith</code> or <code>zipWhen</code> is never called</h3>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">myMethod.process("a") // this method returns Mono&lt;Void&gt;
        .zipWith(myMethod.process("b"), combinator) //this is never called
        .subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the source <code>Mono</code> is either <code>empty</code> or a <code>Mono&lt;Void&gt;</code> (a <code>Mono&lt;Void&gt;</code> is
empty for all intents and purposes), some combinations are never called.</p>
</div>
<div class="paragraph">
<p>This is the typical case for any transformer such as the <code>zip</code> static method or
the <code>zipWith</code> <code>zipWhen</code> operators, which (by definition) need an element from each
source to produce their output.</p>
</div>
<div class="paragraph">
<p>Using data-suppressing operators on sources of <code>zip</code> is thus problematic.
Examples of data-suppressing operators include <code>then()</code>, <code>thenEmpty(Publisher&lt;Void&gt;)</code>,
<code>ignoreElements()</code> and <code>ignoreElement()</code>, and <code>when(Publisher&#8230;&#8203;)</code>.</p>
</div>
<div class="paragraph">
<p>Similarly, operators that use a <code>Function&lt;T,?&gt;</code> to tune their behavior, such as <code>flatMap</code>,
need at least one element to be emitted for the <code>Function</code> to have a chance
to apply. Applying these on an empty (or <code>&lt;Void&gt;</code>) sequence nevers produce an element.</p>
</div>
<div class="paragraph">
<p>You can use <code>.defaultIfEmpty(T)</code> and <code>.switchIfEmpty(Publisher&lt;T&gt;)</code> to
replace an empty sequence of <code>T</code> with a default value or a fallback <code>Publisher&lt;T&gt;</code> (respectively),
which could help avoid some of these situations. Note that this does not apply to
<code>Flux&lt;Void&gt;</code>/<code>Mono&lt;Void&gt;</code> sources, as you can only switch to another <code>Publisher&lt;Void&gt;</code>,
which is still guaranteed to be empty. The following example uses <code>defaultIfEmpty</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. use <code>defaultIfEmpty</code> before <code>zipWhen</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">myMethod.emptySequenceForKey("a") // this method returns empty Mono&lt;String&gt;
        .defaultIfEmpty("") // this converts empty sequence to just the empty String
        .zipWhen(aString -&gt; myMethod.process("b")) //this is called with the empty String
        .subscribe();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.retryWhen"><a class="anchor" href="#faq.retryWhen"></a>C.4. How to Use <code>retryWhen</code> to Emulate <code>retry(3)</code>?</h3>
<div class="paragraph">
<p>The <code>retryWhen</code> operator can be quite complex. Hopefully the following snippet of code
can help you understand how it works by attempting to emulate a simpler
<code>retry(3)</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
		Flux.&lt;String&gt;error(new IllegalArgumentException())
				.doOnError(e -&gt; errorCount.incrementAndGet())
				.retryWhen(Retry.from(companion -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
						companion.map(rs -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
							if (rs.totalRetries() &lt; 3) return rs.totalRetries(); <i class="conum" data-value="3"></i><b>(3)</b>
							else throw Exceptions.propagate(rs.failure()); <i class="conum" data-value="4"></i><b>(4)</b>
						})
				));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We customize <code>Retry</code> by adapting from a <code>Function</code> lambda rather than providing a concrete class</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The companion emits <code>RetrySignal</code> objects, which bear number of retries so far and last failure</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>To allow for three retries, we consider indexes &lt; 3 and return a value to emit (here we simply return the index).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In order to terminate the sequence in error, we throw the original exception after
these three retries.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.exponentialBackoff"><a class="anchor" href="#faq.exponentialBackoff"></a>C.5. How can I use <code>retryWhen</code> for Exponential Backoff?</h3>
<div class="paragraph">
<p>Exponential backoff produces retry attempts with a growing delay between each
of the attempts, so as not to overload the source systems and risk an all-out
crash. The rationale is that, if the source produces an error, it is already in
an unstable state and is not likely to immediately recover from it. So blindly
retrying immediately is likely to produce yet another error and add to the
instability.</p>
</div>
<div class="paragraph">
<p>Since <code>3.3.4.RELEASE</code>, Reactor comes with a builder for such a retry, to be used with <code>Flux#retryWhen</code>: <code>Retry.backoff</code>.</p>
</div>
<div class="paragraph">
<p>The following example showcases a simple use of the builder, with hooks logging message right before
and after the retry attempt delays.
It delays retries and increases the delay between each attempt (pseudocode:
delay = 100ms * 2^attempt_number_starting_at_zero):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
Flux.&lt;String&gt;error(new IllegalStateException("boom"))
		.doOnError(e -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
			errorCount.incrementAndGet();
			System.out.println(e + " at " + LocalTime.now());
		})
		.retryWhen(Retry
				.backoff(3, Duration.ofMillis(100)).jitter(0d) <i class="conum" data-value="2"></i><b>(2)</b>
				.doAfterRetry(rs -&gt; System.out.println("retried at " + LocalTime.now() + ", attempt " + rs.totalRetries())) <i class="conum" data-value="3"></i><b>(3)</b>
				.onRetryExhaustedThrow((spec, rs) -&gt; rs.failure()) <i class="conum" data-value="4"></i><b>(4)</b>
		);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We will log the time of errors emitted by the source and count them.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We configure an exponential backoff retry with at most 3 attempts and no jitter.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We also log the time at which the retry happens, and the retry attempt number (starting from 0).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>By default, an <code>Exceptions.retryExhausted</code> exception would be thrown, with the last <code>failure()</code> as a cause.
Here we customize that to directly emit the cause as <code>onError</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>When subscribed to, this fails and terminates after printing out the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>java.lang.IllegalStateException: boom at 00:00:00.0
retried at 00:00:00.101, attempt 0 <i class="conum" data-value="1"></i><b>(1)</b>
java.lang.IllegalStateException: boom at 00:00:00.101
retried at 00:00:00.304, attempt 1 <i class="conum" data-value="2"></i><b>(2)</b>
java.lang.IllegalStateException: boom at 00:00:00.304
retried at 00:00:00.702, attempt 2 <i class="conum" data-value="3"></i><b>(3)</b>
java.lang.IllegalStateException: boom at 00:00:00.702</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First retry after about 100ms</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Second retry after about 200ms</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Third retry after about 400ms</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.thread-affinity-publishon"><a class="anchor" href="#faq.thread-affinity-publishon"></a>C.6. How Do I Ensure Thread Affinity when I Use <code>publishOn()</code>?</h3>
<div class="paragraph">
<p>As described in <a href="#schedulers">Schedulers</a>, <code>publishOn()</code> can be used to switch
execution contexts. The <code>publishOn</code> operator influences the threading context
where the rest of the operators in the chain below it run, up to a new
occurrence of <code>publishOn</code>. So the placement of <code>publishOn</code> is significant.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Flux&lt;Integer&gt; source = Sinks.many().unicast().onBackpressureBuffer().asFlux();
source.publishOn(scheduler1)
	  .map(i -&gt; transform(i))
	  .publishOn(scheduler2)
	  .doOnNext(i -&gt; processNext(i))
	  .subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>transform</code> function in <code>map()</code> is
run on a worker of <code>scheduler1</code>, and the <code>processNext</code> method in
<code>doOnNext()</code> is run on a worker of <code>scheduler2</code>. Each subscription gets
its own worker, so all elements pushed to the corresponding subscriber are published
on the same <code>Thread</code>.</p>
</div>
<div class="paragraph">
<p>You can use single-threaded schedulers to ensure thread affinity for different stages in the
chain or for different subscribers.</p>
</div>
</div>
<div class="sect2">
<h3 id="faq.mdc"><a class="anchor" href="#faq.mdc"></a>C.7. What Is a Good Pattern for Contextual Logging? (MDC)</h3>
<div class="paragraph">
<p>Most logging frameworks allow contextual logging, letting users store variables that are reflected in the logging pattern, generally by way of a <code>Map</code> called the MDC ("Mapped Diagnostic Context").
This is one of the most recurring use of <code>ThreadLocal</code> in Java, and as a consequence this pattern assumes that the code being logged is tied in a one-to-one relationship with a <code>Thread</code>.</p>
</div>
<div class="paragraph">
<p>That might have been a safe assumption to make before Java 8, but with the advent of functional programming elements in the Java language things have changed a bit&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take the example of a API that was imperative and used the template method pattern, then switches to a more functional style.
With the template method pattern, inheritance was at play. Now in its more functional approach, higher order functions are passed to define the "steps" of the algorithm.
Things are now more declarative than imperative, and that frees the library to make decisions about where each step should run.
For instance, knowing which steps of the underlying algorithm can be parallelized, the library can use an <code>ExecutorService</code> to execute some of the steps in parallel.</p>
</div>
<div class="paragraph">
<p>One concrete example of such a functional API is the <code>Stream</code> API introduced in Java 8 and its <code>parallel()</code> flavor.
Logging with a MDC in a parallel <code>Stream</code> is not a free lunch: one need to ensure the MDC is captured and reapplied in each step.</p>
</div>
<div class="paragraph">
<p>The functional style enables such optimizations, because each step is thread-agnostic and referentially transparent, but it can break the MDC assumption of a single <code>Thread</code>.
The most idiomatic way of ensuring any kind of contextual information is accessible to all stages would be to pass that context around through the composition chain.
During the development of Reactor we encountered the same general class of problem, and we wanted to avoid this very hands-down and explicit approach.
This is why the <code>Context</code> was introduced: it propagates through the execution chain as long as <code>Flux</code> and <code>Mono</code> are used as the return value, by letting stages (operators) peek at the <code>Context</code> of their downstream stage.
So instead of using <code>ThreadLocal</code>, Reactor offers this map-like object that is tied to a <code>Subscription</code> and not a <code>Thread</code>.</p>
</div>
<div class="paragraph">
<p>Now that we&#8217;ve established that MDC "just working" is not the best assumption to make in a declarative API, how can we perform contextualized log statements in relation to events in a Reactive Stream (<code>onNext</code>, <code>onError</code>, and <code>onComplete</code>)?</p>
</div>
<div class="paragraph">
<p>This entry of the FAQ offers a possible intermediate solution when one wants to log in relation to these signals in a straightforward and explicit manner.
Make sure to read the <a href="#context">Adding a Context to a Reactive Sequence</a> section beforehand, and especially how a write must happen towards the bottom of the operator chain for operators above it to see it.</p>
</div>
<div class="paragraph">
<p>To get contextual information from the <code>Context</code> to the MDC, the simplest way is to wrap logging statements in a <code>doOnEach</code> operator with a little bit of boilerplate code.
This boilerplate depends on both the logging framework/abstraction of your choice and the information you want to put in the MDC, so it has to be in your codebase.</p>
</div>
<div class="paragraph">
<p>The following is an example of such a helper function around a single MDC variable and focused on logging <code>onNext</code> events, using Java 9 enhanced <code>Optional</code> API:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static &lt;T&gt; Consumer&lt;Signal&lt;T&gt;&gt; logOnNext(Consumer&lt;T&gt; logStatement) {
	return signal -&gt; {
		if (!signal.isOnNext()) return; <i class="conum" data-value="1"></i><b>(1)</b>
		Optional&lt;String&gt; toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY"); <i class="conum" data-value="2"></i><b>(2)</b>

		toPutInMdc.ifPresentOrElse(tpim -&gt; {
			try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) { <i class="conum" data-value="3"></i><b>(3)</b>
				logStatement.accept(signal.get()); <i class="conum" data-value="4"></i><b>(4)</b>
			}
		},
		() -&gt; logStatement.accept(signal.get())); <i class="conum" data-value="5"></i><b>(5)</b>
	};
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>doOnEach</code> signals include <code>onComplete</code> and <code>onError</code>. In this example we&#8217;re only interested in logging <code>onNext</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We will extract one interesting value from the Reactor <code>Context</code> (see the <a href="#context.api">The <code>Context</code> API</a> section)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We use the <code>MDCCloseable</code> from SLF4J 2 in this example, allowing try-with-resource syntax for automatic cleanup of the MDC after the log statement is executed</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Proper log statement is provided by the caller as a <code>Consumer&lt;T&gt;</code> (consumer of the onNext value)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>In case the expected key wasn&#8217;t set in the <code>Context</code> we use the alternative path where nothing is put in the MDC</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Using this boilerplate code ensures that we are good citizens with the MDC: we set a key right before we execute a logging statement and remove it immediately after.
There is no risk of polluting the MDC for subsequent logging statements.</p>
</div>
<div class="paragraph">
<p>Of course, this is a suggestion. You might be interested in extracting multiple values from the <code>Context</code> or in logging things in case of <code>onError</code>.
You might want to create additional helper methods for these cases or craft a single method that makes use of additional lambdas to cover more ground.</p>
</div>
<div class="paragraph">
<p>In any case, the usage of the preceding helper method could look like the following reactive web controller:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@GetMapping("/byPrice")
public Flux&lt;Restaurant&gt; byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
	String apiId = userId == null ? "" : userId; <i class="conum" data-value="1"></i><b>(1)</b>

	return restaurantService.byPrice(maxPrice))
			   .doOnEach(logOnNext(r -&gt; LOG.debug("found restaurant {} for ${}", <i class="conum" data-value="2"></i><b>(2)</b>
					r.getName(), r.getPricePerPerson())))
			   .contextWrite(Context.of("CONTEXT_KEY", apiId)); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We need to get the contextual information from the request header to put it in the <code>Context</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we apply our helper method to the <code>Flux</code>, using <code>doOnEach</code>. Remember: operators see <code>Context</code> values defined below them.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We write the value from the header to the <code>Context</code> using the chosen key <code>CONTEXT_KEY</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In this configuration, the <code>restaurantService</code> can emit its data on a shared thread, yet the logs will still reference the correct <code>X-UserId</code> for each request.</p>
</div>
<div class="paragraph">
<p>For completeness, we can also see what an error-logging helper could look like:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static Consumer&lt;Signal&lt;?&gt;&gt; logOnError(Consumer&lt;Throwable&gt; errorLogStatement) {
	return signal -&gt; {
		if (!signal.isOnError()) return;
		Optional&lt;String&gt; toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY");

		toPutInMdc.ifPresentOrElse(tpim -&gt; {
			try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) {
				errorLogStatement.accept(signal.getThrowable());
			}
		},
		() -&gt; errorLogStatement.accept(signal.getThrowable()));
	};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Nothing much has changed, except for the fact that we check that the <code>Signal</code> is effectively an <code>onError</code>, and that we provide said error (a <code>Throwable</code>) to the log statement lambda.</p>
</div>
<div class="paragraph">
<p>Applying this helper in the controller is very similar to what we&#8217;ve done before:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@GetMapping("/byPrice")
public Flux&lt;Restaurant&gt; byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
	String apiId = userId == null ? "" : userId;

	return restaurantService.byPrice(maxPrice))
			   .doOnEach(logOnNext(v -&gt; LOG.info("found restaurant {}", v))
			   .doOnEach(logOnError(e -&gt; LOG.error("error when searching restaurants", e)) <i class="conum" data-value="1"></i><b>(1)</b>
			   .contextWrite(Context.of("CONTEXT_KEY", apiId));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In case the <code>restaurantService</code> emits an error, it will be logged with MDC context here</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/faq.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#faq">FAQ, Best Practices, and "How do I&#8230;&#8203;?"</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactor-extra"><a class="anchor" href="#reactor-extra"></a>Appendix D: Reactor-Extra</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>reactor-extra</code> artifact contains additional operators and utilities that are for
users of <code>reactor-core</code> with advanced needs, or incubating operators.</p>
</div>
<div class="paragraph">
<p>As this is a separate artifact, you need to explicitly add it to your build. The following
example shows how to do so in Gradle:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">dependencies {
     compile 'io.projectreactor:reactor-core'
     compile 'io.projectreactor.addons:reactor-extra' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add the reactor extra artifact in addition to core. See <a href="#getting">Getting Reactor</a> for details
about why you do not need to specify a version if you use the BOM, usage in Maven, and other details.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extra-tuples"><a class="anchor" href="#extra-tuples"></a>D.1. <code>TupleUtils</code> and Functional Interfaces</h3>
<div class="paragraph">
<p>The <code>reactor.function</code> package contains functional interfaces that complement the Java 8
<code>Function</code>, <code>Predicate</code>, and <code>Consumer</code> interfaces, for three to eight values.</p>
</div>
<div class="paragraph">
<p><code>TupleUtils</code> offers static methods that act as a bridge between lambdas of these functional
interfaces to a similar interface on the corresponding <code>Tuple</code>.</p>
</div>
<div class="paragraph">
<p>This lets you easily work with independent parts of any <code>Tuple</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.map(tuple -&gt; {
  String firstName = tuple.getT1();
  String lastName = tuple.getT2();
  String address = tuple.getT3();

  return new Customer(firstName, lastName, address);
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can rewrite the preceding example as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">.map(TupleUtils.function(Customer::new)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>(as <code>Customer</code> constructor conforms to <code>Function3</code> functional interface signature)</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extra-math"><a class="anchor" href="#extra-math"></a>D.2. Math Operators With <code>MathFlux</code></h3>
<div class="paragraph">
<p>The <code>reactor.math</code> package contains a <code>MathFlux</code> specialized version of <code>Flux</code> that offers
mathematical operators, including <code>max</code>, <code>min</code>, <code>sumInt</code>, <code>averageDouble</code>, and others.</p>
</div>
</div>
<div class="sect2">
<h3 id="extra-schedulers"><a class="anchor" href="#extra-schedulers"></a>D.3. Schedulers</h3>
<div class="paragraph">
<p>Reactor-extra comes with the <code>ForkJoinPoolScheduler</code> (in the <code>reactor.scheduler.forkjoin</code> package): it uses the Java <code>ForkJoinPool</code> to execute tasks.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/apdx-reactorExtra.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#reactor-extra">Reactor-Extra</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 3.5.0-SNAPSHOT<br>
Last updated 2022-05-22 07:33:35 +0900
</div>
</div>
<link rel="stylesheet" href="./highlight/styles/railscasts.min.css">
<script src="./highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>